From: Etienne Millon <me@emillon.org>
Subject: Fix header path

Move headers so that the main files are <libtcod.{h,hpp}> and the different
modules in <libtcod/*.h>.

--- a/include/libtcod.h
+++ b/include/libtcod.h
@@ -173,25 +173,25 @@
 #define CLAMP(a, b, x)		((x) < (a) ? (a) : ((x) > (b) ? (b) : (x)))
 #define LERP(a, b, x) ( a + x * (b - a) )
 
-#include "list.h"
-#include "color.h"
-#include "console.h"
-#include "image.h"
-#include "mouse.h"
-#include "sys.h"
-#include "mersenne.h"
-#include "bresenham.h"
-#include "noise.h"
-#include "fov.h"
-#include "path.h"
-#include "lex.h"
-#include "parser.h"
-#include "tree.h"
-#include "bsp.h"
-#include "heightmap.h"
-#include "zip.h"
-#include "namegen.h"
-#include "txtfield.h"
+#include <libtcod/list.h>
+#include <libtcod/color.h>
+#include <libtcod/console.h>
+#include <libtcod/image.h>
+#include <libtcod/mouse.h>
+#include <libtcod/sys.h>
+#include <libtcod/mersenne.h>
+#include <libtcod/bresenham.h>
+#include <libtcod/noise.h>
+#include <libtcod/fov.h>
+#include <libtcod/path.h>
+#include <libtcod/lex.h>
+#include <libtcod/parser.h>
+#include <libtcod/tree.h>
+#include <libtcod/bsp.h>
+#include <libtcod/heightmap.h>
+#include <libtcod/zip.h>
+#include <libtcod/namegen.h>
+#include <libtcod/txtfield.h>
 #ifdef __cplusplus
 #undef bool
 }
--- a/include/bresenham.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_BRESENHAM_H
-#define _TCOD_BRESENHAM_H
-
-typedef bool (*TCOD_line_listener_t) (int x, int y);
-
-TCODLIB_API void TCOD_line_init(int xFrom, int yFrom, int xTo, int yTo);
-TCODLIB_API bool TCOD_line_step(int *xCur, int *yCur); /* advance one step. returns true if we reach destination */
-/* atomic callback function. Stops when the callback returns false */
-TCODLIB_API bool TCOD_line(int xFrom, int yFrom, int xTo, int yTo, TCOD_line_listener_t listener);
-
-/* thread-safe versions */
-typedef struct {
-	int stepx;
-	int stepy;
-	int e;
-	int deltax;
-	int deltay;
-	int origx; 
-	int origy; 
-	int destx; 
-	int desty; 
-} TCOD_bresenham_data_t;
-
-TCODLIB_API void TCOD_line_init_mt(int xFrom, int yFrom, int xTo, int yTo, TCOD_bresenham_data_t *data);
-TCODLIB_API bool TCOD_line_step_mt(int *xCur, int *yCur, TCOD_bresenham_data_t *data);
-TCODLIB_API bool TCOD_line_mt(int xFrom, int yFrom, int xTo, int yTo, TCOD_line_listener_t listener, TCOD_bresenham_data_t *data);
-
-#endif
--- a/include/bsp.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_BSP_H
-#define _TCOD_BSP_H
-
-typedef struct {
-	TCOD_tree_t tree; /* pseudo oop : bsp inherit tree */
-	int x,y,w,h; /* node position & size */
-	int position; /* position of splitting */
-	uint8 level; /* level in the tree */
-	bool horizontal; /* horizontal splitting ? */
-} TCOD_bsp_t;
-
-typedef bool (*TCOD_bsp_callback_t)(TCOD_bsp_t *node, void *userData);
-
-TCODLIB_API TCOD_bsp_t *TCOD_bsp_new();
-TCODLIB_API TCOD_bsp_t *TCOD_bsp_new_with_size(int x,int y,int w, int h);
-TCODLIB_API void TCOD_bsp_delete(TCOD_bsp_t *node);
-
-TCODLIB_API TCOD_bsp_t * TCOD_bsp_left(TCOD_bsp_t *node);
-TCODLIB_API TCOD_bsp_t * TCOD_bsp_right(TCOD_bsp_t *node);
-TCODLIB_API TCOD_bsp_t * TCOD_bsp_father(TCOD_bsp_t *node);
-
-TCODLIB_API bool TCOD_bsp_is_leaf(TCOD_bsp_t *node);
-TCODLIB_API bool TCOD_bsp_traverse_pre_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
-TCODLIB_API bool TCOD_bsp_traverse_in_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
-TCODLIB_API bool TCOD_bsp_traverse_post_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
-TCODLIB_API bool TCOD_bsp_traverse_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
-TCODLIB_API bool TCOD_bsp_traverse_inverted_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
-TCODLIB_API bool TCOD_bsp_contains(TCOD_bsp_t *node, int x, int y);
-TCODLIB_API TCOD_bsp_t * TCOD_bsp_find_node(TCOD_bsp_t *node, int x, int y);
-TCODLIB_API void TCOD_bsp_resize(TCOD_bsp_t *node, int x,int y, int w, int h);
-TCODLIB_API void TCOD_bsp_split_once(TCOD_bsp_t *node, bool horizontal, int position);
-TCODLIB_API void TCOD_bsp_split_recursive(TCOD_bsp_t *node, TCOD_random_t randomizer, int nb, 
-		int minHSize, int minVSize, float maxHRatio, float maxVRatio);
-TCODLIB_API void TCOD_bsp_remove_sons(TCOD_bsp_t *node);
-
-#endif
--- a/include/color.h
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_COLOR_H
-#define _TCOD_COLOR_H
-
-typedef struct {
-	uint8 r,g,b;
-} TCOD_color_t;
-
-/* constructors */
-TCODLIB_API TCOD_color_t TCOD_color_RGB(uint8 r, uint8 g, uint8 b);
-TCODLIB_API TCOD_color_t TCOD_color_HSV(float h, float s, float v);
-/* basic operations */
-TCODLIB_API bool TCOD_color_equals (TCOD_color_t c1, TCOD_color_t c2);
-TCODLIB_API TCOD_color_t TCOD_color_add (TCOD_color_t c1, TCOD_color_t c2);
-TCODLIB_API TCOD_color_t TCOD_color_subtract (TCOD_color_t c1, TCOD_color_t c2);
-TCODLIB_API TCOD_color_t TCOD_color_multiply (TCOD_color_t c1, TCOD_color_t c2);
-TCODLIB_API TCOD_color_t TCOD_color_multiply_scalar (TCOD_color_t c1, float value);
-TCODLIB_API TCOD_color_t TCOD_color_lerp (TCOD_color_t c1, TCOD_color_t c2, float coef);
-/* HSV transformations */
-TCODLIB_API void TCOD_color_set_HSV (TCOD_color_t *c,float h, float s, float v);
-TCODLIB_API void TCOD_color_get_HSV (TCOD_color_t c,float * h, float * s, float * v);
-TCODLIB_API float TCOD_color_get_hue (TCOD_color_t c);
-TCODLIB_API void TCOD_color_set_hue (TCOD_color_t *c, float h);
-TCODLIB_API float TCOD_color_get_saturation (TCOD_color_t c);
-TCODLIB_API void TCOD_color_set_saturation (TCOD_color_t *c, float s);
-TCODLIB_API float TCOD_color_get_value (TCOD_color_t c);
-TCODLIB_API void TCOD_color_set_value (TCOD_color_t *c, float v);
-TCODLIB_API void TCOD_color_shift_hue (TCOD_color_t *c, float hshift);
-TCODLIB_API void TCOD_color_scale_HSV (TCOD_color_t *c, float scoef, float vcoef);
-/* color map */
-TCODLIB_API void TCOD_color_gen_map(TCOD_color_t *map, int nb_key, TCOD_color_t const *key_color, int const *key_index);
-
-/* color names */
-enum {
-	TCOD_COLOR_RED,
-	TCOD_COLOR_FLAME,
-	TCOD_COLOR_ORANGE,
-	TCOD_COLOR_AMBER,
-	TCOD_COLOR_YELLOW,
-	TCOD_COLOR_LIME,
-	TCOD_COLOR_CHARTREUSE,
-	TCOD_COLOR_GREEN,
-	TCOD_COLOR_SEA,
-	TCOD_COLOR_TURQUOISE,
-	TCOD_COLOR_CYAN,
-	TCOD_COLOR_SKY,
-	TCOD_COLOR_AZURE,
-	TCOD_COLOR_BLUE,
-	TCOD_COLOR_HAN,
-	TCOD_COLOR_VIOLET,
-	TCOD_COLOR_PURPLE,
-	TCOD_COLOR_FUCHSIA,
-	TCOD_COLOR_MAGENTA,
-	TCOD_COLOR_PINK,
-	TCOD_COLOR_CRIMSON,
-	TCOD_COLOR_NB
-};
-
-/* color levels */
-enum {
-	TCOD_COLOR_DESATURATED,
-	TCOD_COLOR_LIGHTEST,
-	TCOD_COLOR_LIGHTER,
-	TCOD_COLOR_LIGHT,
-	TCOD_COLOR_NORMAL,
-	TCOD_COLOR_DARK,
-	TCOD_COLOR_DARKER,
-	TCOD_COLOR_DARKEST,
-	TCOD_COLOR_LEVELS
-};
-
-/* color array */
-extern TCODLIB_API const TCOD_color_t  TCOD_colors[TCOD_COLOR_NB][TCOD_COLOR_LEVELS];
-
-/* grey levels */
-extern TCODLIB_API const TCOD_color_t TCOD_black;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_light_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_grey;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_light_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_gray;
-extern TCODLIB_API const TCOD_color_t TCOD_white;
-
-/* sepia */
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_sepia;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_sepia;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_sepia;
-extern TCODLIB_API const TCOD_color_t TCOD_sepia;
-extern TCODLIB_API const TCOD_color_t TCOD_light_sepia;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_sepia;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_sepia;
-
-/* standard colors */
-extern TCODLIB_API const TCOD_color_t TCOD_red;
-extern TCODLIB_API const TCOD_color_t TCOD_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_green;
-extern TCODLIB_API const TCOD_color_t TCOD_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_han;
-extern TCODLIB_API const TCOD_color_t TCOD_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_crimson;
-
-/* dark colors */
-extern TCODLIB_API const TCOD_color_t TCOD_dark_red;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_green;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_han;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_dark_crimson;
-
-/* darker colors */
-extern TCODLIB_API const TCOD_color_t TCOD_darker_red;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_green;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_han;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_darker_crimson;
-
-/* darkest colors */
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_red;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_green;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_han;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_darkest_crimson;
-
-/* light colors */
-extern TCODLIB_API const TCOD_color_t TCOD_light_red;
-extern TCODLIB_API const TCOD_color_t TCOD_light_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_light_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_light_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_light_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_light_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_light_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_light_green;
-extern TCODLIB_API const TCOD_color_t TCOD_light_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_light_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_light_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_light_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_light_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_light_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_light_han;
-extern TCODLIB_API const TCOD_color_t TCOD_light_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_light_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_light_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_light_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_light_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_light_crimson;
-
-/* lighter colors */
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_red;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_green;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_han;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_lighter_crimson;
-
-/* lightest colors */
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_red;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_green;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_han;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_lightest_crimson;
-
-/* desaturated */
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_red;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_flame;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_orange;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_amber;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_yellow;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_lime;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_chartreuse;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_green;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_sea;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_turquoise;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_cyan;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_sky;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_azure;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_blue;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_han;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_violet;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_purple;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_fuchsia;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_magenta;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_pink;
-extern TCODLIB_API const TCOD_color_t TCOD_desaturated_crimson;
-
-/* metallic */
-extern TCODLIB_API const TCOD_color_t TCOD_brass;
-extern TCODLIB_API const TCOD_color_t TCOD_copper;
-extern TCODLIB_API const TCOD_color_t TCOD_gold;
-extern TCODLIB_API const TCOD_color_t TCOD_silver;
-
-/* miscellaneous */
-extern TCODLIB_API const TCOD_color_t TCOD_celadon;
-extern TCODLIB_API const TCOD_color_t TCOD_peach;
-
-#endif
--- a/include/console.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_CONSOLE_H
-#define _TCOD_CONSOLE_H
-
-#include "console_types.h"
-
-#define TCOD_BKGND_ALPHA(alpha) ((TCOD_bkgnd_flag_t)(TCOD_BKGND_ALPH|(((uint8)(alpha*255))<<8)))
-#define TCOD_BKGND_ADDALPHA(alpha) ((TCOD_bkgnd_flag_t)(TCOD_BKGND_ADDA|(((uint8)(alpha*255))<<8)))
-
-typedef void * TCOD_console_t;
-
-TCODLIB_API void TCOD_console_init_root(int w, int h, const char * title, bool fullscreen, TCOD_renderer_t renderer);
-TCODLIB_API void TCOD_console_set_window_title(const char *title);
-TCODLIB_API void TCOD_console_set_fullscreen(bool fullscreen);
-TCODLIB_API bool TCOD_console_is_fullscreen();
-TCODLIB_API bool TCOD_console_is_window_closed();
-
-TCODLIB_API void TCOD_console_set_custom_font(const char *fontFile, int flags,int nb_char_horiz, int nb_char_vertic);
-TCODLIB_API void TCOD_console_map_ascii_code_to_font(int asciiCode, int fontCharX, int fontCharY);
-TCODLIB_API void TCOD_console_map_ascii_codes_to_font(int asciiCode, int nbCodes, int fontCharX, int fontCharY);
-TCODLIB_API void TCOD_console_map_string_to_font(const char *s, int fontCharX, int fontCharY);
-
-TCODLIB_API void TCOD_console_set_dirty(int x, int y, int w, int h);
-TCODLIB_API void TCOD_console_set_default_background(TCOD_console_t con,TCOD_color_t col);
-TCODLIB_API void TCOD_console_set_default_foreground(TCOD_console_t con,TCOD_color_t col);
-TCODLIB_API void TCOD_console_clear(TCOD_console_t con);
-TCODLIB_API void TCOD_console_set_char_background(TCOD_console_t con,int x, int y, TCOD_color_t col, TCOD_bkgnd_flag_t flag);
-TCODLIB_API void TCOD_console_set_char_foreground(TCOD_console_t con,int x, int y, TCOD_color_t col);
-TCODLIB_API void TCOD_console_set_char(TCOD_console_t con,int x, int y, int c);
-TCODLIB_API void TCOD_console_put_char(TCOD_console_t con,int x, int y, int c, TCOD_bkgnd_flag_t flag);
-TCODLIB_API void TCOD_console_put_char_ex(TCOD_console_t con,int x, int y, int c, TCOD_color_t fore, TCOD_color_t back);
-
-TCODLIB_API void TCOD_console_set_background_flag(TCOD_console_t con,TCOD_bkgnd_flag_t flag);
-TCODLIB_API TCOD_bkgnd_flag_t TCOD_console_get_background_flag(TCOD_console_t con);
-TCODLIB_API void TCOD_console_set_alignment(TCOD_console_t con,TCOD_alignment_t alignment);
-TCODLIB_API TCOD_alignment_t TCOD_console_get_alignment(TCOD_console_t con);
-TCODLIB_API void TCOD_console_print(TCOD_console_t con,int x, int y, const char *fmt, ...);
-TCODLIB_API void TCOD_console_print_ex(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
-TCODLIB_API int TCOD_console_print_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...);
-TCODLIB_API int TCOD_console_print_rect_ex(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
-TCODLIB_API int TCOD_console_get_height_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...);
-
-TCODLIB_API void TCOD_console_rect(TCOD_console_t con,int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag);
-TCODLIB_API void TCOD_console_hline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag);
-TCODLIB_API void TCOD_console_vline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag);
-TCODLIB_API void TCOD_console_print_frame(TCOD_console_t con,int x,int y,int w,int h, bool empty, TCOD_bkgnd_flag_t flag, const char *fmt, ...);
-
-#ifndef NO_UNICODE
-/* unicode support */
-TCODLIB_API void TCOD_console_map_string_to_font_utf(const wchar_t *s, int fontCharX, int fontCharY);
-TCODLIB_API void TCOD_console_print_utf(TCOD_console_t con,int x, int y, const wchar_t *fmt, ...);
-TCODLIB_API void TCOD_console_print_ex_utf(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
-TCODLIB_API int TCOD_console_print_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...);
-TCODLIB_API int TCOD_console_print_rect_ex_utf(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
-TCODLIB_API int TCOD_console_get_height_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...);
-#endif
-
-
-TCODLIB_API TCOD_color_t TCOD_console_get_default_background(TCOD_console_t con);
-TCODLIB_API TCOD_color_t TCOD_console_get_default_foreground(TCOD_console_t con);
-TCODLIB_API TCOD_color_t TCOD_console_get_char_background(TCOD_console_t con,int x, int y);
-TCODLIB_API TCOD_color_t TCOD_console_get_char_foreground(TCOD_console_t con,int x, int y);
-TCODLIB_API int TCOD_console_get_char(TCOD_console_t con,int x, int y);
-
-TCODLIB_API void TCOD_console_set_fade(uint8 val, TCOD_color_t fade);
-TCODLIB_API uint8 TCOD_console_get_fade();
-TCODLIB_API TCOD_color_t TCOD_console_get_fading_color();
-
-TCODLIB_API void TCOD_console_flush();
-
-TCODLIB_API void TCOD_console_set_color_control(TCOD_colctrl_t con, TCOD_color_t fore, TCOD_color_t back);
-
-TCODLIB_API TCOD_key_t TCOD_console_check_for_keypress(int flags);
-TCODLIB_API TCOD_key_t TCOD_console_wait_for_keypress(bool flush);
-TCODLIB_API void TCOD_console_set_keyboard_repeat(int initial_delay, int interval);
-TCODLIB_API void TCOD_console_disable_keyboard_repeat();
-TCODLIB_API bool TCOD_console_is_key_pressed(TCOD_keycode_t key);
-
-/* ASCII paint file support */
-TCODLIB_API TCOD_console_t TCOD_console_from_file(const char *filename);
-TCODLIB_API bool TCOD_console_load_asc(TCOD_console_t con, const char *filename);
-TCODLIB_API bool TCOD_console_load_apf(TCOD_console_t con, const char *filename);
-TCODLIB_API bool TCOD_console_save_asc(TCOD_console_t con, const char *filename);
-TCODLIB_API bool TCOD_console_save_apf(TCOD_console_t con, const char *filename);
-
-TCODLIB_API TCOD_console_t TCOD_console_new(int w, int h);
-TCODLIB_API int TCOD_console_get_width(TCOD_console_t con);
-TCODLIB_API int TCOD_console_get_height(TCOD_console_t con);
-TCODLIB_API void TCOD_console_set_key_color(TCOD_console_t con,TCOD_color_t col);
-TCODLIB_API void TCOD_console_blit(TCOD_console_t src,int xSrc, int ySrc, int wSrc, int hSrc, TCOD_console_t dst, int xDst, int yDst, float foreground_alpha, float background_alpha);
-TCODLIB_API void TCOD_console_delete(TCOD_console_t console);
-
-TCODLIB_API void TCOD_console_credits();
-TCODLIB_API void TCOD_console_credits_reset();
-TCODLIB_API bool TCOD_console_credits_render(int x, int y, bool alpha);
-
-#endif
--- a/include/fov.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_FOV_H
-#define _TCOD_FOV_H
-
-typedef void *TCOD_map_t;
-
-#include "fov_types.h"
-
-/* allocate a new map */
-TCODLIB_API TCOD_map_t TCOD_map_new(int width, int height);
-/* set all cells as solid rock (cannot see through nor walk) */
-TCODLIB_API void TCOD_map_clear(TCOD_map_t map, bool transparent, bool walkable);
-/* copy a map to another, reallocating it when needed */
-TCODLIB_API void TCOD_map_copy(TCOD_map_t source, TCOD_map_t dest);
-/* change a cell properties */
-TCODLIB_API void TCOD_map_set_properties(TCOD_map_t map, int x, int y, bool is_transparent, bool is_walkable);
-/* destroy a map */
-TCODLIB_API void TCOD_map_delete(TCOD_map_t map);
-
-/* calculate the field of view (potentially visible cells from player_x,player_y) */
-TCODLIB_API void TCOD_map_compute_fov(TCOD_map_t map, int player_x, int player_y, int max_radius, bool light_walls, TCOD_fov_algorithm_t algo);
-/* check if a cell is in the last computed field of view */
-TCODLIB_API bool TCOD_map_is_in_fov(TCOD_map_t map, int x, int y);
-TCODLIB_API void TCOD_map_set_in_fov(TCOD_map_t map, int x, int y, bool fov);
-
-/* retrieve properties from the map */
-TCODLIB_API bool TCOD_map_is_transparent(TCOD_map_t map, int x, int y);
-TCODLIB_API bool TCOD_map_is_walkable(TCOD_map_t map, int x, int y);
-TCODLIB_API int TCOD_map_get_width(TCOD_map_t map);
-TCODLIB_API int TCOD_map_get_height(TCOD_map_t map);
-TCODLIB_API int TCOD_map_get_nb_cells(TCOD_map_t map);
-#endif
--- a/include/heightmap.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifndef _TCOD_HEIGHTMAP_H
-#define _TCOD_HEIGHTMAP_H
-
-typedef struct {
-	int w,h;
-	float *values;
-} TCOD_heightmap_t;
-
-TCODLIB_API TCOD_heightmap_t *TCOD_heightmap_new(int w,int h);
-TCODLIB_API void TCOD_heightmap_delete(TCOD_heightmap_t *hm);
-
-TCODLIB_API float TCOD_heightmap_get_value(const TCOD_heightmap_t *hm, int x, int y);
-TCODLIB_API float TCOD_heightmap_get_interpolated_value(const TCOD_heightmap_t *hm, float x, float y);
-TCODLIB_API void TCOD_heightmap_set_value(TCOD_heightmap_t *hm, int x, int y, float value);
-TCODLIB_API float TCOD_heightmap_get_slope(const TCOD_heightmap_t *hm, int x, int y);
-TCODLIB_API void TCOD_heightmap_get_normal(const TCOD_heightmap_t *hm, float x, float y, float n[3], float waterLevel);
-TCODLIB_API int TCOD_heightmap_count_cells(const TCOD_heightmap_t *hm, float min, float max);
-TCODLIB_API bool TCOD_heightmap_has_land_on_border(const TCOD_heightmap_t *hm, float waterLevel);
-TCODLIB_API void TCOD_heightmap_get_minmax(const TCOD_heightmap_t *hm, float *min, float *max);
-
-TCODLIB_API void TCOD_heightmap_copy(const TCOD_heightmap_t *hm_source,TCOD_heightmap_t *hm_dest);
-TCODLIB_API void TCOD_heightmap_add(TCOD_heightmap_t *hm, float value);
-TCODLIB_API void TCOD_heightmap_scale(TCOD_heightmap_t *hm, float value);
-TCODLIB_API void TCOD_heightmap_clamp(TCOD_heightmap_t *hm, float min, float max);
-TCODLIB_API void TCOD_heightmap_normalize(TCOD_heightmap_t *hm, float min, float max);
-TCODLIB_API void TCOD_heightmap_clear(TCOD_heightmap_t *hm);
-TCODLIB_API void TCOD_heightmap_lerp_hm(const TCOD_heightmap_t *hm1, const TCOD_heightmap_t *hm2, TCOD_heightmap_t *hmres, float coef);
-TCODLIB_API void TCOD_heightmap_add_hm(const TCOD_heightmap_t *hm1, const TCOD_heightmap_t *hm2, TCOD_heightmap_t *hmres);
-TCODLIB_API void TCOD_heightmap_multiply_hm(const TCOD_heightmap_t *hm1, const TCOD_heightmap_t *hm2, TCOD_heightmap_t *hmres);
-
-TCODLIB_API void TCOD_heightmap_add_hill(TCOD_heightmap_t *hm, float hx, float hy, float hradius, float hheight);
-TCODLIB_API void TCOD_heightmap_dig_hill(TCOD_heightmap_t *hm, float hx, float hy, float hradius, float hheight);
-TCODLIB_API void TCOD_heightmap_dig_bezier(TCOD_heightmap_t *hm, int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth);
-TCODLIB_API void TCOD_heightmap_rain_erosion(TCOD_heightmap_t *hm, int nbDrops,float erosionCoef,float sedimentationCoef,TCOD_random_t rnd);
-/* TCODLIB_API void TCOD_heightmap_heat_erosion(TCOD_heightmap_t *hm, int nbPass,float minSlope,float erosionCoef,float sedimentationCoef,TCOD_random_t rnd); */
-TCODLIB_API void TCOD_heightmap_kernel_transform(TCOD_heightmap_t *hm, int kernelsize, const int *dx, const int *dy, const float *weight, float minLevel,float maxLevel);
-TCODLIB_API void TCOD_heightmap_add_voronoi(TCOD_heightmap_t *hm, int nbPoints, int nbCoef, const float *coef,TCOD_random_t rnd);
-/* TCODLIB_API void TCOD_heightmap_mid_point_deplacement(TCOD_heightmap_t *hm, TCOD_random_t rnd); */
-TCODLIB_API void TCOD_heightmap_add_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale); 
-TCODLIB_API void TCOD_heightmap_scale_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale); 
-TCODLIB_API void TCOD_heightmap_islandify(TCOD_heightmap_t *hm, float seaLevel,TCOD_random_t rnd);
-
-#endif
-
--- a/include/image.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-typedef void *TCOD_image_t;
-
-TCODLIB_API TCOD_image_t TCOD_image_new(int width, int height);
-TCODLIB_API TCOD_image_t TCOD_image_from_console(TCOD_console_t console);
-TCODLIB_API void TCOD_image_refresh_console(TCOD_image_t image, TCOD_console_t console);
-TCODLIB_API TCOD_image_t TCOD_image_load(const char *filename);
-TCODLIB_API void TCOD_image_clear(TCOD_image_t image, TCOD_color_t color);
-TCODLIB_API void TCOD_image_invert(TCOD_image_t image);
-TCODLIB_API void TCOD_image_hflip(TCOD_image_t image);
-TCODLIB_API void TCOD_image_rotate90(TCOD_image_t image, int numRotations);
-TCODLIB_API void TCOD_image_vflip(TCOD_image_t image);
-TCODLIB_API void TCOD_image_scale(TCOD_image_t image, int neww, int newh);
-TCODLIB_API void TCOD_image_save(TCOD_image_t image, const char *filename);
-TCODLIB_API void TCOD_image_get_size(TCOD_image_t image, int *w,int *h);
-TCODLIB_API TCOD_color_t TCOD_image_get_pixel(TCOD_image_t image,int x, int y);
-TCODLIB_API int TCOD_image_get_alpha(TCOD_image_t image,int x, int y);
-TCODLIB_API TCOD_color_t TCOD_image_get_mipmap_pixel(TCOD_image_t image,float x0,float y0, float x1, float y1);
-TCODLIB_API void TCOD_image_put_pixel(TCOD_image_t image,int x, int y,TCOD_color_t col);
-TCODLIB_API void TCOD_image_blit(TCOD_image_t image, TCOD_console_t console, float x, float y, 
-	TCOD_bkgnd_flag_t bkgnd_flag, float scalex, float scaley, float angle);
-TCODLIB_API void TCOD_image_blit_rect(TCOD_image_t image, TCOD_console_t console, int x, int y, int w, int h, 
-	TCOD_bkgnd_flag_t bkgnd_flag);
-TCODLIB_API void TCOD_image_blit_2x(TCOD_image_t image, TCOD_console_t dest, int dx, int dy, int sx, int sy, int w, int h);
-TCODLIB_API void TCOD_image_delete(TCOD_image_t image);
-TCODLIB_API void TCOD_image_set_key_color(TCOD_image_t image, TCOD_color_t key_color);
-TCODLIB_API bool TCOD_image_is_pixel_transparent(TCOD_image_t image, int x, int y);
-
--- a/include/lex.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_LEX_H
-#define _TCOD_LEX_H
-/*
- * This is a libtcod internal module.
- * Use at your own risks...
- */
-
-#define TCOD_LEX_FLAG_NOCASE 1
-#define TCOD_LEX_FLAG_NESTING_COMMENT 2
-#define TCOD_LEX_FLAG_TOKENIZE_COMMENTS 4
-
-#define TCOD_LEX_ERROR -1
-#define TCOD_LEX_UNKNOWN 0
-#define TCOD_LEX_SYMBOL 1
-#define TCOD_LEX_KEYWORD 2
-#define TCOD_LEX_IDEN 3
-#define TCOD_LEX_STRING 4
-#define TCOD_LEX_INTEGER 5
-#define TCOD_LEX_FLOAT 6
-#define TCOD_LEX_CHAR 7
-#define TCOD_LEX_EOF 8
-#define TCOD_LEX_COMMENT 9
-
-#define TCOD_LEX_MAX_SYMBOLS 100
-#define TCOD_LEX_SYMBOL_SIZE 5
-#define TCOD_LEX_MAX_KEYWORDS 100
-#define TCOD_LEX_KEYWORD_SIZE 20
-
-typedef struct {
-	int file_line, token_type, token_int_val, token_idx;
-	float token_float_val;
-	char *tok;
-    int toklen;
-	char lastStringDelim;
-	char *pos;
-	char *buf;
-	char *filename;
-	char *last_javadoc_comment;
-	/* private stuff */
-	int nb_symbols, nb_keywords, flags;
-	char symbols[ TCOD_LEX_MAX_SYMBOLS][ TCOD_LEX_SYMBOL_SIZE ], 
-	keywords[ TCOD_LEX_MAX_KEYWORDS ][ TCOD_LEX_KEYWORD_SIZE ];
-	const char *simpleCmt;
-	const char *cmtStart, *cmtStop, *javadocCmtStart;
-	const char *stringDelim;
-	bool javadoc_read;
-	bool allocBuf;
-	bool savept; /* is this object a savepoint (no free in destructor) */	
-} TCOD_lex_t;
-
-TCODLIB_API TCOD_lex_t *TCOD_lex_new_intern();
-TCODLIB_API TCOD_lex_t *TCOD_lex_new(const char **symbols, const char **keywords, const char *simpleComment, 
-		const char *commentStart, const char *commentStop, const char *javadocCommentStart, const char *stringDelim, int flags);
-TCODLIB_API void TCOD_lex_delete(TCOD_lex_t *lex);
-
-TCODLIB_API void TCOD_lex_set_data_buffer(TCOD_lex_t *lex,char *dat);
-TCODLIB_API bool TCOD_lex_set_data_file(TCOD_lex_t *lex,const char *filename);
-
-TCODLIB_API int TCOD_lex_parse(TCOD_lex_t *lex);
-TCODLIB_API int TCOD_lex_parse_until_token_type(TCOD_lex_t *lex,int token_type);
-TCODLIB_API int TCOD_lex_parse_until_token_value(TCOD_lex_t *lex,const char *token_value);
-
-TCODLIB_API bool TCOD_lex_expect_token_type(TCOD_lex_t *lex,int token_type);
-TCODLIB_API bool TCOD_lex_expect_token_value(TCOD_lex_t *lex,int token_type,const char *token_value);
-
-TCODLIB_API void TCOD_lex_savepoint(TCOD_lex_t *lex,TCOD_lex_t *savept);
-TCODLIB_API void TCOD_lex_restore(TCOD_lex_t *lex,TCOD_lex_t *savept);
-TCODLIB_API char *TCOD_lex_get_last_javadoc(TCOD_lex_t *lex);
-TCODLIB_API const char *TCOD_lex_get_token_name(int token_type);
-TCODLIB_API char *TCOD_lex_get_last_error();
-
-TCODLIB_API int TCOD_lex_hextoint(char c);
-
-#endif
--- /dev/null
+++ b/include/libtcod/bresenham.h
@@ -0,0 +1,55 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_BRESENHAM_H
+#define _TCOD_BRESENHAM_H
+
+typedef bool (*TCOD_line_listener_t) (int x, int y);
+
+TCODLIB_API void TCOD_line_init(int xFrom, int yFrom, int xTo, int yTo);
+TCODLIB_API bool TCOD_line_step(int *xCur, int *yCur); /* advance one step. returns true if we reach destination */
+/* atomic callback function. Stops when the callback returns false */
+TCODLIB_API bool TCOD_line(int xFrom, int yFrom, int xTo, int yTo, TCOD_line_listener_t listener);
+
+/* thread-safe versions */
+typedef struct {
+	int stepx;
+	int stepy;
+	int e;
+	int deltax;
+	int deltay;
+	int origx; 
+	int origy; 
+	int destx; 
+	int desty; 
+} TCOD_bresenham_data_t;
+
+TCODLIB_API void TCOD_line_init_mt(int xFrom, int yFrom, int xTo, int yTo, TCOD_bresenham_data_t *data);
+TCODLIB_API bool TCOD_line_step_mt(int *xCur, int *yCur, TCOD_bresenham_data_t *data);
+TCODLIB_API bool TCOD_line_mt(int xFrom, int yFrom, int xTo, int yTo, TCOD_line_listener_t listener, TCOD_bresenham_data_t *data);
+
+#endif
--- /dev/null
+++ b/include/libtcod/bsp.h
@@ -0,0 +1,63 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_BSP_H
+#define _TCOD_BSP_H
+
+typedef struct {
+	TCOD_tree_t tree; /* pseudo oop : bsp inherit tree */
+	int x,y,w,h; /* node position & size */
+	int position; /* position of splitting */
+	uint8 level; /* level in the tree */
+	bool horizontal; /* horizontal splitting ? */
+} TCOD_bsp_t;
+
+typedef bool (*TCOD_bsp_callback_t)(TCOD_bsp_t *node, void *userData);
+
+TCODLIB_API TCOD_bsp_t *TCOD_bsp_new();
+TCODLIB_API TCOD_bsp_t *TCOD_bsp_new_with_size(int x,int y,int w, int h);
+TCODLIB_API void TCOD_bsp_delete(TCOD_bsp_t *node);
+
+TCODLIB_API TCOD_bsp_t * TCOD_bsp_left(TCOD_bsp_t *node);
+TCODLIB_API TCOD_bsp_t * TCOD_bsp_right(TCOD_bsp_t *node);
+TCODLIB_API TCOD_bsp_t * TCOD_bsp_father(TCOD_bsp_t *node);
+
+TCODLIB_API bool TCOD_bsp_is_leaf(TCOD_bsp_t *node);
+TCODLIB_API bool TCOD_bsp_traverse_pre_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
+TCODLIB_API bool TCOD_bsp_traverse_in_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
+TCODLIB_API bool TCOD_bsp_traverse_post_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
+TCODLIB_API bool TCOD_bsp_traverse_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
+TCODLIB_API bool TCOD_bsp_traverse_inverted_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t listener, void *userData);
+TCODLIB_API bool TCOD_bsp_contains(TCOD_bsp_t *node, int x, int y);
+TCODLIB_API TCOD_bsp_t * TCOD_bsp_find_node(TCOD_bsp_t *node, int x, int y);
+TCODLIB_API void TCOD_bsp_resize(TCOD_bsp_t *node, int x,int y, int w, int h);
+TCODLIB_API void TCOD_bsp_split_once(TCOD_bsp_t *node, bool horizontal, int position);
+TCODLIB_API void TCOD_bsp_split_recursive(TCOD_bsp_t *node, TCOD_random_t randomizer, int nb, 
+		int minHSize, int minVSize, float maxHRatio, float maxVRatio);
+TCODLIB_API void TCOD_bsp_remove_sons(TCOD_bsp_t *node);
+
+#endif
--- /dev/null
+++ b/include/libtcod/color.h
@@ -0,0 +1,322 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_COLOR_H
+#define _TCOD_COLOR_H
+
+typedef struct {
+	uint8 r,g,b;
+} TCOD_color_t;
+
+/* constructors */
+TCODLIB_API TCOD_color_t TCOD_color_RGB(uint8 r, uint8 g, uint8 b);
+TCODLIB_API TCOD_color_t TCOD_color_HSV(float h, float s, float v);
+/* basic operations */
+TCODLIB_API bool TCOD_color_equals (TCOD_color_t c1, TCOD_color_t c2);
+TCODLIB_API TCOD_color_t TCOD_color_add (TCOD_color_t c1, TCOD_color_t c2);
+TCODLIB_API TCOD_color_t TCOD_color_subtract (TCOD_color_t c1, TCOD_color_t c2);
+TCODLIB_API TCOD_color_t TCOD_color_multiply (TCOD_color_t c1, TCOD_color_t c2);
+TCODLIB_API TCOD_color_t TCOD_color_multiply_scalar (TCOD_color_t c1, float value);
+TCODLIB_API TCOD_color_t TCOD_color_lerp (TCOD_color_t c1, TCOD_color_t c2, float coef);
+/* HSV transformations */
+TCODLIB_API void TCOD_color_set_HSV (TCOD_color_t *c,float h, float s, float v);
+TCODLIB_API void TCOD_color_get_HSV (TCOD_color_t c,float * h, float * s, float * v);
+TCODLIB_API float TCOD_color_get_hue (TCOD_color_t c);
+TCODLIB_API void TCOD_color_set_hue (TCOD_color_t *c, float h);
+TCODLIB_API float TCOD_color_get_saturation (TCOD_color_t c);
+TCODLIB_API void TCOD_color_set_saturation (TCOD_color_t *c, float s);
+TCODLIB_API float TCOD_color_get_value (TCOD_color_t c);
+TCODLIB_API void TCOD_color_set_value (TCOD_color_t *c, float v);
+TCODLIB_API void TCOD_color_shift_hue (TCOD_color_t *c, float hshift);
+TCODLIB_API void TCOD_color_scale_HSV (TCOD_color_t *c, float scoef, float vcoef);
+/* color map */
+TCODLIB_API void TCOD_color_gen_map(TCOD_color_t *map, int nb_key, TCOD_color_t const *key_color, int const *key_index);
+
+/* color names */
+enum {
+	TCOD_COLOR_RED,
+	TCOD_COLOR_FLAME,
+	TCOD_COLOR_ORANGE,
+	TCOD_COLOR_AMBER,
+	TCOD_COLOR_YELLOW,
+	TCOD_COLOR_LIME,
+	TCOD_COLOR_CHARTREUSE,
+	TCOD_COLOR_GREEN,
+	TCOD_COLOR_SEA,
+	TCOD_COLOR_TURQUOISE,
+	TCOD_COLOR_CYAN,
+	TCOD_COLOR_SKY,
+	TCOD_COLOR_AZURE,
+	TCOD_COLOR_BLUE,
+	TCOD_COLOR_HAN,
+	TCOD_COLOR_VIOLET,
+	TCOD_COLOR_PURPLE,
+	TCOD_COLOR_FUCHSIA,
+	TCOD_COLOR_MAGENTA,
+	TCOD_COLOR_PINK,
+	TCOD_COLOR_CRIMSON,
+	TCOD_COLOR_NB
+};
+
+/* color levels */
+enum {
+	TCOD_COLOR_DESATURATED,
+	TCOD_COLOR_LIGHTEST,
+	TCOD_COLOR_LIGHTER,
+	TCOD_COLOR_LIGHT,
+	TCOD_COLOR_NORMAL,
+	TCOD_COLOR_DARK,
+	TCOD_COLOR_DARKER,
+	TCOD_COLOR_DARKEST,
+	TCOD_COLOR_LEVELS
+};
+
+/* color array */
+extern TCODLIB_API const TCOD_color_t  TCOD_colors[TCOD_COLOR_NB][TCOD_COLOR_LEVELS];
+
+/* grey levels */
+extern TCODLIB_API const TCOD_color_t TCOD_black;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_light_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_grey;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_light_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_gray;
+extern TCODLIB_API const TCOD_color_t TCOD_white;
+
+/* sepia */
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_sepia;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_sepia;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_sepia;
+extern TCODLIB_API const TCOD_color_t TCOD_sepia;
+extern TCODLIB_API const TCOD_color_t TCOD_light_sepia;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_sepia;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_sepia;
+
+/* standard colors */
+extern TCODLIB_API const TCOD_color_t TCOD_red;
+extern TCODLIB_API const TCOD_color_t TCOD_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_green;
+extern TCODLIB_API const TCOD_color_t TCOD_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_han;
+extern TCODLIB_API const TCOD_color_t TCOD_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_crimson;
+
+/* dark colors */
+extern TCODLIB_API const TCOD_color_t TCOD_dark_red;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_green;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_han;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_dark_crimson;
+
+/* darker colors */
+extern TCODLIB_API const TCOD_color_t TCOD_darker_red;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_green;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_han;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_darker_crimson;
+
+/* darkest colors */
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_red;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_green;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_han;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_darkest_crimson;
+
+/* light colors */
+extern TCODLIB_API const TCOD_color_t TCOD_light_red;
+extern TCODLIB_API const TCOD_color_t TCOD_light_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_light_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_light_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_light_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_light_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_light_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_light_green;
+extern TCODLIB_API const TCOD_color_t TCOD_light_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_light_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_light_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_light_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_light_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_light_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_light_han;
+extern TCODLIB_API const TCOD_color_t TCOD_light_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_light_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_light_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_light_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_light_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_light_crimson;
+
+/* lighter colors */
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_red;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_green;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_han;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_lighter_crimson;
+
+/* lightest colors */
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_red;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_green;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_han;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_lightest_crimson;
+
+/* desaturated */
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_red;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_flame;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_orange;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_amber;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_yellow;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_lime;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_chartreuse;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_green;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_sea;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_turquoise;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_cyan;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_sky;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_azure;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_blue;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_han;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_violet;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_purple;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_fuchsia;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_magenta;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_pink;
+extern TCODLIB_API const TCOD_color_t TCOD_desaturated_crimson;
+
+/* metallic */
+extern TCODLIB_API const TCOD_color_t TCOD_brass;
+extern TCODLIB_API const TCOD_color_t TCOD_copper;
+extern TCODLIB_API const TCOD_color_t TCOD_gold;
+extern TCODLIB_API const TCOD_color_t TCOD_silver;
+
+/* miscellaneous */
+extern TCODLIB_API const TCOD_color_t TCOD_celadon;
+extern TCODLIB_API const TCOD_color_t TCOD_peach;
+
+#endif
--- /dev/null
+++ b/include/libtcod/console.h
@@ -0,0 +1,123 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_CONSOLE_H
+#define _TCOD_CONSOLE_H
+
+#include <libtcod/console_types.h>
+
+#define TCOD_BKGND_ALPHA(alpha) ((TCOD_bkgnd_flag_t)(TCOD_BKGND_ALPH|(((uint8)(alpha*255))<<8)))
+#define TCOD_BKGND_ADDALPHA(alpha) ((TCOD_bkgnd_flag_t)(TCOD_BKGND_ADDA|(((uint8)(alpha*255))<<8)))
+
+typedef void * TCOD_console_t;
+
+TCODLIB_API void TCOD_console_init_root(int w, int h, const char * title, bool fullscreen, TCOD_renderer_t renderer);
+TCODLIB_API void TCOD_console_set_window_title(const char *title);
+TCODLIB_API void TCOD_console_set_fullscreen(bool fullscreen);
+TCODLIB_API bool TCOD_console_is_fullscreen();
+TCODLIB_API bool TCOD_console_is_window_closed();
+
+TCODLIB_API void TCOD_console_set_custom_font(const char *fontFile, int flags,int nb_char_horiz, int nb_char_vertic);
+TCODLIB_API void TCOD_console_map_ascii_code_to_font(int asciiCode, int fontCharX, int fontCharY);
+TCODLIB_API void TCOD_console_map_ascii_codes_to_font(int asciiCode, int nbCodes, int fontCharX, int fontCharY);
+TCODLIB_API void TCOD_console_map_string_to_font(const char *s, int fontCharX, int fontCharY);
+
+TCODLIB_API void TCOD_console_set_dirty(int x, int y, int w, int h);
+TCODLIB_API void TCOD_console_set_default_background(TCOD_console_t con,TCOD_color_t col);
+TCODLIB_API void TCOD_console_set_default_foreground(TCOD_console_t con,TCOD_color_t col);
+TCODLIB_API void TCOD_console_clear(TCOD_console_t con);
+TCODLIB_API void TCOD_console_set_char_background(TCOD_console_t con,int x, int y, TCOD_color_t col, TCOD_bkgnd_flag_t flag);
+TCODLIB_API void TCOD_console_set_char_foreground(TCOD_console_t con,int x, int y, TCOD_color_t col);
+TCODLIB_API void TCOD_console_set_char(TCOD_console_t con,int x, int y, int c);
+TCODLIB_API void TCOD_console_put_char(TCOD_console_t con,int x, int y, int c, TCOD_bkgnd_flag_t flag);
+TCODLIB_API void TCOD_console_put_char_ex(TCOD_console_t con,int x, int y, int c, TCOD_color_t fore, TCOD_color_t back);
+
+TCODLIB_API void TCOD_console_set_background_flag(TCOD_console_t con,TCOD_bkgnd_flag_t flag);
+TCODLIB_API TCOD_bkgnd_flag_t TCOD_console_get_background_flag(TCOD_console_t con);
+TCODLIB_API void TCOD_console_set_alignment(TCOD_console_t con,TCOD_alignment_t alignment);
+TCODLIB_API TCOD_alignment_t TCOD_console_get_alignment(TCOD_console_t con);
+TCODLIB_API void TCOD_console_print(TCOD_console_t con,int x, int y, const char *fmt, ...);
+TCODLIB_API void TCOD_console_print_ex(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
+TCODLIB_API int TCOD_console_print_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...);
+TCODLIB_API int TCOD_console_print_rect_ex(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
+TCODLIB_API int TCOD_console_get_height_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...);
+
+TCODLIB_API void TCOD_console_rect(TCOD_console_t con,int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag);
+TCODLIB_API void TCOD_console_hline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag);
+TCODLIB_API void TCOD_console_vline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag);
+TCODLIB_API void TCOD_console_print_frame(TCOD_console_t con,int x,int y,int w,int h, bool empty, TCOD_bkgnd_flag_t flag, const char *fmt, ...);
+
+#ifndef NO_UNICODE
+/* unicode support */
+TCODLIB_API void TCOD_console_map_string_to_font_utf(const wchar_t *s, int fontCharX, int fontCharY);
+TCODLIB_API void TCOD_console_print_utf(TCOD_console_t con,int x, int y, const wchar_t *fmt, ...);
+TCODLIB_API void TCOD_console_print_ex_utf(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
+TCODLIB_API int TCOD_console_print_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...);
+TCODLIB_API int TCOD_console_print_rect_ex_utf(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
+TCODLIB_API int TCOD_console_get_height_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...);
+#endif
+
+
+TCODLIB_API TCOD_color_t TCOD_console_get_default_background(TCOD_console_t con);
+TCODLIB_API TCOD_color_t TCOD_console_get_default_foreground(TCOD_console_t con);
+TCODLIB_API TCOD_color_t TCOD_console_get_char_background(TCOD_console_t con,int x, int y);
+TCODLIB_API TCOD_color_t TCOD_console_get_char_foreground(TCOD_console_t con,int x, int y);
+TCODLIB_API int TCOD_console_get_char(TCOD_console_t con,int x, int y);
+
+TCODLIB_API void TCOD_console_set_fade(uint8 val, TCOD_color_t fade);
+TCODLIB_API uint8 TCOD_console_get_fade();
+TCODLIB_API TCOD_color_t TCOD_console_get_fading_color();
+
+TCODLIB_API void TCOD_console_flush();
+
+TCODLIB_API void TCOD_console_set_color_control(TCOD_colctrl_t con, TCOD_color_t fore, TCOD_color_t back);
+
+TCODLIB_API TCOD_key_t TCOD_console_check_for_keypress(int flags);
+TCODLIB_API TCOD_key_t TCOD_console_wait_for_keypress(bool flush);
+TCODLIB_API void TCOD_console_set_keyboard_repeat(int initial_delay, int interval);
+TCODLIB_API void TCOD_console_disable_keyboard_repeat();
+TCODLIB_API bool TCOD_console_is_key_pressed(TCOD_keycode_t key);
+
+/* ASCII paint file support */
+TCODLIB_API TCOD_console_t TCOD_console_from_file(const char *filename);
+TCODLIB_API bool TCOD_console_load_asc(TCOD_console_t con, const char *filename);
+TCODLIB_API bool TCOD_console_load_apf(TCOD_console_t con, const char *filename);
+TCODLIB_API bool TCOD_console_save_asc(TCOD_console_t con, const char *filename);
+TCODLIB_API bool TCOD_console_save_apf(TCOD_console_t con, const char *filename);
+
+TCODLIB_API TCOD_console_t TCOD_console_new(int w, int h);
+TCODLIB_API int TCOD_console_get_width(TCOD_console_t con);
+TCODLIB_API int TCOD_console_get_height(TCOD_console_t con);
+TCODLIB_API void TCOD_console_set_key_color(TCOD_console_t con,TCOD_color_t col);
+TCODLIB_API void TCOD_console_blit(TCOD_console_t src,int xSrc, int ySrc, int wSrc, int hSrc, TCOD_console_t dst, int xDst, int yDst, float foreground_alpha, float background_alpha);
+TCODLIB_API void TCOD_console_delete(TCOD_console_t console);
+
+TCODLIB_API void TCOD_console_credits();
+TCODLIB_API void TCOD_console_credits_reset();
+TCODLIB_API bool TCOD_console_credits_render(int x, int y, bool alpha);
+
+#endif
--- /dev/null
+++ b/include/libtcod/fov.h
@@ -0,0 +1,58 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_FOV_H
+#define _TCOD_FOV_H
+
+typedef void *TCOD_map_t;
+
+#include <libtcod/fov_types.h>
+
+/* allocate a new map */
+TCODLIB_API TCOD_map_t TCOD_map_new(int width, int height);
+/* set all cells as solid rock (cannot see through nor walk) */
+TCODLIB_API void TCOD_map_clear(TCOD_map_t map, bool transparent, bool walkable);
+/* copy a map to another, reallocating it when needed */
+TCODLIB_API void TCOD_map_copy(TCOD_map_t source, TCOD_map_t dest);
+/* change a cell properties */
+TCODLIB_API void TCOD_map_set_properties(TCOD_map_t map, int x, int y, bool is_transparent, bool is_walkable);
+/* destroy a map */
+TCODLIB_API void TCOD_map_delete(TCOD_map_t map);
+
+/* calculate the field of view (potentially visible cells from player_x,player_y) */
+TCODLIB_API void TCOD_map_compute_fov(TCOD_map_t map, int player_x, int player_y, int max_radius, bool light_walls, TCOD_fov_algorithm_t algo);
+/* check if a cell is in the last computed field of view */
+TCODLIB_API bool TCOD_map_is_in_fov(TCOD_map_t map, int x, int y);
+TCODLIB_API void TCOD_map_set_in_fov(TCOD_map_t map, int x, int y, bool fov);
+
+/* retrieve properties from the map */
+TCODLIB_API bool TCOD_map_is_transparent(TCOD_map_t map, int x, int y);
+TCODLIB_API bool TCOD_map_is_walkable(TCOD_map_t map, int x, int y);
+TCODLIB_API int TCOD_map_get_width(TCOD_map_t map);
+TCODLIB_API int TCOD_map_get_height(TCOD_map_t map);
+TCODLIB_API int TCOD_map_get_nb_cells(TCOD_map_t map);
+#endif
--- /dev/null
+++ b/include/libtcod/heightmap.h
@@ -0,0 +1,70 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _TCOD_HEIGHTMAP_H
+#define _TCOD_HEIGHTMAP_H
+
+typedef struct {
+	int w,h;
+	float *values;
+} TCOD_heightmap_t;
+
+TCODLIB_API TCOD_heightmap_t *TCOD_heightmap_new(int w,int h);
+TCODLIB_API void TCOD_heightmap_delete(TCOD_heightmap_t *hm);
+
+TCODLIB_API float TCOD_heightmap_get_value(const TCOD_heightmap_t *hm, int x, int y);
+TCODLIB_API float TCOD_heightmap_get_interpolated_value(const TCOD_heightmap_t *hm, float x, float y);
+TCODLIB_API void TCOD_heightmap_set_value(TCOD_heightmap_t *hm, int x, int y, float value);
+TCODLIB_API float TCOD_heightmap_get_slope(const TCOD_heightmap_t *hm, int x, int y);
+TCODLIB_API void TCOD_heightmap_get_normal(const TCOD_heightmap_t *hm, float x, float y, float n[3], float waterLevel);
+TCODLIB_API int TCOD_heightmap_count_cells(const TCOD_heightmap_t *hm, float min, float max);
+TCODLIB_API bool TCOD_heightmap_has_land_on_border(const TCOD_heightmap_t *hm, float waterLevel);
+TCODLIB_API void TCOD_heightmap_get_minmax(const TCOD_heightmap_t *hm, float *min, float *max);
+
+TCODLIB_API void TCOD_heightmap_copy(const TCOD_heightmap_t *hm_source,TCOD_heightmap_t *hm_dest);
+TCODLIB_API void TCOD_heightmap_add(TCOD_heightmap_t *hm, float value);
+TCODLIB_API void TCOD_heightmap_scale(TCOD_heightmap_t *hm, float value);
+TCODLIB_API void TCOD_heightmap_clamp(TCOD_heightmap_t *hm, float min, float max);
+TCODLIB_API void TCOD_heightmap_normalize(TCOD_heightmap_t *hm, float min, float max);
+TCODLIB_API void TCOD_heightmap_clear(TCOD_heightmap_t *hm);
+TCODLIB_API void TCOD_heightmap_lerp_hm(const TCOD_heightmap_t *hm1, const TCOD_heightmap_t *hm2, TCOD_heightmap_t *hmres, float coef);
+TCODLIB_API void TCOD_heightmap_add_hm(const TCOD_heightmap_t *hm1, const TCOD_heightmap_t *hm2, TCOD_heightmap_t *hmres);
+TCODLIB_API void TCOD_heightmap_multiply_hm(const TCOD_heightmap_t *hm1, const TCOD_heightmap_t *hm2, TCOD_heightmap_t *hmres);
+
+TCODLIB_API void TCOD_heightmap_add_hill(TCOD_heightmap_t *hm, float hx, float hy, float hradius, float hheight);
+TCODLIB_API void TCOD_heightmap_dig_hill(TCOD_heightmap_t *hm, float hx, float hy, float hradius, float hheight);
+TCODLIB_API void TCOD_heightmap_dig_bezier(TCOD_heightmap_t *hm, int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth);
+TCODLIB_API void TCOD_heightmap_rain_erosion(TCOD_heightmap_t *hm, int nbDrops,float erosionCoef,float sedimentationCoef,TCOD_random_t rnd);
+/* TCODLIB_API void TCOD_heightmap_heat_erosion(TCOD_heightmap_t *hm, int nbPass,float minSlope,float erosionCoef,float sedimentationCoef,TCOD_random_t rnd); */
+TCODLIB_API void TCOD_heightmap_kernel_transform(TCOD_heightmap_t *hm, int kernelsize, const int *dx, const int *dy, const float *weight, float minLevel,float maxLevel);
+TCODLIB_API void TCOD_heightmap_add_voronoi(TCOD_heightmap_t *hm, int nbPoints, int nbCoef, const float *coef,TCOD_random_t rnd);
+/* TCODLIB_API void TCOD_heightmap_mid_point_deplacement(TCOD_heightmap_t *hm, TCOD_random_t rnd); */
+TCODLIB_API void TCOD_heightmap_add_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale); 
+TCODLIB_API void TCOD_heightmap_scale_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale); 
+TCODLIB_API void TCOD_heightmap_islandify(TCOD_heightmap_t *hm, float seaLevel,TCOD_random_t rnd);
+
+#endif
+
--- /dev/null
+++ b/include/libtcod/image.h
@@ -0,0 +1,54 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+typedef void *TCOD_image_t;
+
+TCODLIB_API TCOD_image_t TCOD_image_new(int width, int height);
+TCODLIB_API TCOD_image_t TCOD_image_from_console(TCOD_console_t console);
+TCODLIB_API void TCOD_image_refresh_console(TCOD_image_t image, TCOD_console_t console);
+TCODLIB_API TCOD_image_t TCOD_image_load(const char *filename);
+TCODLIB_API void TCOD_image_clear(TCOD_image_t image, TCOD_color_t color);
+TCODLIB_API void TCOD_image_invert(TCOD_image_t image);
+TCODLIB_API void TCOD_image_hflip(TCOD_image_t image);
+TCODLIB_API void TCOD_image_rotate90(TCOD_image_t image, int numRotations);
+TCODLIB_API void TCOD_image_vflip(TCOD_image_t image);
+TCODLIB_API void TCOD_image_scale(TCOD_image_t image, int neww, int newh);
+TCODLIB_API void TCOD_image_save(TCOD_image_t image, const char *filename);
+TCODLIB_API void TCOD_image_get_size(TCOD_image_t image, int *w,int *h);
+TCODLIB_API TCOD_color_t TCOD_image_get_pixel(TCOD_image_t image,int x, int y);
+TCODLIB_API int TCOD_image_get_alpha(TCOD_image_t image,int x, int y);
+TCODLIB_API TCOD_color_t TCOD_image_get_mipmap_pixel(TCOD_image_t image,float x0,float y0, float x1, float y1);
+TCODLIB_API void TCOD_image_put_pixel(TCOD_image_t image,int x, int y,TCOD_color_t col);
+TCODLIB_API void TCOD_image_blit(TCOD_image_t image, TCOD_console_t console, float x, float y, 
+	TCOD_bkgnd_flag_t bkgnd_flag, float scalex, float scaley, float angle);
+TCODLIB_API void TCOD_image_blit_rect(TCOD_image_t image, TCOD_console_t console, int x, int y, int w, int h, 
+	TCOD_bkgnd_flag_t bkgnd_flag);
+TCODLIB_API void TCOD_image_blit_2x(TCOD_image_t image, TCOD_console_t dest, int dx, int dy, int sx, int sy, int w, int h);
+TCODLIB_API void TCOD_image_delete(TCOD_image_t image);
+TCODLIB_API void TCOD_image_set_key_color(TCOD_image_t image, TCOD_color_t key_color);
+TCODLIB_API bool TCOD_image_is_pixel_transparent(TCOD_image_t image, int x, int y);
+
--- /dev/null
+++ b/include/libtcod/lex.h
@@ -0,0 +1,101 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_LEX_H
+#define _TCOD_LEX_H
+/*
+ * This is a libtcod internal module.
+ * Use at your own risks...
+ */
+
+#define TCOD_LEX_FLAG_NOCASE 1
+#define TCOD_LEX_FLAG_NESTING_COMMENT 2
+#define TCOD_LEX_FLAG_TOKENIZE_COMMENTS 4
+
+#define TCOD_LEX_ERROR -1
+#define TCOD_LEX_UNKNOWN 0
+#define TCOD_LEX_SYMBOL 1
+#define TCOD_LEX_KEYWORD 2
+#define TCOD_LEX_IDEN 3
+#define TCOD_LEX_STRING 4
+#define TCOD_LEX_INTEGER 5
+#define TCOD_LEX_FLOAT 6
+#define TCOD_LEX_CHAR 7
+#define TCOD_LEX_EOF 8
+#define TCOD_LEX_COMMENT 9
+
+#define TCOD_LEX_MAX_SYMBOLS 100
+#define TCOD_LEX_SYMBOL_SIZE 5
+#define TCOD_LEX_MAX_KEYWORDS 100
+#define TCOD_LEX_KEYWORD_SIZE 20
+
+typedef struct {
+	int file_line, token_type, token_int_val, token_idx;
+	float token_float_val;
+	char *tok;
+    int toklen;
+	char lastStringDelim;
+	char *pos;
+	char *buf;
+	char *filename;
+	char *last_javadoc_comment;
+	/* private stuff */
+	int nb_symbols, nb_keywords, flags;
+	char symbols[ TCOD_LEX_MAX_SYMBOLS][ TCOD_LEX_SYMBOL_SIZE ], 
+	keywords[ TCOD_LEX_MAX_KEYWORDS ][ TCOD_LEX_KEYWORD_SIZE ];
+	const char *simpleCmt;
+	const char *cmtStart, *cmtStop, *javadocCmtStart;
+	const char *stringDelim;
+	bool javadoc_read;
+	bool allocBuf;
+	bool savept; /* is this object a savepoint (no free in destructor) */	
+} TCOD_lex_t;
+
+TCODLIB_API TCOD_lex_t *TCOD_lex_new_intern();
+TCODLIB_API TCOD_lex_t *TCOD_lex_new(const char **symbols, const char **keywords, const char *simpleComment, 
+		const char *commentStart, const char *commentStop, const char *javadocCommentStart, const char *stringDelim, int flags);
+TCODLIB_API void TCOD_lex_delete(TCOD_lex_t *lex);
+
+TCODLIB_API void TCOD_lex_set_data_buffer(TCOD_lex_t *lex,char *dat);
+TCODLIB_API bool TCOD_lex_set_data_file(TCOD_lex_t *lex,const char *filename);
+
+TCODLIB_API int TCOD_lex_parse(TCOD_lex_t *lex);
+TCODLIB_API int TCOD_lex_parse_until_token_type(TCOD_lex_t *lex,int token_type);
+TCODLIB_API int TCOD_lex_parse_until_token_value(TCOD_lex_t *lex,const char *token_value);
+
+TCODLIB_API bool TCOD_lex_expect_token_type(TCOD_lex_t *lex,int token_type);
+TCODLIB_API bool TCOD_lex_expect_token_value(TCOD_lex_t *lex,int token_type,const char *token_value);
+
+TCODLIB_API void TCOD_lex_savepoint(TCOD_lex_t *lex,TCOD_lex_t *savept);
+TCODLIB_API void TCOD_lex_restore(TCOD_lex_t *lex,TCOD_lex_t *savept);
+TCODLIB_API char *TCOD_lex_get_last_javadoc(TCOD_lex_t *lex);
+TCODLIB_API const char *TCOD_lex_get_token_name(int token_type);
+TCODLIB_API char *TCOD_lex_get_last_error();
+
+TCODLIB_API int TCOD_lex_hextoint(char c);
+
+#endif
--- /dev/null
+++ b/include/libtcod/list.h
@@ -0,0 +1,57 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_LIST_H
+#define _TCOD_LIST_H
+
+typedef void *TCOD_list_t;
+
+TCODLIB_API TCOD_list_t TCOD_list_new();
+TCODLIB_API TCOD_list_t TCOD_list_allocate(int nb_elements);
+TCODLIB_API TCOD_list_t TCOD_list_duplicate(TCOD_list_t l);
+TCODLIB_API void TCOD_list_delete(TCOD_list_t l);
+TCODLIB_API void TCOD_list_push(TCOD_list_t l, const void * elt);
+TCODLIB_API void * TCOD_list_pop(TCOD_list_t l);
+TCODLIB_API void * TCOD_list_peek(TCOD_list_t l);
+TCODLIB_API void TCOD_list_add_all(TCOD_list_t l, TCOD_list_t l2);
+TCODLIB_API void * TCOD_list_get(TCOD_list_t l,int idx);
+TCODLIB_API void TCOD_list_set(TCOD_list_t l,const void *elt, int idx);
+TCODLIB_API void ** TCOD_list_begin(TCOD_list_t l);
+TCODLIB_API void ** TCOD_list_end(TCOD_list_t l);
+TCODLIB_API void TCOD_list_reverse(TCOD_list_t l);
+TCODLIB_API void **TCOD_list_remove_iterator(TCOD_list_t l, void **elt);
+TCODLIB_API void TCOD_list_remove(TCOD_list_t l, const void * elt);
+TCODLIB_API void **TCOD_list_remove_iterator_fast(TCOD_list_t l, void **elt);
+TCODLIB_API void TCOD_list_remove_fast(TCOD_list_t l, const void * elt);
+TCODLIB_API bool TCOD_list_contains(TCOD_list_t l,const void * elt);
+TCODLIB_API void TCOD_list_clear(TCOD_list_t l);
+TCODLIB_API void TCOD_list_clear_and_delete(TCOD_list_t l);
+TCODLIB_API int TCOD_list_size(TCOD_list_t l);
+TCODLIB_API void ** TCOD_list_insert_before(TCOD_list_t l,const void *elt,int before);
+TCODLIB_API bool TCOD_list_is_empty(TCOD_list_t l);
+
+#endif
--- /dev/null
+++ b/include/libtcod/mersenne.h
@@ -0,0 +1,56 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_RANDOM_H
+#define _TCOD_RANDOM_H
+
+#include "mersenne_types.h"
+
+typedef void *TCOD_random_t;
+
+TCODLIB_API TCOD_random_t TCOD_random_get_instance(void);
+TCODLIB_API TCOD_random_t TCOD_random_new(TCOD_random_algo_t algo);
+TCODLIB_API TCOD_random_t TCOD_random_save(TCOD_random_t mersenne);
+TCODLIB_API void TCOD_random_restore(TCOD_random_t mersenne, TCOD_random_t backup);
+TCODLIB_API TCOD_random_t TCOD_random_new_from_seed(TCOD_random_algo_t algo, uint32 seed);
+TCODLIB_API void TCOD_random_delete(TCOD_random_t mersenne);
+
+TCODLIB_API void TCOD_random_set_distribution (TCOD_random_t mersenne, TCOD_distribution_t distribution);
+
+TCODLIB_API int TCOD_random_get_int (TCOD_random_t mersenne, int min, int max);
+TCODLIB_API float TCOD_random_get_float (TCOD_random_t mersenne, float min, float max);
+TCODLIB_API double TCOD_random_get_double (TCOD_random_t mersenne, double min, double max);
+
+TCODLIB_API int TCOD_random_get_int_mean (TCOD_random_t mersenne, int min, int max, int mean);
+TCODLIB_API float TCOD_random_get_float_mean (TCOD_random_t mersenne, float min, float max, float mean);
+TCODLIB_API double TCOD_random_get_double_mean (TCOD_random_t mersenne, double min, double max, double mean);
+
+TCODLIB_API TCOD_dice_t TCOD_random_dice_new (const char * s);
+TCODLIB_API int TCOD_random_dice_roll (TCOD_random_t mersenne, TCOD_dice_t dice);
+TCODLIB_API int TCOD_random_dice_roll_s (TCOD_random_t mersenne, const char * s);
+
+#endif
--- /dev/null
+++ b/include/libtcod/mouse.h
@@ -0,0 +1,39 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_MOUSE_H
+#define _TCOD_MOUSE_H
+
+#include "mouse_types.h"
+
+TCODLIB_API void TCOD_mouse_show_cursor(bool visible);
+TCODLIB_API TCOD_mouse_t TCOD_mouse_get_status();
+TCODLIB_API bool TCOD_mouse_is_cursor_visible();
+TCODLIB_API void TCOD_mouse_move(int x, int y);
+TCODLIB_API void TCOD_mouse_includes_touch(bool enable);
+
+#endif
--- /dev/null
+++ b/include/libtcod/namegen.h
@@ -0,0 +1,49 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*
+* Mingos' NameGen
+* This file was written by Dominik "Mingos" Marczuk.
+*/
+
+#ifndef _TCOD_NAMEGEN_H
+#define _TCOD_NAMEGEN_H
+
+/* the generator typedef */
+typedef void * TCOD_namegen_t;
+
+/* parse a file with syllable sets */
+TCODLIB_API void TCOD_namegen_parse (const char * filename, TCOD_random_t random);
+/* generate a name */
+TCODLIB_API char * TCOD_namegen_generate (char * name, bool allocate);
+/* generate a name using a custom generation rule */
+TCODLIB_API char * TCOD_namegen_generate_custom (char * name, char * rule, bool allocate);
+/* retrieve the list of all available syllable set names */
+TCODLIB_API TCOD_list_t TCOD_namegen_get_sets (void);
+/* delete a generator */
+TCODLIB_API void TCOD_namegen_destroy (void);
+
+#endif
--- /dev/null
+++ b/include/libtcod/noise.h
@@ -0,0 +1,56 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_PERLIN_H
+#define _TCOD_PERLIN_H
+
+typedef void *TCOD_noise_t;
+
+typedef enum {
+	TCOD_NOISE_PERLIN = 1,
+	TCOD_NOISE_SIMPLEX = 2,
+	TCOD_NOISE_WAVELET = 4,
+	TCOD_NOISE_DEFAULT = 0
+} TCOD_noise_type_t;
+
+#include "noise_defaults.h"
+
+/* create a new noise object */
+TCODLIB_API TCOD_noise_t TCOD_noise_new(int dimensions, float hurst, float lacunarity, TCOD_random_t random);
+
+/* simplified API */
+TCODLIB_API void TCOD_noise_set_type (TCOD_noise_t noise, TCOD_noise_type_t type);
+TCODLIB_API float TCOD_noise_get_ex (TCOD_noise_t noise, float *f, TCOD_noise_type_t type);
+TCODLIB_API float TCOD_noise_get_fbm_ex (TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t type);
+TCODLIB_API float TCOD_noise_get_turbulence_ex (TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t type);
+TCODLIB_API float TCOD_noise_get (TCOD_noise_t noise, float *f);
+TCODLIB_API float TCOD_noise_get_fbm (TCOD_noise_t noise, float *f, float octaves);
+TCODLIB_API float TCOD_noise_get_turbulence (TCOD_noise_t noise, float *f, float octaves);
+/* delete the noise object */
+TCODLIB_API void TCOD_noise_delete(TCOD_noise_t noise);
+
+#endif
--- /dev/null
+++ b/include/libtcod/parser.h
@@ -0,0 +1,170 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_PARSER_H
+#define _TCOD_PARSER_H
+
+/* generic type */
+typedef enum {
+	TCOD_TYPE_NONE,
+	TCOD_TYPE_BOOL,
+	TCOD_TYPE_CHAR,
+	TCOD_TYPE_INT,
+	TCOD_TYPE_FLOAT,
+	TCOD_TYPE_STRING,
+	TCOD_TYPE_COLOR,
+	TCOD_TYPE_DICE,
+	TCOD_TYPE_VALUELIST00,
+	TCOD_TYPE_VALUELIST01,
+	TCOD_TYPE_VALUELIST02,
+	TCOD_TYPE_VALUELIST03,
+	TCOD_TYPE_VALUELIST04,
+	TCOD_TYPE_VALUELIST05,
+	TCOD_TYPE_VALUELIST06,
+	TCOD_TYPE_VALUELIST07,
+	TCOD_TYPE_VALUELIST08,
+	TCOD_TYPE_VALUELIST09,
+	TCOD_TYPE_VALUELIST10,
+	TCOD_TYPE_VALUELIST11,
+	TCOD_TYPE_VALUELIST12,
+	TCOD_TYPE_VALUELIST13,
+	TCOD_TYPE_VALUELIST14,
+	TCOD_TYPE_VALUELIST15,
+	TCOD_TYPE_CUSTOM00,
+	TCOD_TYPE_CUSTOM01,
+	TCOD_TYPE_CUSTOM02,
+	TCOD_TYPE_CUSTOM03,
+	TCOD_TYPE_CUSTOM04,
+	TCOD_TYPE_CUSTOM05,
+	TCOD_TYPE_CUSTOM06,
+	TCOD_TYPE_CUSTOM07,
+	TCOD_TYPE_CUSTOM08,
+	TCOD_TYPE_CUSTOM09,
+	TCOD_TYPE_CUSTOM10,
+	TCOD_TYPE_CUSTOM11,
+	TCOD_TYPE_CUSTOM12,
+	TCOD_TYPE_CUSTOM13,
+	TCOD_TYPE_CUSTOM14,
+	TCOD_TYPE_CUSTOM15,
+	TCOD_TYPE_LIST=1024
+} TCOD_value_type_t;
+
+/* generic value */
+typedef union {
+	bool b;
+	char c;
+	int32 i;
+	float f;
+	char *s;
+	TCOD_color_t col;
+	TCOD_dice_t dice;
+	TCOD_list_t list;
+	void *custom;
+} TCOD_value_t;
+
+/* parser structures */
+typedef void *TCOD_parser_struct_t;
+TCODLIB_API const char *TCOD_struct_get_name(TCOD_parser_struct_t def);
+TCODLIB_API void TCOD_struct_add_property(TCOD_parser_struct_t def, const char *name,TCOD_value_type_t type, bool mandatory);
+TCODLIB_API void TCOD_struct_add_list_property(TCOD_parser_struct_t def, const char *name,TCOD_value_type_t type, bool mandatory);
+TCODLIB_API void TCOD_struct_add_value_list(TCOD_parser_struct_t def,const char *name, const char **value_list, bool mandatory);
+TCODLIB_API void TCOD_struct_add_value_list_sized(TCOD_parser_struct_t def,const char *name, const char **value_list, int size, bool mandatory);
+TCODLIB_API void TCOD_struct_add_flag(TCOD_parser_struct_t def,const char *propname);
+TCODLIB_API void TCOD_struct_add_structure(TCOD_parser_struct_t def,TCOD_parser_struct_t sub_structure);
+TCODLIB_API bool TCOD_struct_is_mandatory(TCOD_parser_struct_t def,const char *propname);
+TCODLIB_API TCOD_value_type_t TCOD_struct_get_type(TCOD_parser_struct_t def, const char *propname);
+
+
+/* parser listener */
+typedef struct {
+	bool (*new_struct)(TCOD_parser_struct_t str,const char *name);
+	bool (*new_flag)(const char *name);
+	bool (*new_property)(const char *propname, TCOD_value_type_t type, TCOD_value_t value);
+	bool (*end_struct)(TCOD_parser_struct_t str, const char *name);
+	void (*error)(const char *msg);
+} TCOD_parser_listener_t;
+
+/* a custom type parser */
+typedef TCOD_value_t (*TCOD_parser_custom_t)(TCOD_lex_t *lex, TCOD_parser_listener_t *listener, TCOD_parser_struct_t str, char *propname);
+
+/* the parser */
+typedef void *TCOD_parser_t;
+
+TCODLIB_API TCOD_parser_t TCOD_parser_new();
+TCODLIB_API TCOD_parser_struct_t TCOD_parser_new_struct(TCOD_parser_t parser, char *name);
+TCODLIB_API TCOD_value_type_t TCOD_parser_new_custom_type(TCOD_parser_t parser,TCOD_parser_custom_t custom_type_parser);
+TCODLIB_API void TCOD_parser_run(TCOD_parser_t parser, const char *filename, TCOD_parser_listener_t *listener);
+TCODLIB_API void TCOD_parser_delete(TCOD_parser_t parser);
+/* error during parsing. can be called by the parser listener */
+TCODLIB_API void TCOD_parser_error(const char *msg, ...);
+/* default parser listener */
+TCODLIB_API bool TCOD_parser_get_bool_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API int TCOD_parser_get_char_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API int TCOD_parser_get_int_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API float TCOD_parser_get_float_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API const char * TCOD_parser_get_string_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API TCOD_color_t TCOD_parser_get_color_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API TCOD_dice_t TCOD_parser_get_dice_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API void TCOD_parser_get_dice_property_py(TCOD_parser_t parser, const char *name, TCOD_dice_t *dice);
+TCODLIB_API void * TCOD_parser_get_custom_property(TCOD_parser_t parser, const char *name);
+TCODLIB_API TCOD_list_t TCOD_parser_get_list_property(TCOD_parser_t parser, const char *name, TCOD_value_type_t type);
+
+/* parser internals (may be used by custom type parsers) */
+/* parser structures */
+typedef struct {
+	char *name; /* entity type name */
+	/* list of flags */
+	TCOD_list_t flags;
+	/* list of properties (name, type, mandatory) */
+	TCOD_list_t props;
+	/* list of value lists */
+	TCOD_list_t lists;
+	/* list of sub-structures */
+	TCOD_list_t structs;
+} TCOD_struct_int_t;
+/* the parser */
+typedef struct {
+	/* list of structures */
+	TCOD_list_t structs;
+	/* list of custom type parsers */
+	TCOD_parser_custom_t customs[16];
+	/* fatal error occured */
+	bool fatal;
+	/* list of properties if default listener is used */
+	TCOD_list_t props;
+} TCOD_parser_int_t;
+TCODLIB_API TCOD_value_t TCOD_parse_bool_value();
+TCODLIB_API TCOD_value_t TCOD_parse_char_value();
+TCODLIB_API TCOD_value_t TCOD_parse_integer_value();
+TCODLIB_API TCOD_value_t TCOD_parse_float_value();
+TCODLIB_API TCOD_value_t TCOD_parse_string_value();
+TCODLIB_API TCOD_value_t TCOD_parse_color_value();
+TCODLIB_API TCOD_value_t TCOD_parse_dice_value();
+TCODLIB_API TCOD_value_t TCOD_parse_value_list_value(TCOD_struct_int_t *def,int listnum);
+TCODLIB_API TCOD_value_t TCOD_parse_property_value(TCOD_parser_int_t *parser, TCOD_parser_struct_t def, char *propname, bool list);
+
+#endif
--- /dev/null
+++ b/include/libtcod/path.h
@@ -0,0 +1,63 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_PATH_H
+#define _TCOD_PATH_H
+
+typedef float (*TCOD_path_func_t)( int xFrom, int yFrom, int xTo, int yTo, void *user_data );
+typedef void *TCOD_path_t;
+
+TCODLIB_API TCOD_path_t TCOD_path_new_using_map(TCOD_map_t map, float diagonalCost);
+TCODLIB_API TCOD_path_t TCOD_path_new_using_function(int map_width, int map_height, TCOD_path_func_t func, void *user_data, float diagonalCost);
+
+TCODLIB_API bool TCOD_path_compute(TCOD_path_t path, int ox,int oy, int dx, int dy);
+TCODLIB_API bool TCOD_path_walk(TCOD_path_t path, int *x, int *y, bool recalculate_when_needed);
+TCODLIB_API bool TCOD_path_is_empty(TCOD_path_t path);
+TCODLIB_API int TCOD_path_size(TCOD_path_t path);
+TCODLIB_API void TCOD_path_reverse(TCOD_path_t path);
+TCODLIB_API void TCOD_path_get(TCOD_path_t path, int index, int *x, int *y);
+TCODLIB_API void TCOD_path_get_origin(TCOD_path_t path, int *x, int *y);
+TCODLIB_API void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y);
+TCODLIB_API void TCOD_path_delete(TCOD_path_t path);
+
+/* Dijkstra stuff - by Mingos*/
+
+typedef void *TCOD_dijkstra_t;
+
+TCODLIB_API TCOD_dijkstra_t TCOD_dijkstra_new (TCOD_map_t map, float diagonalCost);
+TCODLIB_API TCOD_dijkstra_t TCOD_dijkstra_new_using_function(int map_width, int map_height, TCOD_path_func_t func, void *user_data, float diagonalCost);
+TCODLIB_API void TCOD_dijkstra_compute (TCOD_dijkstra_t dijkstra, int root_x, int root_y);
+TCODLIB_API float TCOD_dijkstra_get_distance (TCOD_dijkstra_t dijkstra, int x, int y);
+TCODLIB_API bool TCOD_dijkstra_path_set (TCOD_dijkstra_t dijkstra, int x, int y);
+TCODLIB_API bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t path);
+TCODLIB_API int TCOD_dijkstra_size(TCOD_dijkstra_t path);
+TCODLIB_API void TCOD_dijkstra_reverse(TCOD_dijkstra_t path);
+TCODLIB_API void TCOD_dijkstra_get(TCOD_dijkstra_t path, int index, int *x, int *y);
+TCODLIB_API bool TCOD_dijkstra_path_walk (TCOD_dijkstra_t dijkstra, int *x, int *y);
+TCODLIB_API void TCOD_dijkstra_delete (TCOD_dijkstra_t dijkstra);
+
+#endif
--- /dev/null
+++ b/include/libtcod/sys.h
@@ -0,0 +1,108 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_SYS_H
+#define _TCOD_SYS_H
+
+TCODLIB_API uint32 TCOD_sys_elapsed_milli();
+TCODLIB_API float TCOD_sys_elapsed_seconds();
+TCODLIB_API void TCOD_sys_sleep_milli(uint32 val);
+TCODLIB_API void TCOD_sys_save_screenshot(const char *filename);
+TCODLIB_API void TCOD_sys_force_fullscreen_resolution(int width, int height);
+TCODLIB_API void TCOD_sys_set_renderer(TCOD_renderer_t renderer);
+TCODLIB_API TCOD_renderer_t TCOD_sys_get_renderer();
+TCODLIB_API void TCOD_sys_set_fps(int val);
+TCODLIB_API int TCOD_sys_get_fps();
+TCODLIB_API float TCOD_sys_get_last_frame_length();
+TCODLIB_API void TCOD_sys_get_current_resolution(int *w, int *h);
+TCODLIB_API void TCOD_sys_get_fullscreen_offsets(int *offx, int *offy);
+TCODLIB_API void TCOD_sys_update_char(int asciiCode, int fontx, int fonty, TCOD_image_t img, int x, int y);
+TCODLIB_API void TCOD_sys_get_char_size(int *w, int *h);
+TCODLIB_API void *TCOD_sys_get_sdl_window();
+
+typedef enum {
+  TCOD_EVENT_KEY_PRESS=1,
+  TCOD_EVENT_KEY_RELEASE=2,
+  TCOD_EVENT_KEY=TCOD_EVENT_KEY_PRESS|TCOD_EVENT_KEY_RELEASE,
+  TCOD_EVENT_MOUSE_MOVE=4,
+  TCOD_EVENT_MOUSE_PRESS=8,
+  TCOD_EVENT_MOUSE_RELEASE=16,
+  TCOD_EVENT_MOUSE=TCOD_EVENT_MOUSE_MOVE|TCOD_EVENT_MOUSE_PRESS|TCOD_EVENT_MOUSE_RELEASE,
+  TCOD_EVENT_ANY=TCOD_EVENT_KEY|TCOD_EVENT_MOUSE,
+} TCOD_event_t;
+TCODLIB_API TCOD_event_t TCOD_sys_wait_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush);
+TCODLIB_API TCOD_event_t TCOD_sys_check_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse);
+
+/* filesystem stuff */
+TCODLIB_API bool TCOD_sys_create_directory(const char *path);
+TCODLIB_API bool TCOD_sys_delete_file(const char *path);
+TCODLIB_API bool TCOD_sys_delete_directory(const char *path);
+TCODLIB_API bool TCOD_sys_is_directory(const char *path);
+TCODLIB_API TCOD_list_t TCOD_sys_get_directory_content(const char *path, const char *pattern);
+TCODLIB_API bool TCOD_sys_file_exists(const char * filename, ...);
+TCODLIB_API bool TCOD_sys_read_file(const char *filename, unsigned char **buf, uint32 *size);
+TCODLIB_API bool TCOD_sys_write_file(const char *filename, unsigned char *buf, uint32 size);
+
+/* clipboard */
+TCODLIB_API void TCOD_sys_clipboard_set(const char *value);
+TCODLIB_API char *TCOD_sys_clipboard_get();
+
+/* thread stuff */
+typedef void *TCOD_thread_t;
+typedef void *TCOD_semaphore_t;
+typedef void *TCOD_mutex_t;
+typedef void *TCOD_cond_t;
+/* threads */
+TCODLIB_API TCOD_thread_t TCOD_thread_new(int (*func)(void *), void *data);
+TCODLIB_API void TCOD_thread_delete(TCOD_thread_t th);
+TCODLIB_API int TCOD_sys_get_num_cores();
+TCODLIB_API void TCOD_thread_wait(TCOD_thread_t th);
+/* mutex */
+TCODLIB_API TCOD_mutex_t TCOD_mutex_new();
+TCODLIB_API void TCOD_mutex_in(TCOD_mutex_t mut);
+TCODLIB_API void TCOD_mutex_out(TCOD_mutex_t mut);
+TCODLIB_API void TCOD_mutex_delete(TCOD_mutex_t mut);
+/* semaphore */
+TCODLIB_API TCOD_semaphore_t TCOD_semaphore_new(int initVal);
+TCODLIB_API void TCOD_semaphore_lock(TCOD_semaphore_t sem);
+TCODLIB_API void TCOD_semaphore_unlock(TCOD_semaphore_t sem);
+TCODLIB_API void TCOD_semaphore_delete( TCOD_semaphore_t sem);
+/* condition */
+TCODLIB_API TCOD_cond_t TCOD_condition_new();
+TCODLIB_API void TCOD_condition_signal(TCOD_cond_t sem);
+TCODLIB_API void TCOD_condition_broadcast(TCOD_cond_t sem);
+TCODLIB_API void TCOD_condition_wait(TCOD_cond_t sem, TCOD_mutex_t mut);
+TCODLIB_API void TCOD_condition_delete( TCOD_cond_t sem);
+/* dynamic library */
+typedef void *TCOD_library_t;
+TCODLIB_API TCOD_library_t TCOD_load_library(const char *path);
+TCODLIB_API void * TCOD_get_function_address(TCOD_library_t library, const char *function_name);
+TCODLIB_API void TCOD_close_library(TCOD_library_t);
+/* SDL renderer callback */
+typedef void (*SDL_renderer_t) (void *sdl_surface);
+TCODLIB_API void TCOD_sys_register_SDL_renderer(SDL_renderer_t renderer);
+#endif
--- /dev/null
+++ b/include/libtcod/tree.h
@@ -0,0 +1,40 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_TREE_H
+#define _TCOD_TREE_H
+
+typedef struct _TCOD_tree_t {
+	struct _TCOD_tree_t *next;
+	struct _TCOD_tree_t *father;
+	struct _TCOD_tree_t *sons;
+} TCOD_tree_t;
+
+TCODLIB_API TCOD_tree_t *TCOD_tree_new();
+TCODLIB_API void TCOD_tree_add_son(TCOD_tree_t *node, TCOD_tree_t *son);
+
+#endif
--- /dev/null
+++ b/include/libtcod/txtfield.h
@@ -0,0 +1,43 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef _TCOD_TEXT_H_
+#define _TCOD_TEXT_H_
+
+typedef void * TCOD_text_t;
+
+TCODLIB_API TCOD_text_t TCOD_text_init(int x, int y, int w, int h, int max_chars);
+TCODLIB_API void TCOD_text_set_properties(TCOD_text_t txt, int cursor_char, int blink_interval, const char * prompt, int tab_size);
+TCODLIB_API void TCOD_text_set_colors(TCOD_text_t txt, TCOD_color_t fore, TCOD_color_t back, float back_transparency);
+TCODLIB_API bool TCOD_text_update(TCOD_text_t txt, TCOD_key_t key);
+TCODLIB_API void TCOD_text_render(TCOD_text_t txt, TCOD_console_t con);
+TCODLIB_API const char * TCOD_text_get(TCOD_text_t txt);
+TCODLIB_API void TCOD_text_reset(TCOD_text_t txt);
+TCODLIB_API void TCOD_text_delete(TCOD_text_t txt);
+
+#endif
--- /dev/null
+++ b/include/libtcod/zip.h
@@ -0,0 +1,62 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_ZIP_H
+#define _TCOD_ZIP_H
+
+typedef void *TCOD_zip_t;
+
+TCODLIB_API TCOD_zip_t TCOD_zip_new();
+TCODLIB_API void TCOD_zip_delete(TCOD_zip_t zip);
+
+/* output interface */
+TCODLIB_API void TCOD_zip_put_char(TCOD_zip_t zip, char val);
+TCODLIB_API void TCOD_zip_put_int(TCOD_zip_t zip, int val);
+TCODLIB_API void TCOD_zip_put_float(TCOD_zip_t zip, float val);
+TCODLIB_API void TCOD_zip_put_string(TCOD_zip_t zip, const char *val);
+TCODLIB_API void TCOD_zip_put_color(TCOD_zip_t zip, const TCOD_color_t val);
+TCODLIB_API void TCOD_zip_put_image(TCOD_zip_t zip, const TCOD_image_t val);
+TCODLIB_API void TCOD_zip_put_console(TCOD_zip_t zip, const TCOD_console_t val);
+TCODLIB_API void TCOD_zip_put_data(TCOD_zip_t zip, int nbBytes, const void *data);
+TCODLIB_API uint32 TCOD_zip_get_current_bytes(TCOD_zip_t zip);
+TCODLIB_API int TCOD_zip_save_to_file(TCOD_zip_t zip, const char *filename);
+
+/* input interface */
+TCODLIB_API int TCOD_zip_load_from_file(TCOD_zip_t zip, const char *filename);
+TCODLIB_API char TCOD_zip_get_char(TCOD_zip_t zip);
+TCODLIB_API int TCOD_zip_get_int(TCOD_zip_t zip);
+TCODLIB_API float TCOD_zip_get_float(TCOD_zip_t zip);
+TCODLIB_API const char *TCOD_zip_get_string(TCOD_zip_t zip);
+TCODLIB_API TCOD_color_t TCOD_zip_get_color(TCOD_zip_t zip);
+TCODLIB_API TCOD_image_t TCOD_zip_get_image(TCOD_zip_t zip);
+TCODLIB_API TCOD_console_t TCOD_zip_get_console(TCOD_zip_t zip);
+TCODLIB_API int TCOD_zip_get_data(TCOD_zip_t zip, int nbBytes, void *data);
+TCODLIB_API uint32 TCOD_zip_get_remaining_bytes(TCOD_zip_t zip);
+TCODLIB_API void TCOD_zip_skip_bytes(TCOD_zip_t zip, uint32 nbBytes);
+
+#endif
+
--- a/include/list.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_LIST_H
-#define _TCOD_LIST_H
-
-typedef void *TCOD_list_t;
-
-TCODLIB_API TCOD_list_t TCOD_list_new();
-TCODLIB_API TCOD_list_t TCOD_list_allocate(int nb_elements);
-TCODLIB_API TCOD_list_t TCOD_list_duplicate(TCOD_list_t l);
-TCODLIB_API void TCOD_list_delete(TCOD_list_t l);
-TCODLIB_API void TCOD_list_push(TCOD_list_t l, const void * elt);
-TCODLIB_API void * TCOD_list_pop(TCOD_list_t l);
-TCODLIB_API void * TCOD_list_peek(TCOD_list_t l);
-TCODLIB_API void TCOD_list_add_all(TCOD_list_t l, TCOD_list_t l2);
-TCODLIB_API void * TCOD_list_get(TCOD_list_t l,int idx);
-TCODLIB_API void TCOD_list_set(TCOD_list_t l,const void *elt, int idx);
-TCODLIB_API void ** TCOD_list_begin(TCOD_list_t l);
-TCODLIB_API void ** TCOD_list_end(TCOD_list_t l);
-TCODLIB_API void TCOD_list_reverse(TCOD_list_t l);
-TCODLIB_API void **TCOD_list_remove_iterator(TCOD_list_t l, void **elt);
-TCODLIB_API void TCOD_list_remove(TCOD_list_t l, const void * elt);
-TCODLIB_API void **TCOD_list_remove_iterator_fast(TCOD_list_t l, void **elt);
-TCODLIB_API void TCOD_list_remove_fast(TCOD_list_t l, const void * elt);
-TCODLIB_API bool TCOD_list_contains(TCOD_list_t l,const void * elt);
-TCODLIB_API void TCOD_list_clear(TCOD_list_t l);
-TCODLIB_API void TCOD_list_clear_and_delete(TCOD_list_t l);
-TCODLIB_API int TCOD_list_size(TCOD_list_t l);
-TCODLIB_API void ** TCOD_list_insert_before(TCOD_list_t l,const void *elt,int before);
-TCODLIB_API bool TCOD_list_is_empty(TCOD_list_t l);
-
-#endif
--- a/include/mersenne.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_RANDOM_H
-#define _TCOD_RANDOM_H
-
-#include "mersenne_types.h"
-
-typedef void *TCOD_random_t;
-
-TCODLIB_API TCOD_random_t TCOD_random_get_instance(void);
-TCODLIB_API TCOD_random_t TCOD_random_new(TCOD_random_algo_t algo);
-TCODLIB_API TCOD_random_t TCOD_random_save(TCOD_random_t mersenne);
-TCODLIB_API void TCOD_random_restore(TCOD_random_t mersenne, TCOD_random_t backup);
-TCODLIB_API TCOD_random_t TCOD_random_new_from_seed(TCOD_random_algo_t algo, uint32 seed);
-TCODLIB_API void TCOD_random_delete(TCOD_random_t mersenne);
-
-TCODLIB_API void TCOD_random_set_distribution (TCOD_random_t mersenne, TCOD_distribution_t distribution);
-
-TCODLIB_API int TCOD_random_get_int (TCOD_random_t mersenne, int min, int max);
-TCODLIB_API float TCOD_random_get_float (TCOD_random_t mersenne, float min, float max);
-TCODLIB_API double TCOD_random_get_double (TCOD_random_t mersenne, double min, double max);
-
-TCODLIB_API int TCOD_random_get_int_mean (TCOD_random_t mersenne, int min, int max, int mean);
-TCODLIB_API float TCOD_random_get_float_mean (TCOD_random_t mersenne, float min, float max, float mean);
-TCODLIB_API double TCOD_random_get_double_mean (TCOD_random_t mersenne, double min, double max, double mean);
-
-TCODLIB_API TCOD_dice_t TCOD_random_dice_new (const char * s);
-TCODLIB_API int TCOD_random_dice_roll (TCOD_random_t mersenne, TCOD_dice_t dice);
-TCODLIB_API int TCOD_random_dice_roll_s (TCOD_random_t mersenne, const char * s);
-
-#endif
--- a/include/mouse.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_MOUSE_H
-#define _TCOD_MOUSE_H
-
-#include "mouse_types.h"
-
-TCODLIB_API void TCOD_mouse_show_cursor(bool visible);
-TCODLIB_API TCOD_mouse_t TCOD_mouse_get_status();
-TCODLIB_API bool TCOD_mouse_is_cursor_visible();
-TCODLIB_API void TCOD_mouse_move(int x, int y);
-TCODLIB_API void TCOD_mouse_includes_touch(bool enable);
-
-#endif
--- a/include/namegen.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-/*
-* Mingos' NameGen
-* This file was written by Dominik "Mingos" Marczuk.
-*/
-
-#ifndef _TCOD_NAMEGEN_H
-#define _TCOD_NAMEGEN_H
-
-/* the generator typedef */
-typedef void * TCOD_namegen_t;
-
-/* parse a file with syllable sets */
-TCODLIB_API void TCOD_namegen_parse (const char * filename, TCOD_random_t random);
-/* generate a name */
-TCODLIB_API char * TCOD_namegen_generate (char * name, bool allocate);
-/* generate a name using a custom generation rule */
-TCODLIB_API char * TCOD_namegen_generate_custom (char * name, char * rule, bool allocate);
-/* retrieve the list of all available syllable set names */
-TCODLIB_API TCOD_list_t TCOD_namegen_get_sets (void);
-/* delete a generator */
-TCODLIB_API void TCOD_namegen_destroy (void);
-
-#endif
--- a/include/noise.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_PERLIN_H
-#define _TCOD_PERLIN_H
-
-typedef void *TCOD_noise_t;
-
-typedef enum {
-	TCOD_NOISE_PERLIN = 1,
-	TCOD_NOISE_SIMPLEX = 2,
-	TCOD_NOISE_WAVELET = 4,
-	TCOD_NOISE_DEFAULT = 0
-} TCOD_noise_type_t;
-
-#include "noise_defaults.h"
-
-/* create a new noise object */
-TCODLIB_API TCOD_noise_t TCOD_noise_new(int dimensions, float hurst, float lacunarity, TCOD_random_t random);
-
-/* simplified API */
-TCODLIB_API void TCOD_noise_set_type (TCOD_noise_t noise, TCOD_noise_type_t type);
-TCODLIB_API float TCOD_noise_get_ex (TCOD_noise_t noise, float *f, TCOD_noise_type_t type);
-TCODLIB_API float TCOD_noise_get_fbm_ex (TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t type);
-TCODLIB_API float TCOD_noise_get_turbulence_ex (TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t type);
-TCODLIB_API float TCOD_noise_get (TCOD_noise_t noise, float *f);
-TCODLIB_API float TCOD_noise_get_fbm (TCOD_noise_t noise, float *f, float octaves);
-TCODLIB_API float TCOD_noise_get_turbulence (TCOD_noise_t noise, float *f, float octaves);
-/* delete the noise object */
-TCODLIB_API void TCOD_noise_delete(TCOD_noise_t noise);
-
-#endif
--- a/include/parser.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_PARSER_H
-#define _TCOD_PARSER_H
-
-/* generic type */
-typedef enum {
-	TCOD_TYPE_NONE,
-	TCOD_TYPE_BOOL,
-	TCOD_TYPE_CHAR,
-	TCOD_TYPE_INT,
-	TCOD_TYPE_FLOAT,
-	TCOD_TYPE_STRING,
-	TCOD_TYPE_COLOR,
-	TCOD_TYPE_DICE,
-	TCOD_TYPE_VALUELIST00,
-	TCOD_TYPE_VALUELIST01,
-	TCOD_TYPE_VALUELIST02,
-	TCOD_TYPE_VALUELIST03,
-	TCOD_TYPE_VALUELIST04,
-	TCOD_TYPE_VALUELIST05,
-	TCOD_TYPE_VALUELIST06,
-	TCOD_TYPE_VALUELIST07,
-	TCOD_TYPE_VALUELIST08,
-	TCOD_TYPE_VALUELIST09,
-	TCOD_TYPE_VALUELIST10,
-	TCOD_TYPE_VALUELIST11,
-	TCOD_TYPE_VALUELIST12,
-	TCOD_TYPE_VALUELIST13,
-	TCOD_TYPE_VALUELIST14,
-	TCOD_TYPE_VALUELIST15,
-	TCOD_TYPE_CUSTOM00,
-	TCOD_TYPE_CUSTOM01,
-	TCOD_TYPE_CUSTOM02,
-	TCOD_TYPE_CUSTOM03,
-	TCOD_TYPE_CUSTOM04,
-	TCOD_TYPE_CUSTOM05,
-	TCOD_TYPE_CUSTOM06,
-	TCOD_TYPE_CUSTOM07,
-	TCOD_TYPE_CUSTOM08,
-	TCOD_TYPE_CUSTOM09,
-	TCOD_TYPE_CUSTOM10,
-	TCOD_TYPE_CUSTOM11,
-	TCOD_TYPE_CUSTOM12,
-	TCOD_TYPE_CUSTOM13,
-	TCOD_TYPE_CUSTOM14,
-	TCOD_TYPE_CUSTOM15,
-	TCOD_TYPE_LIST=1024
-} TCOD_value_type_t;
-
-/* generic value */
-typedef union {
-	bool b;
-	char c;
-	int32 i;
-	float f;
-	char *s;
-	TCOD_color_t col;
-	TCOD_dice_t dice;
-	TCOD_list_t list;
-	void *custom;
-} TCOD_value_t;
-
-/* parser structures */
-typedef void *TCOD_parser_struct_t;
-TCODLIB_API const char *TCOD_struct_get_name(TCOD_parser_struct_t def);
-TCODLIB_API void TCOD_struct_add_property(TCOD_parser_struct_t def, const char *name,TCOD_value_type_t type, bool mandatory);
-TCODLIB_API void TCOD_struct_add_list_property(TCOD_parser_struct_t def, const char *name,TCOD_value_type_t type, bool mandatory);
-TCODLIB_API void TCOD_struct_add_value_list(TCOD_parser_struct_t def,const char *name, const char **value_list, bool mandatory);
-TCODLIB_API void TCOD_struct_add_value_list_sized(TCOD_parser_struct_t def,const char *name, const char **value_list, int size, bool mandatory);
-TCODLIB_API void TCOD_struct_add_flag(TCOD_parser_struct_t def,const char *propname);
-TCODLIB_API void TCOD_struct_add_structure(TCOD_parser_struct_t def,TCOD_parser_struct_t sub_structure);
-TCODLIB_API bool TCOD_struct_is_mandatory(TCOD_parser_struct_t def,const char *propname);
-TCODLIB_API TCOD_value_type_t TCOD_struct_get_type(TCOD_parser_struct_t def, const char *propname);
-
-
-/* parser listener */
-typedef struct {
-	bool (*new_struct)(TCOD_parser_struct_t str,const char *name);
-	bool (*new_flag)(const char *name);
-	bool (*new_property)(const char *propname, TCOD_value_type_t type, TCOD_value_t value);
-	bool (*end_struct)(TCOD_parser_struct_t str, const char *name);
-	void (*error)(const char *msg);
-} TCOD_parser_listener_t;
-
-/* a custom type parser */
-typedef TCOD_value_t (*TCOD_parser_custom_t)(TCOD_lex_t *lex, TCOD_parser_listener_t *listener, TCOD_parser_struct_t str, char *propname);
-
-/* the parser */
-typedef void *TCOD_parser_t;
-
-TCODLIB_API TCOD_parser_t TCOD_parser_new();
-TCODLIB_API TCOD_parser_struct_t TCOD_parser_new_struct(TCOD_parser_t parser, char *name);
-TCODLIB_API TCOD_value_type_t TCOD_parser_new_custom_type(TCOD_parser_t parser,TCOD_parser_custom_t custom_type_parser);
-TCODLIB_API void TCOD_parser_run(TCOD_parser_t parser, const char *filename, TCOD_parser_listener_t *listener);
-TCODLIB_API void TCOD_parser_delete(TCOD_parser_t parser);
-/* error during parsing. can be called by the parser listener */
-TCODLIB_API void TCOD_parser_error(const char *msg, ...);
-/* default parser listener */
-TCODLIB_API bool TCOD_parser_get_bool_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API int TCOD_parser_get_char_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API int TCOD_parser_get_int_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API float TCOD_parser_get_float_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API const char * TCOD_parser_get_string_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API TCOD_color_t TCOD_parser_get_color_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API TCOD_dice_t TCOD_parser_get_dice_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API void TCOD_parser_get_dice_property_py(TCOD_parser_t parser, const char *name, TCOD_dice_t *dice);
-TCODLIB_API void * TCOD_parser_get_custom_property(TCOD_parser_t parser, const char *name);
-TCODLIB_API TCOD_list_t TCOD_parser_get_list_property(TCOD_parser_t parser, const char *name, TCOD_value_type_t type);
-
-/* parser internals (may be used by custom type parsers) */
-/* parser structures */
-typedef struct {
-	char *name; /* entity type name */
-	/* list of flags */
-	TCOD_list_t flags;
-	/* list of properties (name, type, mandatory) */
-	TCOD_list_t props;
-	/* list of value lists */
-	TCOD_list_t lists;
-	/* list of sub-structures */
-	TCOD_list_t structs;
-} TCOD_struct_int_t;
-/* the parser */
-typedef struct {
-	/* list of structures */
-	TCOD_list_t structs;
-	/* list of custom type parsers */
-	TCOD_parser_custom_t customs[16];
-	/* fatal error occured */
-	bool fatal;
-	/* list of properties if default listener is used */
-	TCOD_list_t props;
-} TCOD_parser_int_t;
-TCODLIB_API TCOD_value_t TCOD_parse_bool_value();
-TCODLIB_API TCOD_value_t TCOD_parse_char_value();
-TCODLIB_API TCOD_value_t TCOD_parse_integer_value();
-TCODLIB_API TCOD_value_t TCOD_parse_float_value();
-TCODLIB_API TCOD_value_t TCOD_parse_string_value();
-TCODLIB_API TCOD_value_t TCOD_parse_color_value();
-TCODLIB_API TCOD_value_t TCOD_parse_dice_value();
-TCODLIB_API TCOD_value_t TCOD_parse_value_list_value(TCOD_struct_int_t *def,int listnum);
-TCODLIB_API TCOD_value_t TCOD_parse_property_value(TCOD_parser_int_t *parser, TCOD_parser_struct_t def, char *propname, bool list);
-
-#endif
--- a/include/path.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_PATH_H
-#define _TCOD_PATH_H
-
-typedef float (*TCOD_path_func_t)( int xFrom, int yFrom, int xTo, int yTo, void *user_data );
-typedef void *TCOD_path_t;
-
-TCODLIB_API TCOD_path_t TCOD_path_new_using_map(TCOD_map_t map, float diagonalCost);
-TCODLIB_API TCOD_path_t TCOD_path_new_using_function(int map_width, int map_height, TCOD_path_func_t func, void *user_data, float diagonalCost);
-
-TCODLIB_API bool TCOD_path_compute(TCOD_path_t path, int ox,int oy, int dx, int dy);
-TCODLIB_API bool TCOD_path_walk(TCOD_path_t path, int *x, int *y, bool recalculate_when_needed);
-TCODLIB_API bool TCOD_path_is_empty(TCOD_path_t path);
-TCODLIB_API int TCOD_path_size(TCOD_path_t path);
-TCODLIB_API void TCOD_path_reverse(TCOD_path_t path);
-TCODLIB_API void TCOD_path_get(TCOD_path_t path, int index, int *x, int *y);
-TCODLIB_API void TCOD_path_get_origin(TCOD_path_t path, int *x, int *y);
-TCODLIB_API void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y);
-TCODLIB_API void TCOD_path_delete(TCOD_path_t path);
-
-/* Dijkstra stuff - by Mingos*/
-
-typedef void *TCOD_dijkstra_t;
-
-TCODLIB_API TCOD_dijkstra_t TCOD_dijkstra_new (TCOD_map_t map, float diagonalCost);
-TCODLIB_API TCOD_dijkstra_t TCOD_dijkstra_new_using_function(int map_width, int map_height, TCOD_path_func_t func, void *user_data, float diagonalCost);
-TCODLIB_API void TCOD_dijkstra_compute (TCOD_dijkstra_t dijkstra, int root_x, int root_y);
-TCODLIB_API float TCOD_dijkstra_get_distance (TCOD_dijkstra_t dijkstra, int x, int y);
-TCODLIB_API bool TCOD_dijkstra_path_set (TCOD_dijkstra_t dijkstra, int x, int y);
-TCODLIB_API bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t path);
-TCODLIB_API int TCOD_dijkstra_size(TCOD_dijkstra_t path);
-TCODLIB_API void TCOD_dijkstra_reverse(TCOD_dijkstra_t path);
-TCODLIB_API void TCOD_dijkstra_get(TCOD_dijkstra_t path, int index, int *x, int *y);
-TCODLIB_API bool TCOD_dijkstra_path_walk (TCOD_dijkstra_t dijkstra, int *x, int *y);
-TCODLIB_API void TCOD_dijkstra_delete (TCOD_dijkstra_t dijkstra);
-
-#endif
--- a/include/sys.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_SYS_H
-#define _TCOD_SYS_H
-
-TCODLIB_API uint32 TCOD_sys_elapsed_milli();
-TCODLIB_API float TCOD_sys_elapsed_seconds();
-TCODLIB_API void TCOD_sys_sleep_milli(uint32 val);
-TCODLIB_API void TCOD_sys_save_screenshot(const char *filename);
-TCODLIB_API void TCOD_sys_force_fullscreen_resolution(int width, int height);
-TCODLIB_API void TCOD_sys_set_renderer(TCOD_renderer_t renderer);
-TCODLIB_API TCOD_renderer_t TCOD_sys_get_renderer();
-TCODLIB_API void TCOD_sys_set_fps(int val);
-TCODLIB_API int TCOD_sys_get_fps();
-TCODLIB_API float TCOD_sys_get_last_frame_length();
-TCODLIB_API void TCOD_sys_get_current_resolution(int *w, int *h);
-TCODLIB_API void TCOD_sys_get_fullscreen_offsets(int *offx, int *offy);
-TCODLIB_API void TCOD_sys_update_char(int asciiCode, int fontx, int fonty, TCOD_image_t img, int x, int y);
-TCODLIB_API void TCOD_sys_get_char_size(int *w, int *h);
-TCODLIB_API void *TCOD_sys_get_sdl_window();
-
-typedef enum {
-  TCOD_EVENT_KEY_PRESS=1,
-  TCOD_EVENT_KEY_RELEASE=2,
-  TCOD_EVENT_KEY=TCOD_EVENT_KEY_PRESS|TCOD_EVENT_KEY_RELEASE,
-  TCOD_EVENT_MOUSE_MOVE=4,
-  TCOD_EVENT_MOUSE_PRESS=8,
-  TCOD_EVENT_MOUSE_RELEASE=16,
-  TCOD_EVENT_MOUSE=TCOD_EVENT_MOUSE_MOVE|TCOD_EVENT_MOUSE_PRESS|TCOD_EVENT_MOUSE_RELEASE,
-  TCOD_EVENT_ANY=TCOD_EVENT_KEY|TCOD_EVENT_MOUSE,
-} TCOD_event_t;
-TCODLIB_API TCOD_event_t TCOD_sys_wait_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush);
-TCODLIB_API TCOD_event_t TCOD_sys_check_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse);
-
-/* filesystem stuff */
-TCODLIB_API bool TCOD_sys_create_directory(const char *path);
-TCODLIB_API bool TCOD_sys_delete_file(const char *path);
-TCODLIB_API bool TCOD_sys_delete_directory(const char *path);
-TCODLIB_API bool TCOD_sys_is_directory(const char *path);
-TCODLIB_API TCOD_list_t TCOD_sys_get_directory_content(const char *path, const char *pattern);
-TCODLIB_API bool TCOD_sys_file_exists(const char * filename, ...);
-TCODLIB_API bool TCOD_sys_read_file(const char *filename, unsigned char **buf, uint32 *size);
-TCODLIB_API bool TCOD_sys_write_file(const char *filename, unsigned char *buf, uint32 size);
-
-/* clipboard */
-TCODLIB_API void TCOD_sys_clipboard_set(const char *value);
-TCODLIB_API char *TCOD_sys_clipboard_get();
-
-/* thread stuff */
-typedef void *TCOD_thread_t;
-typedef void *TCOD_semaphore_t;
-typedef void *TCOD_mutex_t;
-typedef void *TCOD_cond_t;
-/* threads */
-TCODLIB_API TCOD_thread_t TCOD_thread_new(int (*func)(void *), void *data);
-TCODLIB_API void TCOD_thread_delete(TCOD_thread_t th);
-TCODLIB_API int TCOD_sys_get_num_cores();
-TCODLIB_API void TCOD_thread_wait(TCOD_thread_t th);
-/* mutex */
-TCODLIB_API TCOD_mutex_t TCOD_mutex_new();
-TCODLIB_API void TCOD_mutex_in(TCOD_mutex_t mut);
-TCODLIB_API void TCOD_mutex_out(TCOD_mutex_t mut);
-TCODLIB_API void TCOD_mutex_delete(TCOD_mutex_t mut);
-/* semaphore */
-TCODLIB_API TCOD_semaphore_t TCOD_semaphore_new(int initVal);
-TCODLIB_API void TCOD_semaphore_lock(TCOD_semaphore_t sem);
-TCODLIB_API void TCOD_semaphore_unlock(TCOD_semaphore_t sem);
-TCODLIB_API void TCOD_semaphore_delete( TCOD_semaphore_t sem);
-/* condition */
-TCODLIB_API TCOD_cond_t TCOD_condition_new();
-TCODLIB_API void TCOD_condition_signal(TCOD_cond_t sem);
-TCODLIB_API void TCOD_condition_broadcast(TCOD_cond_t sem);
-TCODLIB_API void TCOD_condition_wait(TCOD_cond_t sem, TCOD_mutex_t mut);
-TCODLIB_API void TCOD_condition_delete( TCOD_cond_t sem);
-/* dynamic library */
-typedef void *TCOD_library_t;
-TCODLIB_API TCOD_library_t TCOD_load_library(const char *path);
-TCODLIB_API void * TCOD_get_function_address(TCOD_library_t library, const char *function_name);
-TCODLIB_API void TCOD_close_library(TCOD_library_t);
-/* SDL renderer callback */
-typedef void (*SDL_renderer_t) (void *sdl_surface);
-TCODLIB_API void TCOD_sys_register_SDL_renderer(SDL_renderer_t renderer);
-#endif
--- a/include/tree.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_TREE_H
-#define _TCOD_TREE_H
-
-typedef struct _TCOD_tree_t {
-	struct _TCOD_tree_t *next;
-	struct _TCOD_tree_t *father;
-	struct _TCOD_tree_t *sons;
-} TCOD_tree_t;
-
-TCODLIB_API TCOD_tree_t *TCOD_tree_new();
-TCODLIB_API void TCOD_tree_add_son(TCOD_tree_t *node, TCOD_tree_t *son);
-
-#endif
--- a/include/txtfield.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-#ifndef _TCOD_TEXT_H_
-#define _TCOD_TEXT_H_
-
-typedef void * TCOD_text_t;
-
-TCODLIB_API TCOD_text_t TCOD_text_init(int x, int y, int w, int h, int max_chars);
-TCODLIB_API void TCOD_text_set_properties(TCOD_text_t txt, int cursor_char, int blink_interval, const char * prompt, int tab_size);
-TCODLIB_API void TCOD_text_set_colors(TCOD_text_t txt, TCOD_color_t fore, TCOD_color_t back, float back_transparency);
-TCODLIB_API bool TCOD_text_update(TCOD_text_t txt, TCOD_key_t key);
-TCODLIB_API void TCOD_text_render(TCOD_text_t txt, TCOD_console_t con);
-TCODLIB_API const char * TCOD_text_get(TCOD_text_t txt);
-TCODLIB_API void TCOD_text_reset(TCOD_text_t txt);
-TCODLIB_API void TCOD_text_delete(TCOD_text_t txt);
-
-#endif
--- a/include/zip.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_ZIP_H
-#define _TCOD_ZIP_H
-
-typedef void *TCOD_zip_t;
-
-TCODLIB_API TCOD_zip_t TCOD_zip_new();
-TCODLIB_API void TCOD_zip_delete(TCOD_zip_t zip);
-
-/* output interface */
-TCODLIB_API void TCOD_zip_put_char(TCOD_zip_t zip, char val);
-TCODLIB_API void TCOD_zip_put_int(TCOD_zip_t zip, int val);
-TCODLIB_API void TCOD_zip_put_float(TCOD_zip_t zip, float val);
-TCODLIB_API void TCOD_zip_put_string(TCOD_zip_t zip, const char *val);
-TCODLIB_API void TCOD_zip_put_color(TCOD_zip_t zip, const TCOD_color_t val);
-TCODLIB_API void TCOD_zip_put_image(TCOD_zip_t zip, const TCOD_image_t val);
-TCODLIB_API void TCOD_zip_put_console(TCOD_zip_t zip, const TCOD_console_t val);
-TCODLIB_API void TCOD_zip_put_data(TCOD_zip_t zip, int nbBytes, const void *data);
-TCODLIB_API uint32 TCOD_zip_get_current_bytes(TCOD_zip_t zip);
-TCODLIB_API int TCOD_zip_save_to_file(TCOD_zip_t zip, const char *filename);
-
-/* input interface */
-TCODLIB_API int TCOD_zip_load_from_file(TCOD_zip_t zip, const char *filename);
-TCODLIB_API char TCOD_zip_get_char(TCOD_zip_t zip);
-TCODLIB_API int TCOD_zip_get_int(TCOD_zip_t zip);
-TCODLIB_API float TCOD_zip_get_float(TCOD_zip_t zip);
-TCODLIB_API const char *TCOD_zip_get_string(TCOD_zip_t zip);
-TCODLIB_API TCOD_color_t TCOD_zip_get_color(TCOD_zip_t zip);
-TCODLIB_API TCOD_image_t TCOD_zip_get_image(TCOD_zip_t zip);
-TCODLIB_API TCOD_console_t TCOD_zip_get_console(TCOD_zip_t zip);
-TCODLIB_API int TCOD_zip_get_data(TCOD_zip_t zip, int nbBytes, void *data);
-TCODLIB_API uint32 TCOD_zip_get_remaining_bytes(TCOD_zip_t zip);
-TCODLIB_API void TCOD_zip_skip_bytes(TCOD_zip_t zip, uint32 nbBytes);
-
-#endif
-
--- a/include/console_types.h
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_CONSOLE_TYPES_H
-#define _TCOD_CONSOLE_TYPES_H
-
-typedef enum {
-	TCODK_NONE,
-	TCODK_ESCAPE,
-	TCODK_BACKSPACE,
-	TCODK_TAB,
-	TCODK_ENTER,
-	TCODK_SHIFT,
-	TCODK_CONTROL,
-	TCODK_ALT,
-	TCODK_PAUSE,
-	TCODK_CAPSLOCK,
-	TCODK_PAGEUP,
-	TCODK_PAGEDOWN,
-	TCODK_END,
-	TCODK_HOME,
-	TCODK_UP,
-	TCODK_LEFT,
-	TCODK_RIGHT,
-	TCODK_DOWN,
-	TCODK_PRINTSCREEN,
-	TCODK_INSERT,
-	TCODK_DELETE,
-	TCODK_LWIN,
-	TCODK_RWIN,
-	TCODK_APPS,
-	TCODK_0,
-	TCODK_1,
-	TCODK_2,
-	TCODK_3,
-	TCODK_4,
-	TCODK_5,
-	TCODK_6,
-	TCODK_7,
-	TCODK_8,
-	TCODK_9,
-	TCODK_KP0,
-	TCODK_KP1,
-	TCODK_KP2,
-	TCODK_KP3,
-	TCODK_KP4,
-	TCODK_KP5,
-	TCODK_KP6,
-	TCODK_KP7,
-	TCODK_KP8,
-	TCODK_KP9,
-	TCODK_KPADD,
-	TCODK_KPSUB,
-	TCODK_KPDIV,
-	TCODK_KPMUL,
-	TCODK_KPDEC,
-	TCODK_KPENTER,
-	TCODK_F1,
-	TCODK_F2,
-	TCODK_F3,
-	TCODK_F4,
-	TCODK_F5,
-	TCODK_F6,
-	TCODK_F7,
-	TCODK_F8,
-	TCODK_F9,
-	TCODK_F10,
-	TCODK_F11,
-	TCODK_F12,
-	TCODK_NUMLOCK,
-	TCODK_SCROLLLOCK,
-	TCODK_SPACE,
-	TCODK_CHAR
-} TCOD_keycode_t;
-
-/* key data : special code or character */
-typedef struct {
-	TCOD_keycode_t vk; /*  key code */
-	char c; /* character if vk == TCODK_CHAR else 0 */
-	bool pressed ; /* does this correspond to a key press or key release event ? */
-	bool lalt ;
-	bool lctrl ;
-	bool ralt ;
-	bool rctrl ;
-	bool shift ;
-} TCOD_key_t;
-
-typedef enum {
-	/* single walls */
-	TCOD_CHAR_HLINE=196,
-	TCOD_CHAR_VLINE=179,
-	TCOD_CHAR_NE=191,
-	TCOD_CHAR_NW=218,
-	TCOD_CHAR_SE=217,
-	TCOD_CHAR_SW=192,
-	TCOD_CHAR_TEEW=180,
-	TCOD_CHAR_TEEE=195,
-	TCOD_CHAR_TEEN=193,
-	TCOD_CHAR_TEES=194,
-	TCOD_CHAR_CROSS=197,
-	/* double walls */
-	TCOD_CHAR_DHLINE=205,
-	TCOD_CHAR_DVLINE=186,
-	TCOD_CHAR_DNE=187,
-	TCOD_CHAR_DNW=201,
-	TCOD_CHAR_DSE=188,
-	TCOD_CHAR_DSW=200,
-	TCOD_CHAR_DTEEW=185,
-	TCOD_CHAR_DTEEE=204,
-	TCOD_CHAR_DTEEN=202,
-	TCOD_CHAR_DTEES=203,
-	TCOD_CHAR_DCROSS=206,
-	/* blocks */
-	TCOD_CHAR_BLOCK1=176,
-	TCOD_CHAR_BLOCK2=177,
-	TCOD_CHAR_BLOCK3=178,
-	/* arrows */
-	TCOD_CHAR_ARROW_N=24,
-	TCOD_CHAR_ARROW_S=25,
-	TCOD_CHAR_ARROW_E=26,
-	TCOD_CHAR_ARROW_W=27,
-	/* arrows without tail */
-	TCOD_CHAR_ARROW2_N=30,
-	TCOD_CHAR_ARROW2_S=31,
-	TCOD_CHAR_ARROW2_E=16,
-	TCOD_CHAR_ARROW2_W=17,
-	/* double arrows */
-	TCOD_CHAR_DARROW_H=29,
-	TCOD_CHAR_DARROW_V=18,
-	/* GUI stuff */
-	TCOD_CHAR_CHECKBOX_UNSET=224,
-	TCOD_CHAR_CHECKBOX_SET=225,
-	TCOD_CHAR_RADIO_UNSET=9,
-	TCOD_CHAR_RADIO_SET=10,
-	/* sub-pixel resolution kit */
-	TCOD_CHAR_SUBP_NW=226,
-	TCOD_CHAR_SUBP_NE=227,
-	TCOD_CHAR_SUBP_N=228,
-	TCOD_CHAR_SUBP_SE=229,
-	TCOD_CHAR_SUBP_DIAG=230,
-	TCOD_CHAR_SUBP_E=231,
-	TCOD_CHAR_SUBP_SW=232,
-	/* miscellaneous */
-	TCOD_CHAR_SMILIE = 1,
-	TCOD_CHAR_SMILIE_INV = 2,
-	TCOD_CHAR_HEART = 3,
-	TCOD_CHAR_DIAMOND = 4,
-	TCOD_CHAR_CLUB = 5,
-	TCOD_CHAR_SPADE = 6,
-	TCOD_CHAR_BULLET = 7,
-	TCOD_CHAR_BULLET_INV = 8,
-	TCOD_CHAR_MALE = 11,
-	TCOD_CHAR_FEMALE = 12,
-	TCOD_CHAR_NOTE = 13,
-	TCOD_CHAR_NOTE_DOUBLE = 14,
-	TCOD_CHAR_LIGHT = 15,
-	TCOD_CHAR_EXCLAM_DOUBLE = 19,
-	TCOD_CHAR_PILCROW = 20,
-	TCOD_CHAR_SECTION = 21,
-	TCOD_CHAR_POUND = 156,
-	TCOD_CHAR_MULTIPLICATION = 158,
-	TCOD_CHAR_FUNCTION = 159,
-	TCOD_CHAR_RESERVED = 169,
-	TCOD_CHAR_HALF = 171,
-	TCOD_CHAR_ONE_QUARTER = 172,
-	TCOD_CHAR_COPYRIGHT = 184,
-	TCOD_CHAR_CENT = 189,
-	TCOD_CHAR_YEN = 190,
-	TCOD_CHAR_CURRENCY = 207,
-	TCOD_CHAR_THREE_QUARTERS = 243,
-	TCOD_CHAR_DIVISION = 246,
-	TCOD_CHAR_GRADE = 248,
-	TCOD_CHAR_UMLAUT = 249,
-	TCOD_CHAR_POW1 = 251,
-	TCOD_CHAR_POW3 = 252,
-	TCOD_CHAR_POW2 = 253,
-	TCOD_CHAR_BULLET_SQUARE = 254,
-	/* diacritics */
-} TCOD_chars_t;
-
-typedef enum {
-	TCOD_COLCTRL_1 = 1,
-	TCOD_COLCTRL_2,
-	TCOD_COLCTRL_3,
-	TCOD_COLCTRL_4,
-	TCOD_COLCTRL_5,
-	TCOD_COLCTRL_NUMBER=5,
-	TCOD_COLCTRL_FORE_RGB,
-	TCOD_COLCTRL_BACK_RGB,
-	TCOD_COLCTRL_STOP
-} TCOD_colctrl_t;
-
-typedef enum {
-	TCOD_BKGND_NONE,
-	TCOD_BKGND_SET,
-	TCOD_BKGND_MULTIPLY,
-	TCOD_BKGND_LIGHTEN,
-	TCOD_BKGND_DARKEN,
-	TCOD_BKGND_SCREEN,
-	TCOD_BKGND_COLOR_DODGE,
-	TCOD_BKGND_COLOR_BURN,
-	TCOD_BKGND_ADD,
-	TCOD_BKGND_ADDA,
-	TCOD_BKGND_BURN,
-	TCOD_BKGND_OVERLAY,
-	TCOD_BKGND_ALPH,
-	TCOD_BKGND_DEFAULT
-} TCOD_bkgnd_flag_t;
-
-typedef enum {
-	TCOD_KEY_PRESSED=1,
-	TCOD_KEY_RELEASED=2,
-} TCOD_key_status_t;
-
-/* custom font flags */
-typedef enum {
-	TCOD_FONT_LAYOUT_ASCII_INCOL=1,
-	TCOD_FONT_LAYOUT_ASCII_INROW=2,
-	TCOD_FONT_TYPE_GREYSCALE=4,
-	TCOD_FONT_TYPE_GRAYSCALE=4,
-	TCOD_FONT_LAYOUT_TCOD=8,
-} TCOD_font_flags_t;
-
-typedef enum {
-	TCOD_RENDERER_GLSL,
-	TCOD_RENDERER_OPENGL,
-	TCOD_RENDERER_SDL,
-	TCOD_NB_RENDERERS,
-} TCOD_renderer_t;
-
-typedef enum {
-	TCOD_LEFT, 
-	TCOD_RIGHT, 
-	TCOD_CENTER 
-} TCOD_alignment_t;
-
-#endif /* _TCOD_CONSOLE_TYPES_H */
--- /dev/null
+++ b/include/libtcod/console_types.h
@@ -0,0 +1,261 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_CONSOLE_TYPES_H
+#define _TCOD_CONSOLE_TYPES_H
+
+typedef enum {
+	TCODK_NONE,
+	TCODK_ESCAPE,
+	TCODK_BACKSPACE,
+	TCODK_TAB,
+	TCODK_ENTER,
+	TCODK_SHIFT,
+	TCODK_CONTROL,
+	TCODK_ALT,
+	TCODK_PAUSE,
+	TCODK_CAPSLOCK,
+	TCODK_PAGEUP,
+	TCODK_PAGEDOWN,
+	TCODK_END,
+	TCODK_HOME,
+	TCODK_UP,
+	TCODK_LEFT,
+	TCODK_RIGHT,
+	TCODK_DOWN,
+	TCODK_PRINTSCREEN,
+	TCODK_INSERT,
+	TCODK_DELETE,
+	TCODK_LWIN,
+	TCODK_RWIN,
+	TCODK_APPS,
+	TCODK_0,
+	TCODK_1,
+	TCODK_2,
+	TCODK_3,
+	TCODK_4,
+	TCODK_5,
+	TCODK_6,
+	TCODK_7,
+	TCODK_8,
+	TCODK_9,
+	TCODK_KP0,
+	TCODK_KP1,
+	TCODK_KP2,
+	TCODK_KP3,
+	TCODK_KP4,
+	TCODK_KP5,
+	TCODK_KP6,
+	TCODK_KP7,
+	TCODK_KP8,
+	TCODK_KP9,
+	TCODK_KPADD,
+	TCODK_KPSUB,
+	TCODK_KPDIV,
+	TCODK_KPMUL,
+	TCODK_KPDEC,
+	TCODK_KPENTER,
+	TCODK_F1,
+	TCODK_F2,
+	TCODK_F3,
+	TCODK_F4,
+	TCODK_F5,
+	TCODK_F6,
+	TCODK_F7,
+	TCODK_F8,
+	TCODK_F9,
+	TCODK_F10,
+	TCODK_F11,
+	TCODK_F12,
+	TCODK_NUMLOCK,
+	TCODK_SCROLLLOCK,
+	TCODK_SPACE,
+	TCODK_CHAR
+} TCOD_keycode_t;
+
+/* key data : special code or character */
+typedef struct {
+	TCOD_keycode_t vk; /*  key code */
+	char c; /* character if vk == TCODK_CHAR else 0 */
+	bool pressed ; /* does this correspond to a key press or key release event ? */
+	bool lalt ;
+	bool lctrl ;
+	bool ralt ;
+	bool rctrl ;
+	bool shift ;
+} TCOD_key_t;
+
+typedef enum {
+	/* single walls */
+	TCOD_CHAR_HLINE=196,
+	TCOD_CHAR_VLINE=179,
+	TCOD_CHAR_NE=191,
+	TCOD_CHAR_NW=218,
+	TCOD_CHAR_SE=217,
+	TCOD_CHAR_SW=192,
+	TCOD_CHAR_TEEW=180,
+	TCOD_CHAR_TEEE=195,
+	TCOD_CHAR_TEEN=193,
+	TCOD_CHAR_TEES=194,
+	TCOD_CHAR_CROSS=197,
+	/* double walls */
+	TCOD_CHAR_DHLINE=205,
+	TCOD_CHAR_DVLINE=186,
+	TCOD_CHAR_DNE=187,
+	TCOD_CHAR_DNW=201,
+	TCOD_CHAR_DSE=188,
+	TCOD_CHAR_DSW=200,
+	TCOD_CHAR_DTEEW=185,
+	TCOD_CHAR_DTEEE=204,
+	TCOD_CHAR_DTEEN=202,
+	TCOD_CHAR_DTEES=203,
+	TCOD_CHAR_DCROSS=206,
+	/* blocks */
+	TCOD_CHAR_BLOCK1=176,
+	TCOD_CHAR_BLOCK2=177,
+	TCOD_CHAR_BLOCK3=178,
+	/* arrows */
+	TCOD_CHAR_ARROW_N=24,
+	TCOD_CHAR_ARROW_S=25,
+	TCOD_CHAR_ARROW_E=26,
+	TCOD_CHAR_ARROW_W=27,
+	/* arrows without tail */
+	TCOD_CHAR_ARROW2_N=30,
+	TCOD_CHAR_ARROW2_S=31,
+	TCOD_CHAR_ARROW2_E=16,
+	TCOD_CHAR_ARROW2_W=17,
+	/* double arrows */
+	TCOD_CHAR_DARROW_H=29,
+	TCOD_CHAR_DARROW_V=18,
+	/* GUI stuff */
+	TCOD_CHAR_CHECKBOX_UNSET=224,
+	TCOD_CHAR_CHECKBOX_SET=225,
+	TCOD_CHAR_RADIO_UNSET=9,
+	TCOD_CHAR_RADIO_SET=10,
+	/* sub-pixel resolution kit */
+	TCOD_CHAR_SUBP_NW=226,
+	TCOD_CHAR_SUBP_NE=227,
+	TCOD_CHAR_SUBP_N=228,
+	TCOD_CHAR_SUBP_SE=229,
+	TCOD_CHAR_SUBP_DIAG=230,
+	TCOD_CHAR_SUBP_E=231,
+	TCOD_CHAR_SUBP_SW=232,
+	/* miscellaneous */
+	TCOD_CHAR_SMILIE = 1,
+	TCOD_CHAR_SMILIE_INV = 2,
+	TCOD_CHAR_HEART = 3,
+	TCOD_CHAR_DIAMOND = 4,
+	TCOD_CHAR_CLUB = 5,
+	TCOD_CHAR_SPADE = 6,
+	TCOD_CHAR_BULLET = 7,
+	TCOD_CHAR_BULLET_INV = 8,
+	TCOD_CHAR_MALE = 11,
+	TCOD_CHAR_FEMALE = 12,
+	TCOD_CHAR_NOTE = 13,
+	TCOD_CHAR_NOTE_DOUBLE = 14,
+	TCOD_CHAR_LIGHT = 15,
+	TCOD_CHAR_EXCLAM_DOUBLE = 19,
+	TCOD_CHAR_PILCROW = 20,
+	TCOD_CHAR_SECTION = 21,
+	TCOD_CHAR_POUND = 156,
+	TCOD_CHAR_MULTIPLICATION = 158,
+	TCOD_CHAR_FUNCTION = 159,
+	TCOD_CHAR_RESERVED = 169,
+	TCOD_CHAR_HALF = 171,
+	TCOD_CHAR_ONE_QUARTER = 172,
+	TCOD_CHAR_COPYRIGHT = 184,
+	TCOD_CHAR_CENT = 189,
+	TCOD_CHAR_YEN = 190,
+	TCOD_CHAR_CURRENCY = 207,
+	TCOD_CHAR_THREE_QUARTERS = 243,
+	TCOD_CHAR_DIVISION = 246,
+	TCOD_CHAR_GRADE = 248,
+	TCOD_CHAR_UMLAUT = 249,
+	TCOD_CHAR_POW1 = 251,
+	TCOD_CHAR_POW3 = 252,
+	TCOD_CHAR_POW2 = 253,
+	TCOD_CHAR_BULLET_SQUARE = 254,
+	/* diacritics */
+} TCOD_chars_t;
+
+typedef enum {
+	TCOD_COLCTRL_1 = 1,
+	TCOD_COLCTRL_2,
+	TCOD_COLCTRL_3,
+	TCOD_COLCTRL_4,
+	TCOD_COLCTRL_5,
+	TCOD_COLCTRL_NUMBER=5,
+	TCOD_COLCTRL_FORE_RGB,
+	TCOD_COLCTRL_BACK_RGB,
+	TCOD_COLCTRL_STOP
+} TCOD_colctrl_t;
+
+typedef enum {
+	TCOD_BKGND_NONE,
+	TCOD_BKGND_SET,
+	TCOD_BKGND_MULTIPLY,
+	TCOD_BKGND_LIGHTEN,
+	TCOD_BKGND_DARKEN,
+	TCOD_BKGND_SCREEN,
+	TCOD_BKGND_COLOR_DODGE,
+	TCOD_BKGND_COLOR_BURN,
+	TCOD_BKGND_ADD,
+	TCOD_BKGND_ADDA,
+	TCOD_BKGND_BURN,
+	TCOD_BKGND_OVERLAY,
+	TCOD_BKGND_ALPH,
+	TCOD_BKGND_DEFAULT
+} TCOD_bkgnd_flag_t;
+
+typedef enum {
+	TCOD_KEY_PRESSED=1,
+	TCOD_KEY_RELEASED=2,
+} TCOD_key_status_t;
+
+/* custom font flags */
+typedef enum {
+	TCOD_FONT_LAYOUT_ASCII_INCOL=1,
+	TCOD_FONT_LAYOUT_ASCII_INROW=2,
+	TCOD_FONT_TYPE_GREYSCALE=4,
+	TCOD_FONT_TYPE_GRAYSCALE=4,
+	TCOD_FONT_LAYOUT_TCOD=8,
+} TCOD_font_flags_t;
+
+typedef enum {
+	TCOD_RENDERER_GLSL,
+	TCOD_RENDERER_OPENGL,
+	TCOD_RENDERER_SDL,
+	TCOD_NB_RENDERERS,
+} TCOD_renderer_t;
+
+typedef enum {
+	TCOD_LEFT, 
+	TCOD_RIGHT, 
+	TCOD_CENTER 
+} TCOD_alignment_t;
+
+#endif /* _TCOD_CONSOLE_TYPES_H */
--- a/include/fov_types.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_FOV_TYPES_H
-#define _TCOD_FOV_TYPES_H
-
-/* FOV_BASIC : http://roguebasin.roguelikedevelopment.org/index.php?title=Ray_casting
-   FOV_DIAMOND : http://www.geocities.com/temerra/los_rays.html
-   FOV_SHADOW : http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting
-   FOV_PERMISSIVE : http://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View
-   FOV_RESTRICTIVE : Mingos' Restrictive Precise Angle Shadowcasting (contribution by Mingos) */
-
-typedef enum {
-	FOV_BASIC,
-	FOV_DIAMOND,
-	FOV_SHADOW,
-	FOV_PERMISSIVE_0,
-	FOV_PERMISSIVE_1,
-	FOV_PERMISSIVE_2,
-	FOV_PERMISSIVE_3,
-	FOV_PERMISSIVE_4,
-	FOV_PERMISSIVE_5,
-	FOV_PERMISSIVE_6,
-	FOV_PERMISSIVE_7,
-	FOV_PERMISSIVE_8,
-	FOV_RESTRICTIVE,
-	NB_FOV_ALGORITHMS } TCOD_fov_algorithm_t;
-#define FOV_PERMISSIVE(x) ((TCOD_fov_algorithm_t)(FOV_PERMISSIVE_0 + (x)))
-
-#endif /* _TCOD_FOV_TYPES_H */
--- /dev/null
+++ b/include/libtcod/fov_types.h
@@ -0,0 +1,54 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_FOV_TYPES_H
+#define _TCOD_FOV_TYPES_H
+
+/* FOV_BASIC : http://roguebasin.roguelikedevelopment.org/index.php?title=Ray_casting
+   FOV_DIAMOND : http://www.geocities.com/temerra/los_rays.html
+   FOV_SHADOW : http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting
+   FOV_PERMISSIVE : http://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View
+   FOV_RESTRICTIVE : Mingos' Restrictive Precise Angle Shadowcasting (contribution by Mingos) */
+
+typedef enum {
+	FOV_BASIC,
+	FOV_DIAMOND,
+	FOV_SHADOW,
+	FOV_PERMISSIVE_0,
+	FOV_PERMISSIVE_1,
+	FOV_PERMISSIVE_2,
+	FOV_PERMISSIVE_3,
+	FOV_PERMISSIVE_4,
+	FOV_PERMISSIVE_5,
+	FOV_PERMISSIVE_6,
+	FOV_PERMISSIVE_7,
+	FOV_PERMISSIVE_8,
+	FOV_RESTRICTIVE,
+	NB_FOV_ALGORITHMS } TCOD_fov_algorithm_t;
+#define FOV_PERMISSIVE(x) ((TCOD_fov_algorithm_t)(FOV_PERMISSIVE_0 + (x)))
+
+#endif /* _TCOD_FOV_TYPES_H */
--- a/include/bresenham.hpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_BRESENHAM_HPP
-#define _TCOD_BRESENHAM_HPP
-class TCODLIB_API TCODLineListener {
-public :
-	virtual bool putPoint(int x,int y) = 0;
-	virtual ~TCODLineListener() {}
-};
-
-class TCODLIB_API TCODLine {
-public :
-	/**
-	@PageName line
-	@PageCategory Base toolkits
-	@PageTitle Line drawing toolkit
-	@PageDesc This toolkit is a very simple and lightweight implementation of the bresenham line drawing algorithm. It allows you to follow straight paths on your map very easily.
-	@FuncTitle Initializing the line
-	@FuncDesc First, you have to initialize the toolkit with your starting and ending coordinates.
-	@Cpp static void TCODLine::init (int xFrom, int yFrom, int xTo, int yTo)
-	@C void TCOD_line_init (int xFrom, int yFrom, int xTo, int yTo)
-	@Py line_init (xFrom, yFrom, xTo, yTo)
-	@C# static void TCODLine::init(int xFrom, int yFrom, int xTo, int yTo)
-	@Lua tcod.line.init(xFrom,yFrom, xTo,yTo)
-	@Param xFrom,yFrom Coordinates of the line's starting point.
-	@Param xTo,yTo Coordinates of the line's ending point.
-	*/
-	static void init(int xFrom, int yFrom, int xTo, int yTo);
-	
-	/**
-	@PageName line
-	@FuncTitle Walking the line
-	@FuncDesc You can then step through each cell with this function. It returns true when you reach the line's ending point.
-	@Cpp static bool TCODLine::step (int * xCur, int * yCur)
-	@C bool TCOD_line_step (int * xCur, int * yCur)
-	@Py line_step () # returns x,y or None,None if finished
-	@C# static bool TCODLine::step(ref int xCur, ref int yCur)
-	@Lua tcod.line.step(x,y) -- returns lineEnd,x,y
-	@Param xCur,yCur the coordinates of the next cell on the line are stored here when the function returns
-	@CppEx 
-		// Going from point 5,8 to point 13,4
-		int x = 5, y = 8;
-		TCODLine::init(x,y,13,4);
-		do {
-		    // update cell x,y
-		} while (!TCODLine::step(&x,&y));
-	@CEx 
-		int x = 5, y = 8;
-		TCOD_line_init(x,y,13,4);
-		do {
-		    // update cell x,y 
-		} while (!TCOD_line_step(&x,&y));
-	@PyEx 
-		libtcod.line_init(5,8,13,4)
-		# update cell 5,8
-		x,y=libtcod.line_step()
-		while (not x is None) :
-		    # update cell x,y
-		x,y=libtcod.line_step()
-	@LuaEx
-		x=5
-		y=8
-		tcod.line.init(x,y,13,4)
-		repeat
-			-- update cell x,y
-			lineEnd,x,y = tcod.line.step(x,y)
-		until lineEnd		
-	*/	
-	static bool step(int *xCur, int *yCur);
-
-	/**
-	@PageName line
-	@FuncTitle Callback-based function
-	@FuncDesc The function returns false if the line has been interrupted by the callback (it returned false before the last point).
-	@Cpp
-		class TCODLIB_API TCODLineListener {
-			virtual bool putPoint (int x, int y) = 0;
-		};
-		static bool TCODLine::line (int xFrom, int yFrom, int xTo, int yTo, TCODLineListener * listener)
-	@C
-		typedef bool (*TCOD_line_listener_t) (int x, int y);
-		bool TCOD_line(int xFrom, int yFrom, int xTo, int yTo, TCOD_line_listener_t listener)
-	@Py
-		def line_listener(x,y) : # ...
-		line(xFrom, yFrom, xTo, yTo, listener)
-	@C# static bool line(int xFrom, int yFrom, int xTo, int yTo, TCODLineListener listener)
-	@Param xFrom,yFrom	Coordinates of the line's starting point.
-	@Param xTo,yTo	Coordinates of the line's ending point.
-	@Param listener	Callback called for each line's point. The function stops if the callback returns false.
-	@CppEx // Going from point 5,8 to point 13,4
-class MyLineListener : public TCODLineListener {
-    public:
-    bool putPoint (int x,int y) {
-        printf ("%d %d\n",x,y);
-        return true;
-    }
-};
-MyLineListener myListener;
-TCODLine::line(5,8,13,4,&myListener);
-	@CEx bool my_listener(int x,int y) {
-    printf ("%d %d\n",x,y);
-    return true;
-}
-TCOD_line_line(5,8,13,4,my_listener);
-	@PyEx def my_listener(x,y):
-    print x,y
-    return True
-libtcod.line_line(5,8,13,4,my_listener)	 
-	*/
-	static bool line(int xFrom, int yFrom, int xTo, int yTo, TCODLineListener *listener);
-};
-
-#endif
--- a/include/bsp.hpp
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_BSP_HPP
-#define _TCOD_BSP_HPP
-
-class TCODBsp;
-
-class TCODLIB_API ITCODBspCallback {
-public :
-	virtual ~ITCODBspCallback() {}
-	virtual bool visitNode(TCODBsp *node, void *userData) = 0;
-};
-
-/**
- @PageName bsp
- @PageCategory Roguelike toolkits
- @PageTitle BSP toolkit
- @PageDesc This toolkit allows to create and manipulate 2D Binary Space Partition trees. They can be used to split a rectangular region into non overlapping sub-regions.
- */
-
-class TCODLIB_API TCODBsp : public TCODTree {
-public :
-	int x,y,w,h; // 
-	int position; // position of splitting
-	bool horizontal; // horizontal splitting ?
-	uint8 level; // level in the tree 
-	
-	/**
-	@PageName bsp_init
-	@PageFather bsp
-	@PageTitle Creating a BSP tree
-	@FuncTitle Creating the root node
-	@FuncDesc First, you have to create the root node of the tree. This node encompasses the whole rectangular region.
-	@Cpp TCODBsp::TCODBsp(int x,int y,int w, int h)
-	@C TCOD_bsp_t *TCOD_bsp_new_with_size(int x,int y,int w, int h)
-	@Py bsp_new_with_size(x,y,w, h)
-	@C# TCODBsp::TCODBsp(int x, int y, int w, int h)
-	@Param x,y,w,h	Top left corner position and size of the rectangular region covered by the BSP tree.
-	@CppEx TCODBsp *myBSP = new TCODBsp(0,0,50,50);
-	@CEx TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
-	@PyEx my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
-	*/
-	TCODBsp() : level(0) {}
-	TCODBsp(int x,int y,int w, int h) : x(x),y(y),w(w),h(h),level(0) {}
-
-	/**
-	@PageName bsp_init
-	@FuncTitle Deleting a part of the tree
-	@FuncDesc You can delete a part of the tree, releasing resources for all sub nodes with :
-	@Cpp void TCODBsp::removeSons()
-	@C void TCOD_bsp_remove_sons(TCOD_bsp_t *node)
-	@Py bsp_remove_sons(node)
-	@C# TCODBsp::removeSons()
-	@Param node	In the C version, the node reference.
-	@CppEx 
-		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
-		// create a tree
-		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
-		// clear it (keep only the root)
-		myBSP->removeSons();
-		// and rebuild another random tree
-		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
-	@CEx 
-		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
-		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
-		TCOD_bsp_remove_sons(my_bsp);
-		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
-	@PyEx 
-		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
-		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
-		libtcod.bsp_remove_sons(my_bsp)
-		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
-	*/
-	void removeSons();
-
-	/**
-	@PageName bsp_init
-	@FuncTitle deleting the tree
-	@FuncDesc You can also completely delete the tree, including the root node to release every resource used :
-	@Cpp void TCODBsp::~TCODBsp()
-	@C void TCOD_bsp_delete(TCOD_bsp_t *node)
-	@Py bsp_delete(node)
-	@C# void TCODBsp::Dispose()
-	@Param node	In the C version, the node reference.
-	@CppEx 
-		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
-		// create a tree
-		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
-		// use the tree ...
-		// delete the tree
-		delete myBSP; 
-	@CEx 
-		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
-		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
-		// use the tree ... 
-		TCOD_bsp_delete(my_bsp);
-	@PyEx 
-		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
-		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
-		# use the tree ...
-		libtcod.bsp_delete(my_bsp)
-	*/
-	virtual ~TCODBsp();
-
-	/**
-	@PageName bsp_split
-	@PageFather bsp
-	@PageTitle Splitting the tree
-	@FuncTitle Splitting a node once
-	@FuncDesc Once you have the root node, you can split it into two smaller non-overlapping nodes.
-	@Cpp void TCODBsp::splitOnce(bool horizontal, int position)
-	@C void TCOD_bsp_split_once(TCOD_bsp_t *node, bool horizontal, int position)
-	@Py bsp_split_once(node, horizontal, position)
-	@C# void TCODBsp::splitOnce(bool horizontal, int position)
-	@Param node	In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.
-	@Param horizontal	If true, the node will be splitted horizontally, else, vertically.
-	@Param position	Coordinate of the splitting position.
-		If horizontal is true, x <= position < x+w
-		Else, y <= position < y+h
-	@CppEx 
-		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
-		myBSP->splitOnce(true,20); // horizontal split into two nodes : (0,0,50,20) and (0,20,50,30)
-	@CEx 
-		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
-		TCOD_bsp_split_once(my_bsp,false,20); // vertical split into two nodes : (0,0,20,50) and (20,0,30,50)
-	@PyEx 
-		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
-		libtcod.bsp_split_once(my_bsp,False,20) # vertical split into two nodes : (0,0,20,50) and (20,0,30,50)
-	*/
-	void splitOnce(bool horizontal, int position);
-
-	/**
-	@PageName bsp_split
-	@FuncTitle Recursively splitting a node
-	@FuncDesc You can also recursively split the bsp. At each step, a random orientation (horizontal/vertical) and position are choosen :
-	@Cpp void TCODBsp::splitRecursive(TCODRandom *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio);
-	@C void TCOD_bsp_split_recursive(TCOD_bsp_t *node, TCOD_random_t randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)
-	@Py bsp_split_recursive(node, randomizer, nb, minHSize, minVSize, maxHRatio, maxVRatio)
-	@C# void TCODBsp::splitRecursive(TCODRandom randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)
-	@Param node	In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.
-	@Param randomizer	The random number generator to use. Use NULL for the default one.
-	@Param nb	Number of recursion levels.
-	@Param minHSize, minVSize	minimum values of w and h for a node. A node is splitted only if the resulting sub-nodes are bigger than minHSize x minVSize
-	@Param maxHRatio, maxVRation	maximum values of w/h and h/w for a node. If a node does not conform, the splitting orientation is forced to reduce either the w/h or the h/w ratio. Use values near 1.0 to promote square nodes.
-	@CppEx 
-		// Do a 4 levels BSP tree (the region is splitted into a maximum of 2*2*2*2 sub-regions).
-		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
-		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
-	@CEx 
-		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
-		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
-	@PyEx 
-		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
-		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
-	*/
-	void splitRecursive(TCODRandom *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio);
-
-	/**
-	@PageName bsp_resize
-	@PageTitle Resizing a tree
-	@PageFather bsp
-	@FuncDesc This operation resets the size of the tree nodes without changing the splitting data (orientation/position). It should be called with the initial region size or a bigger size, else some splitting position may be out of the region.
-You can use it if you changed the nodes size and position while using the BSP tree, which happens typically when you use the tree to build a dungeon. You create rooms inside the tree leafs, then shrink the leaf to fit the room size. Calling resize on the root node with the original region size allows you to reset all nodes to their original size.
-	@Cpp void TCODBsp::resize(int x,int y, int w, int h)
-	@C void TCOD_bsp_resize(TCOD_bsp_t *node, int x,int y, int w, int h)
-	@Py bsp_resize(node,  x,y, w, h)
-	@C# void TCODBsp::resize(int x, int y, int w, int h)
-	@Param node	In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.
-	@Param x,y,w,h	New position and size of the node. The original rectangular area covered by the node should be included in the new one to ensure that every splitting edge stay inside its node.
-	@CppEx 
-		// We create a BSP, do some processing that will modify the x,y,w,h fields of the tree nodes, then reset all the nodes to their original size.
-		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
-		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
-		// ... do something with the tree here
-		myBSP->resize(0,0,50,50);
-	@CEx 
-		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
-		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
-		// ... do something with the tree here 
-		TCOD_bsp_resize(my_bsp,0,0,50,50);
-	@PyEx 
-		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
-		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
-		# ... do something with the tree here 
-		libtcod.bsp_resize(my_bsp,0,0,50,50)
-	*/
-	void resize(int x,int y, int w, int h);
-
-	/**
-	@PageName bsp_read
-	@PageFather bsp
-	@PageTitle Reading information from the tree
-	@FuncDesc Once you have built a BSP tree, you can retrieve information from any node. The node gives you free access to its fields :
-	@Cpp 
-		class TCODBsp {
-		public :
-			int x,y,w,h; // 
-			int position; // position of splitting
-			bool horizontal; // horizontal splitting ?
-			uint8 level; // level in the tree 
-			...
-		}
-	@C 
-		typedef struct {
-			int x,y,w,h;
-			int position;
-			bool horizontal;
-			uint8 level;
-			...
-		} TCOD_bsp_t;
-	@C# 
-		class TCODBsp
-		{
-		  public int x { get; set; }
-		  public int y { get; set; }
-		  public int h { get; set; }
-		  public int w { get; set; }
-		  public int position { get; set; }
-		  public bool horizontal { get; set; }
-		  public byte level { get; set; }
-		}
-	@Param x,y,w,h	Rectangular region covered by this node.
-	@Param position	If this node is not a leaf, splitting position.
-	@Param horizontal	If this node is not a leaf, splitting orientation.
-	@Param level	Level in the BSP tree (0 for the root, 1 for the root's sons, ...).
-	*/
-
-	/**
-	@PageName bsp_read
-	@FuncTitle Navigate in the tree
-	@FuncDesc You can navigate from a node to its sons or its parent using one of those functions. Each function returns NULL if the corresponding node does not exists (if the node is not splitted for getLeft and getRight, and if the node is the root node for getFather).
-	@Cpp 
-		TCODBsp *TCODBsp::getLeft() const
-		TCODBsp *TCODBsp::getRight() const
-		TCODBsp *TCODBsp::getFather() const
-	@C 
-		TCOD_bsp_t * TCOD_bsp_left(TCOD_bsp_t *node)
-		TCOD_bsp_t * TCOD_bsp_right(TCOD_bsp_t *node)
-		TCOD_bsp_t * TCOD_bsp_father(TCOD_bsp_t *node)
-	@Py 
-		bsp_left(node)
-		bsp_right(node)
-		bsp_father(node)
-	@C# 
-		TCODBsp TCODBsp::getLeft()
-		TCODBsp TCODBsp::getRight()
-		TCODBsp TCODBsp::getFather()
-	@Param node	In the C version, the node reference.
-	*/
-	TCODBsp *getLeft() const {
-		return (TCODBsp *)sons;
-	}
-	TCODBsp *getRight() const {
-		return sons ? (TCODBsp *)(sons->next) : NULL;
-	}
-	TCODBsp *getFather() const {
-		return (TCODBsp *)father;
-	}
-
-	/**
-	@PageName bsp_read
-	@FuncTitle Checking if a node is a leaf
-	@FuncDesc You can know if a node is a leaf (not splitted, no sons) with this function :
-	@Cpp bool TCODBsp::isLeaf() const
-	@C bool TCOD_bsp_is_leaf(TCOD_bsp_t *node)
-	@Py bsp_is_leaf(node)
-	@C# bool TCODBsp::isLeaf()
-	*/
-	bool isLeaf() const { return sons == NULL ; }
-
-	/**
-	@PageName bsp_read
-	@FuncTitle Check if a cell is inside a node
-	@FuncDesc You can check if a map cell is inside a node.
-	@Cpp bool TCODBsp::contains(int cx, int cy) const
-	@C bool TCOD_bsp_contains(TCOD_bsp_t *node, int cx, int cy)
-	@Py bsp_contains(node, cx, cy)
-	@C# bool TCODBsp::contains(int x, int y)
-	@Param node	In the C version, the node reference.
-	@Param cx,cy	Map cell coordinates.
-	*/
-	bool contains(int x, int y) const;
-
-	/**
-	@PageName bsp_read
-	@FuncTitle Getting the node containing a cell
-	@FuncDesc You can search the tree for the smallest node containing a map cell. If the cell is outside the tree, the function returns NULL :
-	@Cpp TCODBsp *TCODBsp::findNode(int cx, int cy)
-	@C TCOD_bsp_t * TCOD_bsp_find_node(TCOD_bsp_t *node, int cx, int cy)
-	@Py bsp_find_node(node, cx, cy)
-	@C# TCODBsp TCODBsp::findNode(int x, int y)
-	@Param node	In the C version, the node reference.
-	@Param cx,cy	Map cell coordinates.
-	*/
-	TCODBsp *findNode(int x, int y);
-
-	/**
-	@PageName bsp_traverse
-	@PageFather bsp
-	@PageTitle Traversing the tree
-	@FuncDesc You can scan all the nodes of the tree and have a custom function called back for each node.
-		Each traversal function returns false if the traversal has been interrupted (a callback returned false).
-		* Pre-order : the callback is called for the current node, then for the left son, then for the right son.
-		* In-order : the callback is called for the left son, then for current node, then for the right son.
-		* Post-order : the callback is called for the left son, then for the right son, then for the current node.
-		* Level-order : the callback is called for the nodes level by level, from left to right.
-		* Inverted level-order : the callback is called in the exact inverse order as Level-order.
-		<table class="param">
-		<tbody><tr><th>Pre order</th><th>In order</th><th>Post order</th><th>Level order</th><th>Inverted level<br>order</th></tr>
-		<tr><td><img src="bsp_preorder.png"></td><td><img src="bsp_inorder.png"></td><td><img src="bsp_postorder.png"></td><td><img src="bsp_levelorder.png"></td><td><img src="bsp_invlevelorder.png"></td></tr>
-		</tbody></table>
-	@Cpp 
-		class ITCODBspCallback {
-		public :
-			virtual bool visitNode(TCODBsp *node, void *userData) = 0;
-		};
-		
-		bool TCODBsp::traversePreOrder(ITCODBspCallback *callback, void *userData)
-		bool TCODBsp::traverseInOrder(ITCODBspCallback *callback, void *userData)
-		bool TCODBsp::traversePostOrder(ITCODBspCallback *callback, void *userData)
-		bool TCODBsp::traverseLevelOrder(ITCODBspCallback *callback, void *userData)
-		bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback *callback, void *userData)
-	@C 
-		typedef bool (*TCOD_bsp_callback_t)(TCOD_bsp_t *node, void *userData)
-		
-		bool TCOD_bsp_traverse_pre_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
-		bool TCOD_bsp_traverse_in_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
-		bool TCOD_bsp_traverse_post_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
-		bool TCOD_bsp_traverse_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
-		bool TCOD_bsp_traverse_inverted_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
-	@Py 
-		def bsp_callback(node, userData) : # ...
-		
-		bsp_traverse_pre_order(node, callback, userData=0)
-		bsp_traverse_in_order(node, callback, userData=0)
-		bsp_traverse_post_order(node, callback, userData=0)
-		bsp_traverse_level_order(node, callback, userData=0)
-		bsp_traverse_inverted_level_order(node, callback, userData=0)
-	@C#
-		bool TCODBsp::traversePreOrder(ITCODBspCallback callback)
-		bool TCODBsp::traverseInOrder(ITCODBspCallback callback)
-		bool TCODBsp::traversePostOrder(ITCODBspCallback callback)
-		bool TCODBsp::traverseLevelOrder(ITCODBspCallback callback)
-		bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback callback)
-	@Param node	In the C version, the node reference (generally, the root node).
-	@Param callback	The function to call for each node.
-		It receives the current node and the custom data as parameters
-		If it returns false, the traversal is interrupted.
-	@Param userData	Custom data to pass to the callback.
-	@CppEx 
-		class MyCallback : public ITCODBspCallback {
-		public :
-			bool visitNode(TCODBsp *node, void *userData) {
-				printf("node pos %dx%d size %dx%d level %d\n",node->x,node->y,node->w,node->h,node->level);
-				return true;
-			}
-		};
-		myBSP->traversePostOrder(new MyListener(),NULL);
-	@CEx 
-		bool my_callback(TCOD_bsp_t *node, void *userData) {
-			printf("node pos %dx%d size %dx%d level %d\n",node->x,node->y,node->w,node->h,node->level);
-			return true;
-		}
-		TCOD_bsp_traverse_post_order(my_bsp,my_callback,NULL);
-	@PyEx 
-		def my_callback(node, userData) :
-			print "node pos %dx%d size %dx%d level %d"%(node.x,node.y,node.w,node.h,node.level))
-			return True
-		libtcod.bsp_traverse_post_order(my_bsp,my_callback)
-	*/
-	bool traversePreOrder(ITCODBspCallback *listener, void *userData);
-	bool traverseInOrder(ITCODBspCallback *listener, void *userData);
-	bool traversePostOrder(ITCODBspCallback *listener, void *userData);
-	bool traverseLevelOrder(ITCODBspCallback *listener, void *userData);
-	bool traverseInvertedLevelOrder(ITCODBspCallback *listener, void *userData);
-protected :
-	TCODBsp(TCODBsp *father, bool left);
-
-};
-
-#endif
--- a/include/color.hpp
+++ /dev/null
@@ -1,690 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_COLOR_HPP
-#define _TCOD_COLOR_HPP
-
-// color constants uses to generate @ColorTable
-/**
-	@ColorCategory STANDARD COLORS
-	@Color red 255,0,0
-	@Color flame 255,63,0
-	@Color orange 255,127,0
-	@Color amber 255,191,0
-	@Color yellow 255,255,0,
-	@Color lime 191,255,0
-	@Color chartreuse 127,255,0
-	@Color green 0,255,0
-	@Color sea 0,255,127
-	@Color turquoise 0,255,191
-	@Color cyan 0,255,255
-	@Color sky 0,191,255
-	@Color azure 0,127,255
-	@Color blue 0,0,255
-	@Color han 63,0,255
-	@Color violet 127,0,255
-	@Color purple 191,0,255
-	@Color fuchsia 255,0,255
-	@Color magenta 255,0,191
-	@Color pink 255,0,127
-	@Color crimson 255,0,63
-	@ColorCategory METALLIC COLORS
-	@Color brass 191,151,96
-	@Color copper 196,136,124
-	@Color gold 229,191,0
-	@Color silver 203,203,203
-	@ColorCategory MISCELLANEOUS COLORS
-	@Color celadon 172,255,175
-	@Color peach 255,159,127
-	@ColorCategory GREYSCALE & SEPIA
-	@Color grey 127,127,127
-	@Color sepia 127,101,63
-	@ColorCategory BLACK AND WHITE
-	@Color black 0,0,0
-	@Color white 255,255,255
-*/
-
-/**
-	@PageName color
-	@PageCategory Core
-	@PageTitle Colors
-	@PageDesc The Doryen library uses 32bits colors. Thus, your OS desktop must use 32bits colors.
-A color is defined by its red, green and blue component between 0 and 255.
-You can use the following predefined colors (hover over a color to see its full name and R,G,B values):
-	@ColorTable
-	@CppEx 
-		TCODColor::desaturatedRed
-		TCODColor::lightestRed
-		TCODColor::lighterRed
-		TCODColor::lightRed
-		TCODColor::red
-		TCODColor::darkRed
-		TCODColor::darkerRed
-		TCODColor::darkestRed
-	@CEx 
-		TCOD_desaturated_red
-		TCOD_lightest_red
-		TCOD_lighter_red
-		TCOD_light_red
-		TCOD_red
-		TCOD_dark_red
-		TCOD_darker_red
-		TCOD_darkest_red
-	@PyEx 
-		libtcod.desaturated_red
-		libtcod.lightest_red
-		libtcod.lighter_red
-		libtcod.light_red
-		libtcod.red
-		libtcod.dark_red
-		libtcod.darker_red
-		libtcod.darkest_red
-	@C#Ex 
-		TCODColor::desaturatedRed
-		TCODColor::lightestRed
-		TCODColor::lighterRed
-		TCODColor::lightRed
-		TCODColor::red
-		TCODColor::darkRed
-		TCODColor::darkerRed
-		TCODColor::darkestRed
-	@LuaEx
-		tcod.color.desaturatedRed
-		tcod.color.lightestRed
-		tcod.color.lighterRed
-		tcod.color.lightRed
-		tcod.color.red
-		tcod.color.darkRed
-		tcod.color.darkerRed
-		tcod.color.darkestRed
- */
-
-class TCODLIB_API TCODColor {
-public :
-	uint8 r,g,b;
-
-	TCODColor() : r(0),g(0),b(0) {}
-	/**
-	@PageName color
-	@FuncTitle Create your own colors
-	@FuncDesc You can create your own colours using a set of constructors, both for RGB and HSV values.
-	@CppEx 
-		TCODColor myColor(24,64,255); //RGB
-		TCODColor myOtherColor(321.0f,0.7f,1.0f); //HSV
-	@CEx 
-		TCOD_color_t my_color={24,64,255}; <span>/</span>* RGB *<span>/</span>
-		TCOD_color_t my_other_color = TCOD_color_RGB(24,64,255); <span>/</span>* RGB too *<span>/</span>
-		TCOD_color_t my_yet_another_color = TCOD_color_HSV(321.0f,0.7f,1.0f); <span>/</span>* HSV *<span>/</span>
-	@PyEx my_color=libtcod.Color(24,64,255)
-	@C#Ex TCODColor myColor = new TCODColor(24,64,255); //RGB
-	     TCODColor myColor = new TCODColor(321.0f,0.7f,1.0f); //HSV
-	@LuaEx myColor = tcod.Color(24,24,255)
-	*/
-	TCODColor(uint8 r, uint8 g, uint8 b): r(r), g(g), b(b) {}
-	TCODColor(int r, int g, int b): r(r), g(g), b(b) {}
-	TCODColor(const TCOD_color_t &col): r(col.r), g(col.g), b(col.b) {}
-	TCODColor(float h, float s, float v);
-
-	/**
-	@PageName color
-	@FuncTitle Compare two colors
-	@CppEx 
-		if (myColor == TCODColor::yellow) { ... }
-		if (myColor != TCODColor::white) { ... }
-	@CEx 
-		if (TCOD_color_equals(my_color,TCOD_yellow)) { ... }
-		if (!TCOD_color_equals(my_color,TCOD_white)) { ... }
-	@PyEx 
-		if my_color == libtcod.yellow : ...
-		if my_color != litbcod.white : ...
-	@C#Ex 
-		if (myColor.Equal(TCODColor.yellow)) { ... }
-		if (myColor.NotEqual(TCODColor.white)) { ... }
-	@LuaEx 
-		if myColor == tcod.color.yellow then ... end
-	*/
-	bool operator == (const TCODColor & c) const {
-		return (c.r == r && c.g == g && c.b == b);
-	}
-	bool operator != (const TCODColor & c) const {
-		return (c.r != r || c.g != g || c.b != b);
-	}
-
-	/**
-	@PageName color
-	@FuncTitle Multiply two colors
-	@FuncDesc c1 = c2 * c3 =>
-    c1.r = c2.r * c3.r / 255
-    c1.g = c2.g * c3.g / 255
-    c1.b = c2.b * c3.b / 255
-	darkishRed = darkGrey * red
-<table><tr><td style="background-color: rgb(96, 0, 0); width: 60px; height: 30px;"></td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr></table>
-	@CppEx TCODColor myDarkishRed = TCODColor::darkGrey * TCODColor::lightRed;
-	@CEx TCOD_color_t my_darkish_red = TCOD_color_multiply(TCOD_dark_grey, TCOD_light_red);
-	@PyEx my_darkish_red = libtcod.dark_grey * libtcod.light_red
-	@C#Ex TCODColor myDarkishRed = TCODColor.darkGrey.Multiply(TCODColor.lightRed);
-	@LuaEx myDarkishRed = tcod.color.darkGrey * tcod.color.lightRed
-	*/
-	TCODColor operator * (const TCODColor & a) const {
-		TCODColor ret;
-		ret.r=(uint8)(((int)r)*a.r/255);
-		ret.g=(uint8)(((int)g)*a.g/255);
-		ret.b=(uint8)(((int)b)*a.b/255);
-		return ret;
-	}
-
-	/**
-	@PageName color
-	@FuncTitle Multiply a color by a float
-	@FuncDesc c1 = c2 * v =>
-    c1.r = CLAMP(0, 255, c2.r * v)
-    c1.g = CLAMP(0, 255, c2.g * v)
-    c1.b = CLAMP(0, 255, c2.b * v)
-	darkishRed = red * 0.5
-<table><tr><td style="background-color: rgb(128, 0, 0); width: 60px; height: 30px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td><td style="width: 60px;"></td></tr></table>
-</tbody>
-	@CppEx TCODColor myDarkishRed = TCODColor::lightRed * 0.5f;
-	@CEx TCOD_color_t my_darkish_red = TCOD_color_multiply_scalar(TCOD_light_red, 0.5f);
-	@PyEx myDarkishRed = litbcod.light_red * 0.5
-	@C#Ex TCODColor myDarkishRed = TCODColor.lightRed.Multiply(0.5f);
-	@LuaEx myDarkishRed = tcod.color.lightRed * 0.5
-	*/
-	TCODColor operator *(float value) const {
-		TCOD_color_t ret;
-		int r,g,b;
-		r = (int)(this->r * value);
-		g = (int)(this->g * value);
-		b = (int)(this->b * value);
-		r = CLAMP(0,255,r);
-		g = CLAMP(0,255,g);
-		b = CLAMP(0,255,b);
-		ret.r=(uint8)r;
-		ret.g=(uint8)g;
-		ret.b=(uint8)b;
-		return ret;
-	}
-
-	/**
-	@PageName color
-	@FuncTitle Adding two colors
-	@FuncDesc c1 = c1 + c2 => c1.r = MIN(255, c1.r + c2.r)
-                  c1.g = MIN(255, c1.g + c2.g)
-                  c1.b = MIN(255, c1.b + c2.b)
-	lightishRed = red + darkGrey
-<table><tr><td style="background-color: rgb(255, 128, 128); width: 60px; height: 30px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td><td style="background-color: rgb(128, 128, 128); width: 60px;"></td></tr></table>
-	@CppEx TCODColor myLightishRed = TCODColor::red + TCODColor::darkGrey
-	@CEx TCOD_color_t my_lightish_red = TCOD_color_add(TCOD_red, TCOD_dark_grey);
-	@PyEx myLightishRed = libtcod.red + libtcod.dark_grey
-	@C#Ex TCODColor myLightishRed = TCODColor.red.Plus(TCODColor.darkGrey)
-	@LuaEx myLightishRed = tcod.color.red + tcod.color.darkGrey
-	*/
-	TCODColor operator + (const TCODColor & a) const {
-		TCODColor ret;
-		int r=(int)(this->r)+a.r;
-		int g=(int)(this->g)+a.g;
-		int b=(int)(this->b)+a.b;
-		r = MIN(255,r);
-		g = MIN(255,g);
-		b = MIN(255,b);
-		ret.r=(uint8)r;
-		ret.g=(uint8)g;
-		ret.b=(uint8)b;
-		return ret;
-	}
-
-	/**
-	@PageName color
-	@FuncTitle Subtract two colors
-	@FuncDesc  c1 = c1 - c2 => c1.r = MAX(0, c1.r - c2.r)
-                  c1.g = MAX(0, c1.g - c2.g)
-                  c1.b = MAX(0, c1.b - c2.b)
-	redish = red - darkGrey
-<table><tr><td style="background-color: rgb(127, 0, 0); width: 60px; height: 30px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td><td style="background-color: rgb(128, 128, 128); width: 60px;"></td></tr></table>
-	@CppEx TCODColor myRedish = TCODColor::red - TCODColor::darkGrey
-	@CEx TCOD_color_t my_redish = TCOD_color_subtract(TCOD_red, TCOD_dark_grey);
-	@PyEx myRedish = libtcod.red - libtcod.dark_grey
-	@C#Ex TCODColor myRedish = TCODColor.red.Minus(TCODColor.darkGrey)
-	@LuaEx myRedish = tcod.color.red - tcod.color.darkGrey
-	*/
-	TCODColor operator - (const TCODColor & a) const {
-		TCODColor ret;
-		int r=(int)(this->r)-a.r;
-		int g=(int)(this->g)-a.g;
-		int b=(int)(this->b)-a.b;
-		r = MAX(0,r);
-		g = MAX(0,g);
-		b = MAX(0,b);
-		ret.r=(uint8)r;
-		ret.g=(uint8)g;
-		ret.b=(uint8)b;
-		return ret;
-	}
-
-	/**
-	@PageName color
-	@FuncTitle Interpolate between two colors
-	@FuncDesc   c1 = lerp (c2, c3, coef) => c1.r = c2.r  + (c3.r - c2.r ) * coef
-                              c1.g = c2.g  + (c3.g - c2.g ) * coef
-                              c1.b = c2.b  + (c3.b - c2.b ) * coef
-coef should be between 0.0 and 1.0 but you can as well use other values
-<table><tr><td style="background-color: rgb(96, 96, 96); color: rgb(255, 255, 255);" align="center">coef == 0.0f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
-	<tr><td style="background-color: rgb(135, 72, 72); color: rgb(255, 255, 255);" align="center">coef == 0.25f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
-	<tr><td style="background-color: rgb(175, 48, 48); color: rgb(255, 255, 255);" align="center">coef == 0.5f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
-
-	<tr><td style="background-color: rgb(215, 24, 24); color: rgb(255, 255, 255);" align="center">coef == 0.75f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
-	<tr><td style="background-color: rgb(255, 0, 0); color: rgb(255, 255, 255);" align="center">coef == 1.0f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr></table>
-	@CppEx TCODColor myColor = TCODColor::lerp ( TCODColor::darkGrey, TCODColor::lightRed,coef );
-	@CEx TCOD_color_t my_color = TCOD_color_lerp ( TCOD_dark_grey, TCOD_light_red,coef);
-	@PyEx my_color = libtcod.color_lerp ( libtcod.dark_grey, litbcod.light_red,coef)
-	@C#Ex TCODColor myColor = TCODColor.Interpolate( TCODColor.darkGrey, TCODColor.lightRed, coef );
-	@LuaEx myColor = tcod.color.Interpolate( tcod.color.darkGrey, tcod.color.lightRed, coef )
-	*/
-	static TCODColor lerp(const TCODColor &a, const TCODColor &b, float coef) {
-		TCODColor ret;
-		ret.r=(uint8)(a.r+(b.r-a.r)*coef);
-		ret.g=(uint8)(a.g+(b.g-a.g)*coef);
-		ret.b=(uint8)(a.b+(b.b-a.b)*coef);
-		return ret;
-	}
-
-	/**
-	@PageName color
-	@FuncTitle Define a color by its hue, saturation and value
-	@FuncDesc After this function is called, the r,g,b fields of the color are calculated according to the h,s,v parameters.
-	@Cpp void TCODColor::setHSV(float h, float s, float v)
-	@C void TCOD_color_set_HSV(TCOD_color_t *c,float h, float s, float v)
-	@Py color_set_hsv(c,h,s,v)
-	@C# void TCODColor::setHSV(float h, float s, float v)
-	@Lua Color:setHSV( h, s ,v )
-	@Param c In the C and python versions, the color to modify
-	@Param h,s,v Color components in the HSV space
-		0.0 <= h < 360.0
-		0.0 <= s <= 1.0
-		0.0 <= v <= 1.0
-	*/
-	void setHSV(float h, float s, float v);
-
-	/**
-	@PageName color
-	@FuncTitle Define a color's hue, saturation or lightness
-	@FuncDesc These functions set only a single component in the HSV color space.
-	@Cpp 
-		void TCODColor::setHue (float h)
-		void TCODColor::setSaturation (float s)
-		void TCODColor::setValue (float v)
-	@C 
-		void TCOD_color_set_hue (TCOD_color_t *c, float h)
-		void TCOD_color_set_saturation (TCOD_color_t *c, float s)
-		void TCOD_color_set_value (TCOD_color_t *c, float v)
-	@Lua 
-		Color:setHue(h)
-		Color:setSaturation(s)
-		Color:setValue(v)
-	@Param h,s,v	Color components in the HSV space
-	@Param c	In the C and python versions, the color to modify
-	*/
-	void setHue (float h);
-	void setSaturation (float s);
-	void setValue (float v);
-
-	/**
-	@PageName color
-	@FuncTitle Get a color hue, saturation and value components
-	@Cpp void TCODColor::getHSV(float *h, float *s, float *v) const
-	@C void TCOD_color_get_HSV(TCOD_color_t c,float * h, float * s, float * v)
-	@Py color_get_HSV(c) # returns [h,s,v]
-	@C# void TCODColor::getHSV(out float h, out float s, out float v)
-	@Lua Color:getHSV() -- returns h,s,v
-	@Param c	In the C and python versions, the TCOD_color_t from which to read.
-	@Param  h,s,v	Color components in the HSV space
-		0.0 <= h < 360.0
-		0.0 <= s <= 1.0
-		0.0 <= v <= 1.0
-	*/
-	void getHSV(float *h, float *s, float *v) const;
-
-	/**
-	@PageName color
-	@FuncTitle Get a color's hue, saturation or value
-	@FuncDesc Should you need to extract only one of the HSV components, these functions are what you should call. Note that if you need all three values, it's way less burdensome for the CPU to call TCODColor::getHSV().
-	@Cpp 
-		float TCODColor::getHue ()
-		float TCODColor::getSaturation ()
-		float TCODColor::getValue ()
-	@C 
-		float TCOD_color_get_hue (TCOD_color_t c)
-		float TCOD_color_get_saturation (TCOD_color_t c)
-		float TCOD_color_get_value (TCOD_color_t c)
-	@Lua
-		Color:getHue()
-		Color:getSaturation()
-		Color:getValue()
-	@C#
-		float TCODColor::getHue()
-		float TCODColor::getSaturation()
-		float TCODColor::getValue()
-	@Param c	the TCOD_color_t from which to read
-	*/
-	float getHue ();
-	float getSaturation ();
-	float getValue ();
-
-	/**
-	@PageName color
-	@FuncTitle Shift a color's hue up or down
-	@FuncDesc The hue shift value is the number of grades the color's hue will be shifted. The value can be negative for shift left, or positive for shift right.
-		Resulting values H < 0 and H >= 360 are handled automatically.
-	@Cpp void TCODColor::shiftHue (float hshift)
-	@C void TCOD_color_shift_hue (TCOD_color_t *c, float hshift)
-	@C# TCODColor::shiftHue(float hshift)
-	@Lua Color:shiftHue(hshift)
-	@Param c	The color to modify
-	@Param hshift	The hue shift value
-	*/
-	void shiftHue (float hshift);
-
-	/**
-	@PageName color
-	@FuncTitle Scale a color's saturation and value
-	@Cpp void TCODColor::scaleHSV (float sscale, float vscale)
-	@C void TCOD_color_scale_HSV (TCOD_color_t *c, float scoef, float vcoef)
-	@Py color_scale_HSV(c, scoef, vcoef)
-	@C# TCODColor::scaleHSV (float sscale, float vscale)
-	@Lua Color:scaleHSV(sscale,vscale)
-	@Param c	The color to modify
-	@Param sscale	saturation multiplier (1.0f for no change)
-	@Param vscale	value multiplier (1.0f for no change)
-	*/
-	void scaleHSV (float sscale, float vscale);
-
-	/**
-	@PageName color
-	@FuncTitle Generate a smooth color map
-	@FuncDesc You can define a color map from an array of color keys. Colors will be interpolated between the keys.
-	0 -> black
-	4 -> red
-	8 -> white
-	Result :
-	<table>
-	<tbody><tr><td class="code"><pre>map[0]</pre></td><td style="background-color: rgb(0, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td><td>black</td></tr>
-
-	<tr><td class="code"><pre>map[1]</pre></td><td style="background-color: rgb(63, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
-	<tr><td class="code"><pre>map[2]</pre></td><td style="background-color: rgb(127, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
-	<tr><td class="code"><pre>map[3]</pre></td><td style="background-color: rgb(191, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
-	<tr><td class="code"><pre>map[4]</pre></td><td style="background-color: rgb(255, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td><td>red</td></tr>
-	<tr><td class="code"><pre>map[5]</pre></td><td style="background-color: rgb(255, 63, 63); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
-	<tr><td class="code"><pre>map[6]</pre></td><td style="background-color: rgb(255, 127, 127); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
-
-	<tr><td class="code"><pre>map[7]</pre></td><td style="background-color: rgb(255, 191, 191); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
-	<tr><td class="code"><pre>map[8]</pre></td><td style="background-color: rgb(255, 255, 255); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td><td>white</td></tr>
-</tbody></table>
-	@Cpp static void genMap(TCODColor *map, int nbKey, TCODColor const *keyColor, int const *keyIndex)
-	@C void TCOD_gen_map(TCOD_color_t *map, int nb_key, TCOD_color_t const *key_color, int const *key_index)
-	@Py color_gen_map(keyColor,keyIndex) # returns an array of colors
-	@Param map	An array of colors to be filled by the function.
-	@Param nbKey	Number of color keys
-	@Param keyColor	Array of nbKey colors containing the color of each key
-	@Param keyIndex	Array of nbKey integers containing the index of each key.
-		If you want to fill the map array, keyIndex[0] must be 0 and keyIndex[nbKey-1] is the number of elements in map minus 1 but you can also use the function to fill only a part of the map array.
-	@CppEx 
-		int idx[] = { 0, 4, 8 }; // indexes of the keys
-		TCODColor col[] = { TCODColor( 0,0,0 ), TCODColor(255,0,0), TCODColor(255,255,255) }; // colors : black, red, white
-		TCODColor map[9];
-		TCODColor::genMap(map,3,col,idx);
-	@CEx 
-		int idx[] = { 0, 4, 8 }; // indexes of the keys
-		TCOD_color_t col[] = { { 0,0,0 }, {255,0,0}, {255,255,255} }; // colors : black, red, white
-		TCOD_color_t map[9];
-		TCOD_color_gen_map(map,3,col,idx);
-	@PyEx 
-		idx = [ 0, 4, 8 ] # indexes of the keys
-		col = [ libtcod.Color( 0,0,0 ), libtcod.Color( 255,0,0 ), libtcod.Color(255,255,255) ] # colors : black, red, white
-		map=libtcod.color_gen_map(col,idx)
-	*/
-	static void genMap(TCODColor *map, int nbKey, TCODColor const *keyColor, int const *keyIndex);
-
-	// color array
-	static const TCODColor colors[TCOD_COLOR_NB][TCOD_COLOR_LEVELS];
-
-	// grey levels
-	static const TCODColor black;
-	static const TCODColor darkestGrey;
-	static const TCODColor darkerGrey;
-	static const TCODColor darkGrey;
-	static const TCODColor grey;
-	static const TCODColor lightGrey;
-	static const TCODColor lighterGrey;
-	static const TCODColor lightestGrey;
-	static const TCODColor white;
-
-	//sepia
-	static const TCODColor darkestSepia;
-	static const TCODColor darkerSepia;
-	static const TCODColor darkSepia;
-	static const TCODColor sepia;
-	static const TCODColor lightSepia;
-	static const TCODColor lighterSepia;
-	static const TCODColor lightestSepia;
-
-	// standard colors
-	static const TCODColor red;
-  static const TCODColor flame;
-  static const TCODColor orange;
-  static const TCODColor amber;
-  static const TCODColor yellow;
-  static const TCODColor lime;
-  static const TCODColor chartreuse;
-  static const TCODColor green;
-  static const TCODColor sea;
-  static const TCODColor turquoise;
-  static const TCODColor cyan;
-  static const TCODColor sky;
-  static const TCODColor azure;
-  static const TCODColor blue;
-  static const TCODColor han;
-  static const TCODColor violet;
-  static const TCODColor purple;
-  static const TCODColor fuchsia;
-  static const TCODColor magenta;
-  static const TCODColor pink;
-  static const TCODColor crimson;
-
-	// dark colors
-	static const TCODColor darkRed;
-  static const TCODColor darkFlame;
-  static const TCODColor darkOrange;
-  static const TCODColor darkAmber;
-  static const TCODColor darkYellow;
-  static const TCODColor darkLime;
-  static const TCODColor darkChartreuse;
-  static const TCODColor darkGreen;
-  static const TCODColor darkSea;
-  static const TCODColor darkTurquoise;
-  static const TCODColor darkCyan;
-  static const TCODColor darkSky;
-  static const TCODColor darkAzure;
-  static const TCODColor darkBlue;
-  static const TCODColor darkHan;
-  static const TCODColor darkViolet;
-  static const TCODColor darkPurple;
-  static const TCODColor darkFuchsia;
-  static const TCODColor darkMagenta;
-  static const TCODColor darkPink;
-  static const TCODColor darkCrimson;
-
-	// darker colors
-	static const TCODColor darkerRed;
-  static const TCODColor darkerFlame;
-  static const TCODColor darkerOrange;
-  static const TCODColor darkerAmber;
-  static const TCODColor darkerYellow;
-  static const TCODColor darkerLime;
-  static const TCODColor darkerChartreuse;
-  static const TCODColor darkerGreen;
-  static const TCODColor darkerSea;
-  static const TCODColor darkerTurquoise;
-  static const TCODColor darkerCyan;
-  static const TCODColor darkerSky;
-  static const TCODColor darkerAzure;
-  static const TCODColor darkerBlue;
-  static const TCODColor darkerHan;
-  static const TCODColor darkerViolet;
-  static const TCODColor darkerPurple;
-  static const TCODColor darkerFuchsia;
-  static const TCODColor darkerMagenta;
-  static const TCODColor darkerPink;
-  static const TCODColor darkerCrimson;
-
-  // darkest colors
-  static const TCODColor darkestRed;
-  static const TCODColor darkestFlame;
-  static const TCODColor darkestOrange;
-  static const TCODColor darkestAmber;
-  static const TCODColor darkestYellow;
-  static const TCODColor darkestLime;
-  static const TCODColor darkestChartreuse;
-  static const TCODColor darkestGreen;
-  static const TCODColor darkestSea;
-  static const TCODColor darkestTurquoise;
-  static const TCODColor darkestCyan;
-  static const TCODColor darkestSky;
-  static const TCODColor darkestAzure;
-  static const TCODColor darkestBlue;
-  static const TCODColor darkestHan;
-  static const TCODColor darkestViolet;
-  static const TCODColor darkestPurple;
-  static const TCODColor darkestFuchsia;
-  static const TCODColor darkestMagenta;
-  static const TCODColor darkestPink;
-  static const TCODColor darkestCrimson;
-
-	// light colors
-	static const TCODColor lightRed;
-  static const TCODColor lightFlame;
-  static const TCODColor lightOrange;
-  static const TCODColor lightAmber;
-  static const TCODColor lightYellow;
-  static const TCODColor lightLime;
-  static const TCODColor lightChartreuse;
-  static const TCODColor lightGreen;
-  static const TCODColor lightSea;
-  static const TCODColor lightTurquoise;
-  static const TCODColor lightCyan;
-  static const TCODColor lightSky;
-  static const TCODColor lightAzure;
-  static const TCODColor lightBlue;
-  static const TCODColor lightHan;
-  static const TCODColor lightViolet;
-  static const TCODColor lightPurple;
-  static const TCODColor lightFuchsia;
-  static const TCODColor lightMagenta;
-  static const TCODColor lightPink;
-  static const TCODColor lightCrimson;
-
-  //lighter colors
-  static const TCODColor lighterRed;
-  static const TCODColor lighterFlame;
-  static const TCODColor lighterOrange;
-  static const TCODColor lighterAmber;
-  static const TCODColor lighterYellow;
-  static const TCODColor lighterLime;
-  static const TCODColor lighterChartreuse;
-  static const TCODColor lighterGreen;
-  static const TCODColor lighterSea;
-  static const TCODColor lighterTurquoise;
-  static const TCODColor lighterCyan;
-  static const TCODColor lighterSky;
-  static const TCODColor lighterAzure;
-  static const TCODColor lighterBlue;
-  static const TCODColor lighterHan;
-  static const TCODColor lighterViolet;
-  static const TCODColor lighterPurple;
-  static const TCODColor lighterFuchsia;
-  static const TCODColor lighterMagenta;
-  static const TCODColor lighterPink;
-  static const TCODColor lighterCrimson;
-
-  // lightest colors
-  static const TCODColor lightestRed;
-  static const TCODColor lightestFlame;
-  static const TCODColor lightestOrange;
-  static const TCODColor lightestAmber;
-  static const TCODColor lightestYellow;
-  static const TCODColor lightestLime;
-  static const TCODColor lightestChartreuse;
-  static const TCODColor lightestGreen;
-  static const TCODColor lightestSea;
-  static const TCODColor lightestTurquoise;
-  static const TCODColor lightestCyan;
-  static const TCODColor lightestSky;
-  static const TCODColor lightestAzure;
-  static const TCODColor lightestBlue;
-  static const TCODColor lightestHan;
-  static const TCODColor lightestViolet;
-  static const TCODColor lightestPurple;
-  static const TCODColor lightestFuchsia;
-  static const TCODColor lightestMagenta;
-  static const TCODColor lightestPink;
-  static const TCODColor lightestCrimson;
-
-	// desaturated colors
-  static const TCODColor desaturatedRed;
-  static const TCODColor desaturatedFlame;
-  static const TCODColor desaturatedOrange;
-  static const TCODColor desaturatedAmber;
-  static const TCODColor desaturatedYellow;
-  static const TCODColor desaturatedLime;
-  static const TCODColor desaturatedChartreuse;
-  static const TCODColor desaturatedGreen;
-  static const TCODColor desaturatedSea;
-  static const TCODColor desaturatedTurquoise;
-  static const TCODColor desaturatedCyan;
-  static const TCODColor desaturatedSky;
-  static const TCODColor desaturatedAzure;
-  static const TCODColor desaturatedBlue;
-  static const TCODColor desaturatedHan;
-  static const TCODColor desaturatedViolet;
-  static const TCODColor desaturatedPurple;
-  static const TCODColor desaturatedFuchsia;
-  static const TCODColor desaturatedMagenta;
-  static const TCODColor desaturatedPink;
-  static const TCODColor desaturatedCrimson;
-
-	// metallic
-	static const TCODColor brass;
-	static const TCODColor copper;
-	static const TCODColor gold;
-	static const TCODColor silver;
-
-	// miscellaneous
-	static const TCODColor celadon;
-	static const TCODColor peach;
-};
-
-TCODLIB_API TCODColor operator *(float value, const TCODColor &c);
-
-#endif
--- a/include/console.hpp
+++ /dev/null
@@ -1,1759 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_CONSOLE_HPP
-#define _TCOD_CONSOLE_HPP
-
-#include "console_types.h"
-
-/**
-	@PageName console
-	@PageCategory Core
-	@PageTitle Console
-	@PageDesc The console emulator handles the rendering of the game screen and the keyboard input.
-Classic real time game loop:
-	@Cpp
-		TCODConsole::initRoot(80,50,"my game",false);
-		TCODSystem::setFps(25); // limit framerate to 25 frames per second
-		while (!endGame && !TCODConsole::isWindowClosed()) {
-			// ... draw on TCODConsole::root
-			TCODConsole::flush();
-			TCOD_key_t key = TCODConsole::checkForKeypress();
-			updateWorld (key, TCODSystem::getLastFrameLength());
-			// updateWorld(TCOD_key_t key, float elapsed) (using key if key.vk != TCODK_NONE)
-			// use elapsed to scale any update that is time dependant.
-		}
-	@Lua
-		tcod.console.initRoot(80,50,"my game", false)
-		root=libtcod.TCODConsole_root
-		tcod.system.setFps(25)
-		while not tcod.console.isWindowClosed() do
-			-- ... draw on root
-			tcod.console.flush()
-			key=tcod.console.checkForKeypress()
-			-- ... update world, using key and tcod.system.getLastFrameLength
-		end
-
-*/
-/**
-	@PageName console
-	@FuncDesc Classic turn by turn game loop:
-	@Cpp
-		TCODConsole::initRoot(80,50,"my game",false);
-		while (!endGame && !TCODConsole::isWindowClosed()) {
-			// ... draw on TCODConsole::root
-			TCODConsole::flush();
-			TCOD_key_t key = TCODConsole::waitForKeypress(true);
-			//... update world, using key
-		}
-*/
-
-class TCODLIB_API TCODConsole {
-public :
-	/**
-	@PageName console_init
-	@PageTitle Initializing the console
-	@PageFather console
-	*/
-
-	static TCODConsole *root;
-
-	/**
-	@PageName console_init_root
-	@PageTitle Creating the game window
-	@PageFather console_init
-	@Cpp static void TCODConsole::initRoot (int w, int h, const char * title, bool fullscreen = false, TCOD_renderer_t renderer = TCOD_RENDERER_SDL)
-	@C void TCOD_console_init_root (int w, int h, const char * title, bool fullscreen, TCOD_renderer_t renderer)
-	@Py console_init_root (w, h, title, fullscreen = False, renderer = RENDERER_SDL)
-	@C#
-		static void TCODConsole::initRoot(int w, int h, string title)
-		static void TCODConsole::initRoot(int w, int h, string title, bool fullscreen)
-		static void TCODConsole::initRoot(int w, int h, string title, bool fullscreen, TCODRendererType renderer)
-	@Lua
-		tcod.console.initRoot(w,h,title) -- fullscreen = false, renderer = SDL
-		tcod.console.initRoot(w,h,title,fullscreen) -- renderer = SDL
-		tcod.console.initRoot(w,h,title,fullscreen,renderer)
-		-- renderers : tcod.GLSL, tcod.OpenGL, tcod.SDL
-	@Param w,h size of the console(in characters). The default font in libtcod (./terminal.png) uses 8x8 pixels characters.
-		You can change the font by calling TCODConsole::setCustomFont before calling initRoot.
-	@Param title title of the window. It's not visible when you are in fullscreen.
-		Note 1 : you can dynamically change the window title with TCODConsole::setWindowTitle
-	@Param fullscreen wether you start in windowed or fullscreen mode.
-		Note 1 : you can dynamically change this mode with TCODConsole::setFullscreen
-		Note 2 : you can get current mode with TCODConsole::isFullscreen
-	@Param renderer which renderer to use. Possible values are :
-    * TCOD_RENDERER_GLSL : works only on video cards with pixel shaders
-    * TCOD_RENDERER_OPENGL : works on all video cards supporting OpenGL 1.4
-    * TCOD_RENDERER_SDL : should work everywhere!
-		Note 1: if you select a renderer that is not supported by the player's machine, libtcod scan the lower renderers until it finds a working one.
-		Note 2: on recent video cards, GLSL results in up to 900% increase of framerates in the true color sample compared to SDL renderer.
-		Note 3: whatever renderer you use, it can always be overriden by the player through the libtcod.cfg file.
-		Note 4: you can dynamically change the renderer after calling initRoot with TCODSystem::setRenderer.
-		Note 5: you can get current renderer with TCODSystem::getRenderer. It might be different from the one you set in initRoot in case it's not supported on the player's computer.
-	@CppEx TCODConsole::initRoot(80, 50, "The Chronicles Of Doryen v0.1");
-	@CEx TCOD_console_init_root(80, 50, "The Chronicles Of Doryen v0.1", false, TCOD_RENDERER_OPENGL);
-	@PyEx libtcod.console_init_root(80, 50, 'The Chronicles Of Doryen v0.1')
-	@LuaEx tcod.console.initRoot(80,50,"The Chronicles Of Doryen v0.1")
-	*/
-	static void initRoot(int w, int h, const char * title, bool fullscreen = false, TCOD_renderer_t renderer=TCOD_RENDERER_SDL);
-
-	/**
-	@PageName console_set_custom_font
-	@PageTitle Using a custom bitmap font
-	@PageFather console_init
-	@FuncTitle setCustomFont
-	@FuncDesc This function allows you to use a bitmap font (png or bmp) with custom character size or layout.
-		It should be called before initializing the root console with initRoot.
-		Once this function is called, you can define your own custom mappings using mapping functions
-		<h5>Different font layouts</h5>
-		<table>
-		<tr><td>ASCII_INROW</td><td>ASCII_INCOL</td><td>TCOD</td></tr>
-
-		<tr><td><img src='terminal8x8_gs_ro.png' /></td><td><img src='terminal8x8_gs_as.png' /></td><td><img src='terminal8x8_gs_tc.png' /></td></tr>
-		</table>
-		<ul>
-		<li>ascii, in columns : characters 0 to 15 are in the first column. The space character is at coordinates 2,0.</li>
-		<li>ascii, in rows : characters 0 to 15 are in the first row. The space character is at coordinates 0,2.</li>
-		<li>tcod : special mapping. Not all ascii values are mapped. The space character is at coordinates 0,0.</li>
-		</ul>
-		<h5>Different font types</h5>
-		<table>
-		<tr><td>standard<br />(non antialiased)</td><td>antialiased<br />(32 bits PNG)</td><td>antialiased<br />(greyscale)</td></tr>
-
-		<tr><td><img src='terminal.png' /></td><td><img src='terminal8x8_aa_as.png' /></td><td><img src='terminal8x8_gs_as2.png' /></td></tr>
-		</table>
-		<ul>
-		<li>standard : transparency is given by a key color automatically detected by looking at the color of the space character</li>
-		<li>32 bits : transparency is given by the png alpha layer. The font color does not matter but it must be desaturated</li>
-		<li>greyscale : transparency is given by the pixel value. You can use white characters on black background or black characters on white background. The background color is automatically detected by looking at the color of the space character</li>
-		</ul>
-		Examples of fonts can be found in libtcod's fonts directory. Check the Readme file there.
-	@Cpp static void TCODConsole::setCustomFont(const char *fontFile, int flags=TCOD_FONT_LAYOUT_ASCII_INCOL,int nbCharHoriz=0, int nbCharVertic=0)
-	@C void TCOD_console_set_custom_font(const char *fontFile, int flags,int nb_char_horiz, int nb_char_vertic)
-	@Py console_set_custom_font(fontFile, flags=FONT_LAYOUT_ASCII_INCOL,nb_char_horiz=0, nb_char_vertic=0)
-	@C#
-		static void TCODConsole::setCustomFont(string fontFile)
-		static void TCODConsole::setCustomFont(string fontFile, int flags)
-		static void TCODConsole::setCustomFont(string fontFile, int flags, int nbCharHoriz)
-		static void TCODConsole::setCustomFont(string fontFile, int flags, int nbCharHoriz, int nbCharVertic)
-	@Lua
-		tcod.console.setCustomFont(fontFile)
-		tcod.console.setCustomFont(fontFile, flags)
-		tcod.console.setCustomFont(fontFile, nbCharHoriz)
-		tcod.console.setCustomFont(fontFile, flags, nbCharHoriz, nbCharVertic)
-		-- flags : tcod.LayoutAsciiInColumn, tcod.LayoutAsciiInRow, tcod.LayoutTCOD, tcod.Greyscale
-	@Param fontFile Name of a .bmp or .png file containing the font.
-	@Param flags Used to define the characters layout in the bitmap and the font type :
-		TCOD_FONT_LAYOUT_ASCII_INCOL : characters in ASCII order, code 0-15 in the first column
-		TCOD_FONT_LAYOUT_ASCII_INROW : characters in ASCII order, code 0-15 in the first row
-		TCOD_FONT_LAYOUT_TCOD : simplified layout. See examples below.
-		TCOD_FONT_TYPE_GREYSCALE : create an anti-aliased font from a greyscale bitmap
-		For python, remove TCOD _ :
-		libtcod.FONT_LAYOUT_ASCII_INCOL
-	@Param nbCharHoriz,nbCharVertic Number of characters in the font.
-		Should be 16x16 for ASCII layouts, 32x8 for TCOD layout.
-		But you can use any other layout.
-		If set to 0, there are deduced from the font layout flag.
-	@CppEx
-		TCODConsole::setCustomFont("standard_8x8_ascii_in_col_font.bmp",TCOD_FONT_LAYOUT_ASCII_INCOL);
-		TCODConsole::setCustomFont("32bits_8x8_ascii_in_row_font.png",TCOD_FONT_LAYOUT_ASCII_INROW);
-		TCODConsole::setCustomFont("greyscale_8x8_tcod_font.png",TCOD_FONT_LAYOUT_TCOD | TCOD_FONT_TYPE_GREYSCALE);
-	@CEx
-		TCOD_console_set_custom_font("standard_8x8_ascii_in_col_font.bmp",TCOD_FONT_LAYOUT_ASCII_INCOL,16,16);
-		TCOD_console_set_custom_font("32bits_8x8_ascii_in_row_font.png",TCOD_FONT_LAYOUT_ASCII_INROW,32,8);
-		TCOD_console_set_custom_font("greyscale_8x8_tcod_font.png",TCOD_FONT_LAYOUT_TCOD | TCOD_FONT_TYPE_GREYSCALE,32,8);
-	@PyEx
-		libtcod.console_set_custom_font("standard_8x8_ascii_in_col_font.bmp",libtcod.FONT_LAYOUT_ASCII_INCOL)
-		libtcod.console_set_custom_font("32bits_8x8_ascii_in_row_font.png",libtcod.FONT_LAYOUT_ASCII_INROW)
-		libtcod.console_set_custom_font("greyscale_8x8_tcod_font.png",libtcod.FONT_LAYOUT_TCOD | libtcod.FONT_TYPE_GREYSCALE)
-	@LuaEx
-		tcod.console.setCustomFont("standard_8x8_ascii_in_col_font.bmp",tcod.LayoutAsciiInColumn);
-		tcod.console.setCustomFont("32bits_8x8_ascii_in_row_font.png",tcod.LayoutAsciiInRow);
-		tcod.console.setCustomFont("greyscale_8x8_tcod_font.png",tcod.LayoutTCOD + tcod.Greyscale);
-	*/
-	static void setCustomFont(const char *fontFile, int flags=TCOD_FONT_LAYOUT_ASCII_INCOL,int nbCharHoriz=0, int nbCharVertic=0);
-
-	/**
-	@PageName console_map
-	@PageTitle Using custom characters mapping
-	@PageFather console_init
-	@FuncTitle Mapping a single ASCII code to a character
-	@PageDesc These functions allow you to map characters in the bitmap font to ASCII codes.
-		They should be called after initializing the root console with initRoot.
-		You can dynamically change the characters mapping at any time, allowing to use several fonts in the same screen.
-	@Cpp static void TCODConsole::mapAsciiCodeToFont(int asciiCode, int fontCharX, int fontCharY)
-	@C void TCOD_console_map_ascii_code_to_font(int asciiCode, int fontCharX, int fontCharY)
-	@Py console_map_ascii_code_to_font(asciiCode, fontCharX, fontCharY)
-	@C# static void TCODConsole::mapAsciiCodeToFont(int asciiCode, int fontCharX, int fontCharY)
-	@Lua tcod.console.mapAsciiCodeToFont(asciiCode, fontCharX, fontCharY)
-	@Param asciiCode ASCII code to map.
-	@Param fontCharX,fontCharY Coordinate of the character in the bitmap font (in characters, not pixels).
-	*/
-	static void mapAsciiCodeToFont(int asciiCode, int fontCharX, int fontCharY);
-
-	/**
-	@PageName console_map
-	@FuncTitle Mapping consecutive ASCII codes to consecutive characters
-	@Cpp static void TCODConsole::mapAsciiCodesToFont(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY)
-	@C void TCOD_console_map_ascii_codes_to_font(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY)
-	@Py console_map_ascii_codes_to_font(firstAsciiCode, nbCodes, fontCharX, fontCharY)
-	@C# static void TCODConsole::mapAsciiCodesToFont(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY)
-	@Lua tcod.console.mapAsciiCodesToFont(firstAsciiCode, nbCodes, fontCharX, fontCharY)
-	@Param firstAsciiCode first ASCII code to map
-	@Param nbCodes number of consecutive ASCII codes to map
-	@Param fontCharX,fontCharY coordinate of the character in the bitmap font (in characters, not pixels) corresponding to the first ASCII code
-	*/
-	static void mapAsciiCodesToFont(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY);
-
-	/**
-	@PageName console_map
-	@FuncTitle Mapping ASCII code from a string to consecutive characters
-	@Cpp static void TCODConsole::mapStringToFont(const char *s, int fontCharX, int fontCharY)
-	@C void TCOD_console_map_string_to_font(const char *s, int fontCharX, int fontCharY)
-	@Py console_map_string_to_font(s, fontCharX, fontCharY)
-	@C# static void TCODConsole::mapStringToFont(string s, int fontCharX, int fontCharY)
-	@Lua tcod.console.mapStringToFont(s, fontCharX, fontCharY)
-	@Param s string containing the ASCII codes to map
-	@Param fontCharX,fontCharY coordinate of the character in the bitmap font (in characters, not pixels) corresponding to the first ASCII code in the string
-	*/
-	static void mapStringToFont(const char *s, int fontCharX, int fontCharY);
-
-	/**
-	@PageName console_fullscreen
-	@PageTitle Fullscreen mode
-	@PageFather console_init
-	@FuncTitle Getting the current mode
-	@FuncDesc This function returns true if the current mode is fullscreen.
-	@Cpp static bool TCODConsole::isFullscreen()
-	@C bool TCOD_console_is_fullscreen()
-	@Py console_is_fullscreen()
-	@C# static bool TCODConsole::isFullscreen()
-	@Lua tcod.console.isFullscreen()
-	*/
-	static bool isFullscreen();
-	/**
-	@PageName console_fullscreen
-	@FuncTitle Switching between windowed and fullscreen modes
-	@FuncDesc This function switches the root console to fullscreen or windowed mode.
-		Note that there is no predefined key combination to switch to/from fullscreen. You have to do this in your own code.
-	@Cpp static void TCODConsole::setFullscreen(bool fullscreen)
-	@C void TCOD_console_set_fullscreen(bool fullscreen)
-	@Py console_set_fullscreen(fullscreen)
-	@C# static void TCODConsole::setFullscreen(bool fullscreen)
-	@Lua tcod.console.setFullscreen(fullscreen)
-	@Param fullscreen true to switch to fullscreen mode.
-		false to switch to windowed mode.
-	@CppEx
-		TCOD_key_t key=TCODConsole::checkForKeypress();
-		if ( key.vk == TCODK_ENTER && key.lalt )
-			TCODConsole::setFullscreen(!TCODConsole::isFullscreen());
-	@CEx
-		TCOD_key_t key=TCOD_console_check_for_keypress();
-		if ( key.vk == TCODK_ENTER && key.lalt )
-			TCOD_console_set_fullscreen(!TCOD_console_is_fullscreen());
-	@PyEx
-		key=libtcod.console_check_for_keypress()
-		if key.vk == libtcod.KEY_ENTER and key.lalt :
-			libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())
-	@LuaEx
-		key=tcod.console.checkForKeypress()
-		if key.KeyCode == tcod.Enter and key.LeftAlt then
-			tcod.console.setFullscreen(not tcod.console.isFullscreen())
-		end
-	*/
-	static void setFullscreen(bool fullscreen);
-
-	/**
-	@PageName console_window
-	@PageFather console_init
-	@PageTitle Communicate with the window manager
-	@FuncTitle Changing the window title
-	@FuncDesc This function dynamically changes the title of the game window.
-		Note that the window title is not visible while in fullscreen.
-	@Cpp static void TCODConsole::setWindowTitle(const char *title)
- 	@C void TCOD_console_set_window_title(const char *title)
-	@Py console_set_window_title(title)
-	@C# static void TCODConsole::setWindowTitle(string title)
-	@Lua tcod.console.setWindowTitle(title)
-	@Param title New title of the game window
-	*/
-	static void setWindowTitle(const char *title);
-
-	/**
-	@PageName console_window
-	@FuncTitle Handling "close window" events
-	@FuncDesc When you start the program, this returns false. Once a "close window" event has been sent by the window manager, it will allways return true. You're supposed to exit cleanly the game.
-	@Cpp static bool TCODConsole::isWindowClosed()
-	@C bool TCOD_console_is_window_closed()
-	@Py console_is_window_closed()
-	@C# static bool TCODConsole::isWindowClosed()
-	@Lua tcod.console.isWindowClosed()
-	*/
-	static bool isWindowClosed();
-
-	/**
-	@PageName console_credits
-	@PageTitle libtcod's credits
-	@PageFather console_init
-	@PageDesc Use these functions to display credits, as seen in the samples.
-	@FuncTitle Using a separate credit page
-	@FuncDesc You can print a "Powered by libtcod x.y.z" screen during your game startup simply by calling this function after initRoot.
-		The credits screen can be skipped by pressing any key.
-	@Cpp static void TCODConsole::credits()
-	@C void TCOD_console_credits()
-	@Py console_credits()
-	@C# static void TCODConsole::credits()
-	@Lua tcod.console.credits()
-	*/
-	static void credits();
-
-	/**
-	@PageName console_credits
-	@FuncTitle Embedding credits in an existing page
-	@FuncDesc You can also print the credits on one of your game screens (your main menu for example) by calling this function in your main loop.
-		This function returns true when the credits screen is finished, indicating that you no longer need to call it.
-	@Cpp static bool TCODConsole::renderCredits(int x, int y, bool alpha)
-	@C bool TCOD_console_credits_render(int x, int y, bool alpha)
-	@Py bool TCOD_console_credits_render(int x, int y, bool alpha)
-	@C# static bool TCODConsole::renderCredits(int x, int y, bool alpha)
-	@Lua tcod.console.renderCredits(x, y, alpha)
-	@Param x,y Position of the credits text in your root console
-	@Param alpha If true, credits are transparently added on top of the existing screen.
-		For this to work, this function must be placed between your screen rendering code and the console flush.
-	@CppEx
-      TCODConsole::initRoot(80,50,"The Chronicles Of Doryen v0.1",false); // initialize the root console
-      bool endCredits=false;
-      while ( ! TCODConsole::isWindowClosed() ) { // your game loop
-          // your game rendering here...
-          // render transparent credits near the center of the screen
-          if (! endCredits ) endCredits=TCODConsole::renderCredits(35,25,true);
-          TCODConsole::flush();
-      }
-	@CEx
-      TCOD_console_init_root(80,50,"The Chronicles Of Doryen v0.1",false);
-      bool end_credits=false;
-      while ( ! TCOD_console_is_window_closed() ) {
-          // your game rendering here...
-          // render transparent credits near the center of the screen
-          if (! end_credits ) end_credits=TCOD_console_credits_render(35,25,true);
-          TCOD_console_flush();
-      }
-	@PyEx
-      libtcod.console_init_root(80,50,"The Chronicles Of Doryen v0.1",False)
-      end_credits=False
-      while not libtcod.console_is_window_closed() :
-          // your game rendering here...
-          // render transparent credits near the center of the screen
-          if (not end_credits )  : end_credits=libtcod.console_credits_render(35,25,True)
-          libtcod.console_flush()
-	@LuaEx
-		tcod.console.initRoot(80,50,"The Chronicles Of Doryen v0.1") -- initialize the root console
-		endCredits=false
-		while not tcod.console.isWindowClosed() do -- your game loop
-			-- your game rendering here...
-			-- render transparent credits near the center of the screen
-			if not endCredits then endCredits=tcod.console.renderCredits(35,25,true) end
-			tcod.console.flush()
-		end
-	*/
-	static bool renderCredits(int x, int y, bool alpha);
-
-	/**
-	@PageName console_credits
-	@FuncTitle Restart the credits animation
-	@FuncDesc When using rederCredits, you can restart the credits animation from the begining before it's finished by calling this function.
-	@Cpp static void TCODConsole::resetCredits()
-	@C void TCOD_console_credits_reset()
-	@Py console_credits_reset()
-	@C# static void TCODConsole::resetCredits()
-	@Lua tcod.console.resetCredits()
-	*/
-	static void resetCredits();
-
-	/**
-	@PageName console_draw
-	@PageTitle Drawing on the root console
-	@PageFather console
-	*/
-
-	/**
-	@PageName console_draw_basic
-	@PageTitle Basic printing functions
-	@PageFather console_draw
-	@FuncTitle Setting the default background color
-	@FuncDesc This function changes the default background color for a console. The default background color is used by several drawing functions like clear, putChar, ...
-	@Cpp void TCODConsole::setDefaultBackground(TCODColor back)
-	@C void TCOD_console_set_default_background(TCOD_console_t con,TCOD_color_t back)
-	@Py console_set_default_background(con,back)
-	@C# void TCODConsole::setBackgroundColor(TCODColor back)
-	@Lua Console:setBackgroundColor(back)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param back the new default background color for this console
-	@CppEx TCODConsole::root->setDefaultBackground(myColor)
-	@CEx TCOD_console_set_default_background(NULL, my_color)
-	@PyEx litbcod.console_set_default_background(0, my_color)
-	@Lua libtcod.TCODConsole_root:setBackgroundColor( myColor )
-	*/
-	void setDefaultBackground(TCODColor back);
-
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Setting the default foreground color
-	@FuncDesc This function changes the default foreground color for a console. The default foreground color is used by several drawing functions like clear, putChar, ...
-	@Cpp void TCODConsole::setDefaultForeground(TCODColor fore)
-	@C void TCOD_console_set_default_foreground(TCOD_console_t con,TCOD_color_t fore)
-	@Py console_set_default_foreground(con, fore)
-	@C# void TCODConsole::setForegroundColor(TCODColor fore)
-	@Lua Console:setForegroundColor(fore)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param fore the new default foreground color for this console
-	@CppEx TCODConsole::root->setDefaultForeground(myColor)
-	@CEx TCOD_console_set_default_foreground(NULL, my_color)
-	@PyEx litbcod.console_set_default_foreground(0, my_color)
-	@LuaEx libtcod.TCODConsole_root:setForegroundColor( myColor )
-	*/
-	void setDefaultForeground(TCODColor fore);
-
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Clearing a console
-	@FuncDesc This function modifies all cells of a console :
-		* set the cell's background color to the console default background color
-		* set the cell's foreground color to the console default foreground color
-		* set the cell's ASCII code to 32 (space)
-	@Cpp void TCODConsole::clear()
-	@C void TCOD_console_clear(TCOD_console_t con)
-	@Py console_clear(con)
-	@C# void TCODConsole::clear()
-	@Lua Console:clear()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	void clear();
-
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Setting the background color of a cell
-	@FuncDesc This function modifies the background color of a cell, leaving other properties (foreground color and ASCII code) unchanged.
-	@Cpp void TCODConsole::setCharBackground(int x, int y, const TCODColor &col, TCOD_bkgnd_flag_t flag = TCOD_BKGND_SET)
-	@C void TCOD_console_set_char_background(TCOD_console_t con,int x, int y, TCOD_color_t col, TCOD_bkgnd_flag_t flag)
-	@Py console_set_char_background(con, x,  y, col, flag=BKGND_SET)
-	@C#
-		void TCODConsole::setCharBackground(int x, int y, TCODColor col)
-		void TCODConsole::setCharBackground(int x, int y, TCODColor col, TCODBackgroundFlag flag)
-	@Lua
-		Console:setCharBackground(x, y, col)
-		Console:setCharBackground(x, y, col, flag)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param col the background color to use. You can use color constants
-	@Param flag this flag defines how the cell's background color is modified. See <a href="console_bkgnd_flag_t.html">TCOD_bkgnd_flag_t</a>
-	*/
-	void setCharBackground(int x, int y, const TCODColor &col, TCOD_bkgnd_flag_t flag = TCOD_BKGND_SET);
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Setting the foreground color of a cell
-	@FuncDesc This function modifies the foreground color of a cell, leaving other properties (background color and ASCII code) unchanged.
-	@Cpp void TCODConsole::setCharForeground(int x, int y, const TCODColor &col)
-	@C void TCOD_console_set_char_foreground(TCOD_console_t con,int x, int y, TCOD_color_t col)
-	@Py console_set_char_foreground(con, x, y, col)
-	@C# void TCODConsole::setCharForeground(int x, int y, TCODColor col)
-	@Lua Console:setCharForeground(x, y, col)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param col the foreground color to use. You can use color constants
-	*/
-	void setCharForeground(int x, int y, const TCODColor &col);
-
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Setting the ASCII code of a cell
-	@FuncDesc This function modifies the ASCII code of a cell, leaving other properties (background and foreground colors) unchanged.
-		Note that since a clear console has both background and foreground colors set to black for every cell, using setchar will produce black characters on black background. Use putchar instead.
-	@Cpp void TCODConsole::setChar(int x, int y, int c)
-	@C void TCOD_console_set_char(TCOD_console_t con,int x, int y, int c)
-	@Py console_set_char(con, x,  y, c)
-	@C# void TCODConsole::setChar(int x, int y, int c)
-	@Lua Console:setChar(x, y, c)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param c the new ASCII code for the cell. You can use ASCII constants
-	*/
-	void setChar(int x, int y, int c);
-
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Setting every property of a cell using default colors
-	@FuncDesc This function modifies every property of a cell :
-		* update the cell's background color according to the console default background color (see TCOD_bkgnd_flag_t).
-		* set the cell's foreground color to the console default foreground color
-		* set the cell's ASCII code to c
-	@Cpp void TCODConsole::putChar(int x, int y, int c, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
-	@C void TCOD_console_put_char(TCOD_console_t con,int x, int y, int c, TCOD_bkgnd_flag_t flag)
-	@Py console_put_char( con, x,  y, c, flag=BKGND_DEFAULT)
-	@C#
-		void TCODConsole::putChar(int x, int y, int c)
-		void TCODConsole::putChar(int x, int y, int c, TCODBackgroundFlag flag)
-	@Lua
-		Console:putChar(x, y, c)
-		Console:putChar(x, y, c, flag)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param c the new ASCII code for the cell. You can use ASCII constants
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	*/
-	void putChar(int x, int y, int c, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
-
-	/**
-	@PageName console_draw_basic
-	@FuncTitle Setting every property of a cell using specific colors
-	@FuncDesc This function modifies every property of a cell :
-		* set the cell's background color to back.
-		* set the cell's foreground color to fore.
-		* set the cell's ASCII code to c.
-	@Cpp void TCODConsole::putCharEx(int x, int y, int c, const TCODColor & fore, const TCODColor & back)
-	@C void TCOD_console_put_char_ex(TCOD_console_t con,int x, int y, int c, TCOD_color_t fore, TCOD_color_t back)
-	@Py console_put_char_ex( con, x,  y, c, fore, back)
-	@C# void TCODConsole::putCharEx(int x, int y, int c, TCODColor fore, TCODColor back)
-	@Lua Console:putCharEx(x, y, c, fore, back)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param c the new ASCII code for the cell. You can use ASCII constants
-	@Param fore,back new foreground and background colors for this cell
-	*/
-	void putCharEx(int x, int y, int c, const TCODColor &fore, const TCODColor &back);
-
-	/**
-	@PageName console_bkgnd_flag_t
-	@PageTitle Background effect flags
-	@PageFather console_draw
-	@PageDesc This flag is used by most functions that modify a cell background color. It defines how the console's current background color is used to modify the cell's existing background color :
-		TCOD_BKGND_NONE : the cell's background color is not modified.
-		TCOD_BKGND_SET : the cell's background color is replaced by the console's default background color : newbk = curbk.
-		TCOD_BKGND_MULTIPLY : the cell's background color is multiplied by the console's default background color : newbk = oldbk * curbk
-		TCOD_BKGND_LIGHTEN : newbk = MAX(oldbk,curbk)
-		TCOD_BKGND_DARKEN : newbk = MIN(oldbk,curbk)
-		TCOD_BKGND_SCREEN : newbk = white - (white - oldbk) * (white - curbk) // inverse of multiply : (1-newbk) = (1-oldbk)*(1-curbk)
-		TCOD_BKGND_COLOR_DODGE : newbk = curbk / (white - oldbk)
-		TCOD_BKGND_COLOR_BURN : newbk = white - (white - oldbk) / curbk
-		TCOD_BKGND_ADD : newbk = oldbk + curbk
-		TCOD_BKGND_ADDALPHA(alpha) : newbk = oldbk + alpha*curbk
-		TCOD_BKGND_BURN : newbk = oldbk + curbk - white
-		TCOD_BKGND_OVERLAY : newbk = curbk.x <= 0.5 ? 2*curbk*oldbk : white - 2*(white-curbk)*(white-oldbk)
-		TCOD_BKGND_ALPHA(alpha) : newbk = (1.0f-alpha)*oldbk + alpha*(curbk-oldbk)
-		TCOD_BKGND_DEFAULT : use the console's default background flag
-		Note that TCOD_BKGND_ALPHA and TCOD_BKGND_ADDALPHA are MACROS that needs a float parameter between (0.0 and 1.0). TCOD_BKGND_ALPH and TCOD_BKGND_ADDA should not be used directly (else they will have the same effect as TCOD_BKGND_NONE).
-		For python, remove TCOD_ : libtcod.BKGND_NONE
-		For C# : None, Set, Multiply, Lighten, Darken, Screen, ColodDodge, ColorBurn, Add, Burn Overlay, Default
-		With lua, use tcod.None, ..., tcod.Default, BUT tcod.console.Alpha(value) and tcod.console.AddAlpha(value)
-	*/
-
-	/**
-	@PageName console_print
-	@PageTitle String drawing functions
-	@PageFather console_draw
-	@FuncTitle Setting the default background flag
-	@FuncDesc This function defines the background mode (see TCOD_bkgnd_flag_t) for the console.
-		This default mode is used by several functions (print, printRect, ...)
-	@Cpp void TCODConsole::setBackgroundFlag(TCOD_bkgnd_flag_t flag)
-	@C void TCOD_console_set_background_flag(TCOD_console_t con,TCOD_bkgnd_flag_t flag)
-	@Py console_set_background_flag(con, flag)
-	@C# void TCODConsole::setBackgroundFlag(TCODBackgroundFlag flag)
-	@Lua Console:setBackgroundFlag(flag)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	*/
-	void setBackgroundFlag(TCOD_bkgnd_flag_t flag);
-
-	/**
-	@PageName console_print
-	@FuncTitle Getting the default background flag
-	@FuncDesc This function returns the background mode (see TCOD_bkgnd_flag_t) for the console.
-		This default mode is used by several functions (print, printRect, ...)
-	@Cpp TCOD_bkgnd_flag_t TCODConsole::getBackgroundFlag() const
-	@C TCOD_bkgnd_flag_t TCOD_console_get_background_flag(TCOD_console_t con)
-	@Py console_get_background_flag(con)
-	@C# TCODBackgroundFlag TCODConsole::getBackgroundFlag()
-	@Lua Console:getBackgroundFlag()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	TCOD_bkgnd_flag_t getBackgroundFlag() const;
-
-	/**
-	@PageName console_print
-	@FuncTitle Setting the default alignment
-	@FuncDesc This function defines the default alignment (see TCOD_alignment_t) for the console.
-		This default alignment is used by several functions (print, printRect, ...).
-		Values for alignment : TCOD_LEFT, TCOD_CENTER, TCOD_RIGHT (in python, remove TCOD_ : libtcod.LEFT).
-		For C# and Lua : LeftAlignment, RightAlignment, CenterAlignment
-	@Cpp void TCODConsole::setAlignment(TCOD_alignment_t alignment)
-	@C void TCOD_console_set_alignment(TCOD_console_t con,TCOD_bkgnd_flag_t alignment)
-	@Py console_set_alignment(con, alignment)
-	@C# void TCODConsole::setAlignment(TCODAlignment alignment)
-	@Lua Console:setAlignment(alignment)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param alignment defines how the strings are printed on screen.
-	*/
-	void setAlignment(TCOD_alignment_t alignment);
-
-	/**
-	@PageName console_print
-	@FuncTitle Getting the default alignment
-	@FuncDesc This function returns the default alignment (see TCOD_alignment_t) for the console.
-		This default mode is used by several functions (print, printRect, ...).
-		Values for alignment : TCOD_LEFT, TCOD_CENTER, TCOD_RIGHT (in python, remove TCOD_ : libtcod.LEFT).
-		For C# and Lua : LeftAlignment, RightAlignment, CenterAlignment
-	@Cpp TCOD_alignment_t TCODConsole::getAlignment() const
-	@C TCOD_alignment_t TCOD_console_get_alignment(TCOD_console_t con)
-	@Py console_get_alignment(con)
-	@C# TCODAlignment TCODConsole::getAlignment()
-	@Lua Console:getAlignment()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	TCOD_alignment_t getAlignment() const;
-
-	/**
-	@PageName console_print
-	@FuncTitle Printing a string with default parameters
-	@FuncDesc This function print a string at a specific position using current default alignment, background flag, foreground and background colors.
-	@Cpp void TCODConsole::print(int x, int y, const char *fmt, ...)
-	@C void TCOD_console_print(TCOD_console_t con,int x, int y, const char *fmt, ...)
-	@Py console_print(con, x, y, fmt)
-	@C# void TCODConsole::print(int x, int y, string fmt)
-	@Lua Console:print(x, y, fmt)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinate of the character in the console, depending on the default alignment for this console :
-		* TCOD_LEFT : leftmost character of the string
-		* TCOD_CENTER : center character of the string
-		* TCOD_RIGHT : rightmost character of the string
-	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
-	*/
-	void print(int x, int y, const char *fmt, ...);
-
-	/**
-	@PageName console_print
-	@FuncTitle Printing a string with specific alignment and background mode
-	@FuncDesc This function print a string at a specific position using specific alignment and background flag, but default foreground and background colors.
-	@Cpp void TCODConsole::printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
-	@C void TCOD_console_print_ex(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
-	@Py console_print_ex(con, x, y, flag, alignment, fmt)
-	@C# void TCODConsole::printEx(int x, int y, TCODBackgroundFlag flag, TCODAlignment alignment, string fmt)
-	@Lua Console::printEx(x, y, flag, alignment, fmt)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinate of the character in the console, depending on the alignment :
-		* TCOD_LEFT : leftmost character of the string
-		* TCOD_CENTER : center character of the string
-		* TCOD_RIGHT : rightmost character of the string
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	@Param alignment defines how the strings are printed on screen.
-	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
-	*/
-	void printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
-
-	/**
-	@PageName console_print
-	@FuncTitle Printing a string with default parameters and autowrap
-	@FuncDesc This function draws a string in a rectangle inside the console, using default colors, alignment and background mode.
-		If the string reaches the borders of the rectangle, carriage returns are inserted.
-		If h > 0 and the bottom of the rectangle is reached, the string is truncated. If h = 0, the string is only truncated if it reaches the bottom of the console.
-		The function returns the height (number of console lines) of the printed string.
-	@Cpp int TCODConsole::printRect(int x, int y, int w, int h, const char *fmt, ...)
-	@C int TCOD_console_print_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...)
-	@Py console_print_rect(con, x, y, w, h, fmt)
-	@C# int TCODConsole::printRect(int x, int y, int w, int h, string fmt)
-	@Lua Console:printRect(x, y, w, h, fmt)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinate of the character in the console, depending on the alignment :
-		* TCOD_LEFT : leftmost character of the string
-		* TCOD_CENTER : center character of the string
-		* TCOD_RIGHT : rightmost character of the string
-	@Param w,h size of the rectangle
-		x <= x+w < console width
-		y <= y+h < console height
-	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
-	*/
-   	int printRect(int x, int y, int w, int h, const char *fmt, ...);
-
-	/**
-	@PageName console_print
-	@FuncTitle Printing a string with specific alignment and background mode and autowrap
-	@FuncDesc This function draws a string in a rectangle inside the console, using default colors, but specific alignment and background mode.
-		If the string reaches the borders of the rectangle, carriage returns are inserted.
-		If h > 0 and the bottom of the rectangle is reached, the string is truncated. If h = 0, the string is only truncated if it reaches the bottom of the console.
-		The function returns the height (number of console lines) of the printed string.
-	@Cpp int TCODConsole::printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
-	@C int TCOD_console_print_rect_ex(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
-	@Py console_print_rect_ex(con, x, y, w, h, flag, alignment, fmt)
-	@C# int TCODConsole::printRectEx(int x, int y, int w, int h, TCODBackgroundFlag flag, TCODAlignment alignment, string fmt)
-	@Lua Console:printRectEx(x, y, w, h, flag, alignment, fmt)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinate of the character in the console, depending on the alignment :
-		* TCOD_LEFT : leftmost character of the string
-		* TCOD_CENTER : center character of the string
-		* TCOD_RIGHT : rightmost character of the string
-	@Param w,h size of the rectangle
-		x <= x+w < console width
-		y <= y+h < console height
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	@Param alignment defines how the strings are printed on screen.
-	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
-	*/
-	int printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
-
-	/**
-	@PageName console_print
-	@FuncTitle Compute the height of an autowrapped string
-	@FuncDesc This function returns the expected height of an autowrapped string without actually printing the string with printRect or printRectEx
-	@Cpp int TCODConsole::getHeightRect(int x, int y, int w, int h, const char *fmt, ...)
-
-	@C int TCOD_console_get_height_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...)
-	@Py console_get_height_rect(con, x, y, w, h, fmt)
-	@C# int TCODConsole::getHeightRect(int x, int y, int w, int h, string fmt)
-	@Lua Console:getHeightRect(x, y, w, h, fmt)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinate of the rectangle upper-left corner in the console
-	@Param w,h size of the rectangle
-		x <= x+w < console width
-		y <= y+h < console height
-	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
-	*/
-	int getHeightRect(int x, int y, int w, int h, const char *fmt, ...);
-
-	/**
-	@PageName console_print
-	@FuncTitle Changing the colors while printing a string
-	@FuncDesc If you want to draw a string using different colors for each word, the basic solution is to call a string printing function several times, changing the default colors between each call.
-		The TCOD library offers a simpler way to do this, allowing you to draw a string using different colors in a single call. For this, you have to insert color control codes in your string.
-		A color control code is associated with a color set (a foreground color and a background color). If you insert this code in your string, the next characters will use the colors associated with the color control code.
-		There are 5 predefined color control codes :
-		For python, remove TCOD_ : libtcod.COLCTRL_1
-			TCOD_COLCTRL_1
-			TCOD_COLCTRL_2
-			TCOD_COLCTRL_3
-			TCOD_COLCTRL_4
-			TCOD_COLCTRL_5
-		To associate a color with a code, use setColorControl.
-		To go back to the console's default colors, insert in your string the color stop control code :
-			TCOD_COLCTRL_STOP
-
-		You can also use any color without assigning it to a control code, using the generic control codes :
-			TCOD_COLCTRL_FORE_RGB
-			TCOD_COLCTRL_BACK_RGB
-
-		Those controls respectively change the foreground and background color used to print the string characters. In the string, you must insert the r,g,b components of the color (between 1 and 255. The value 0 is forbidden because it represents the end of the string in C/C++) immediately after this code.
-	@Cpp static void TCODConsole::setColorControl(TCOD_colctrl_t con, const TCODColor &fore, const TCODColor &back)
-	@C void TCOD_console_set_color_control(TCOD_colctrl_t con, TCOD_color_t fore, TCOD_color_t back)
-	@Py console_set_color_control(con,fore,back)
-	@C# Not supported directly, use getRGBColorControlString and getColorControlString.
-	@Lua Not supported
-	@Param con the color control TCOD_COLCTRL_x, 1<=x<=5
-	@Param fore foreground color when this control is activated
-	@Param back background color when this control is activated
-	@CppEx
-		// A string with a red over black word, using predefined color control codes
-		TCODConsole::setColorControl(TCOD_COLCTRL_1,TCODColor::red,TCODColor::black);
-		TCODConsole::root->print(1,1,"String with a %cred%c word.",TCOD_COLCTRL_1,TCOD_COLCTRL_STOP);
-		// A string with a red over black word, using generic color control codes
-		TCODConsole::root->print(1,1,"String with a %c%c%c%c%c%c%c%cred%c word.",
-	          TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_BACK_RGB,1,1,1,TCOD_COLCTRL_STOP);
-		// A string with a red over black word, using generic color control codes
-		TCODConsole::root->print(1,1,"String with a %c%c%c%c%c%c%c%cred%c word.",
-	          TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_BACK_RGB,1,1,1,TCOD_COLCTRL_STOP);
-	@CEx
-		// A string with a red over black word, using predefined color control codes
-		TCOD_console_set_color_control(TCOD_COLCTRL_1,red,black);
-		TCOD_console_print(NULL,1,1,"String with a %cred%c word.",TCOD_COLCTRL_1,TCOD_COLCTRL_STOP);
-		// A string with a red word (over default background color), using generic color control codes
-		TCOD_console_print(NULL,1,1,"String with a %c%c%c%cred%c word.",
-			TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_STOP);
-		// A string with a red over black word, using generic color control codes
-		TCOD_console_print(NULL,1,1,"String with a %c%c%c%c%c%c%c%cred%c word.",
-			TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_BACK_RGB,1,1,1,TCOD_COLCTRL_STOP);
-	@PyEx
-		# A string with a red over black word, using predefined color control codes
-		libtcod.console_set_color_control(libtcod.COLCTRL_1,litbcod.red,litbcod.black)
-		libtcod.console_print(0,1,1,"String with a %cred%c word."%(libtcod.COLCTRL_1,libtcod.COLCTRL_STOP))
-		# A string with a red word (over default background color), using generic color control codes
-		litbcod.console_print(0,1,1,"String with a %c%c%c%cred%c word."%(libtcod.COLCTRL_FORE_RGB,255,1,1,libtcod.COLCTRL_STOP))
-		# A string with a red over black word, using generic color control codes
-		libtcod.console_print(0,1,1,"String with a %c%c%c%c%c%c%c%cred%c word."%
-		        (libtcod.COLCTRL_FORE_RGB,255,1,1,libtcod.COLCTRL_BACK_RGB,1,1,1,libtcod.COLCTRL_STOP))
-
-	@C#Ex
-		TCODConsole.root.print(1,1,String.Format("String with a {0}red{1} word.",
-			TCODConsole.getRGBColorControlString(ColorControlForeground,TCODColor.red),
-			TCODConsole.getColorControlString(ColorControlStop));
-	*/
-	static void setColorControl(TCOD_colctrl_t con, const TCODColor &fore, const TCODColor &back);
-
-#ifndef NO_UNICODE
-	/**
-	@PageName console_print
-	@FuncTitle Unicode functions
-	@FuncDesc those functions are similar to their ASCII equivalent, but work with unicode strings (wchar_t in C/C++).
-		Note that unicode is not supported in the python wrapper.
-	@Cpp static void TCODConsole::mapStringToFont(const wchar_t *s, int fontCharX, int fontCharY)
-	@C void TCOD_console_map_string_to_font_utf(const wchar_t *s, int fontCharX, int fontCharY)
-	*/
-	static void mapStringToFont(const wchar_t *s, int fontCharX, int fontCharY);
-	/**
-	@PageName console_print
-	@Cpp void TCODConsole::print(int x, int y, const wchar_t *fmt, ...)
-	@C void TCOD_console_print_utf(TCOD_console_t con,int x, int y, const wchar_t *fmt, ...)
-	*/
-	void print(int x, int y, const wchar_t *fmt, ...);
-	/**
-	@PageName console_print
-	@Cpp void TCODConsole::printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
-	@C void TCOD_console_print_ex_utf(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
-	*/
-	void printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
-	/**
-	@PageName console_print
-	@Cpp int TCODConsole::printRect(int x, int y, int w, int h, const wchar_t *fmt, ...)
-	@C int TCOD_console_print_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...)
-	*/
-   	int printRect(int x, int y, int w, int h, const wchar_t *fmt, ...);
-
-	/**
-	@PageName console_print
-	@Cpp int TCODConsole::printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
-	@C int TCOD_console_print_rect_ex_utf(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
-	*/
-	int printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
-
-	/**
-	@PageName console_print
-	@Cpp int TCODConsole::getHeightRect(int x, int y, int w, int h, const wchar_t *fmt, ...)
-	@C int TCOD_console_get_height_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...)
-	*/
-	int getHeightRect(int x, int y, int w, int h, const wchar_t *fmt, ...);
-#endif
-
-	/**
-	@PageName console_advanced
-	@PageFather console_draw
-	@PageTitle Advanced printing functions
-	@FuncTitle Filling a rectangle with the background color
-	@FuncDesc Fill a rectangle inside a console. For each cell in the rectangle :
-		* set the cell's background color to the console default background color
-		* if clear is true, set the cell's ASCII code to 32 (space)
-	@Cpp void TCODConsole::rect(int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
-	@C void TCOD_console_rect(TCOD_console_t con,int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag)
-	@Py console_rect(con,x,  y,  w, h, clear, flag=BKGND_DEFAULT)
-	@C#
-		void TCODConsole::rect(int x, int y, int w, int h, bool clear)
-		void TCODConsole::rect(int x, int y, int w, int h, bool clear, TCODBackgroundFlag flag)
-	@Lua
-		Console:rect(x, y, w, h, clear)
-		Console:rect(x, y, w, h, clear, flag)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of rectangle upper-left corner in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param w,h size of the rectangle in the console.
-		x <= x+w < console width
-		y <= y+h < console height
-	@Param clear if true, all characters inside the rectangle are set to ASCII code 32 (space).
-		If false, only the background color is modified
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	*/
-	void rect(int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
-
-	/**
-	@PageName console_advanced
-	@FuncTitle Drawing an horizontal line
-	@FuncDesc Draws an horizontal line in the console, using ASCII code TCOD_CHAR_HLINE (196), and the console's default background/foreground colors.
-	@Cpp void TCODConsole::hline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
-	@C void TCOD_console_hline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag)
-	@Py console_hline(con,x,y,l,flag=BKGND_DEFAULT)
-	@C#
-		void TCODConsole::hline(int x,int y, int l)
-		void TCODConsole::hline(int x,int y, int l, TCODBackgroundFlag flag)
-	@Lua
-		Console:hline(x,y, l)
-		Console:hline(x,y, l, flag)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y Coordinates of the line's left end in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param l The length of the line in cells 1 <= l <= console width - x
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	*/
-	void hline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
-
-	/**
-	@PageName console_advanced
-	@FuncTitle Drawing an vertical line
-	@FuncDesc Draws an vertical line in the console, using ASCII code TCOD_CHAR_VLINE (179), and the console's default background/foreground colors.
-	@Cpp void TCODConsole::vline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
-	@C void TCOD_console_vline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag)
-	@Py console_vline(con,x,y,l,flag=BKGND_DEFAULT)
-	@C#
-		void TCODConsole::vline(int x,int y, int l)
-		void TCODConsole::vline(int x,int y, int l, TCODBackgroundFlag flag)
-	@Lua
-		Console:vline(x,y, l)
-		Console:vline(x,y, l, flag)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y Coordinates of the line's upper end in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param l The length of the line in cells 1 <= l <= console height - y
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	*/
-	void vline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
-
-	/**
-	@PageName console_advanced
-	@FuncTitle Drawing a window frame
-	@FuncDesc This function calls the rect function using the supplied background mode flag, then draws a rectangle with the console's default foreground color. If fmt is not NULL, it is printed on the top of the rectangle, using inverted colors.
-	@Cpp void TCODConsole::printFrame(int x,int y,int w,int h, bool clear=true, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT, const char *fmt=NULL, ...)
-	@C void TCOD_console_print_frame(TCOD_console_t con,int x,int y,int w,int h, bool clear, TCOD_bkgnd_flag_t flag, const char *fmt, ...)
-	@Py console_print_frame(con,x, y, w, h, clear=True, flag=BKGND_DEFAULT, fmt=0)
-	@C#
-		void TCODConsole::printFrame(int x,int y, int w,int h)
-		void TCODConsole::printFrame(int x,int y, int w,int h, bool clear)
-		void TCODConsole::printFrame(int x,int y, int w,int h, bool clear, TCODBackgroundFlag flag)
-		void TCODConsole::printFrame(int x,int y, int w,int h, bool clear, TCODBackgroundFlag flag, string fmt)
-	@Lua
-		Console:printFrame(x,y, w,h)
-		Console:printFrame(x,y, w,h, clear)
-		Console:printFrame(x,y, w,h, clear, flag)
-		Console:printFrame(x,y, w,h, clear, flag, fmt)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y Coordinates of the rectangle's upper-left corner in the console.
-		0 <= x < console width
-		0 <= y < console height
-	@Param w,h size of the rectangle in the console.
-		x <= x+w < console width
-		y <= y+h < console height
-	@Param clear if true, all characters inside the rectangle are set to ASCII code 32 (space).
-		If false, only the background color is modified
-	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
-	@Param fmt if NULL, the funtion only draws a rectangle.
-		Else, printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string.
-	*/
-	void printFrame(int x,int y,int w,int h, bool clear=true, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT, const char *fmt=NULL, ...);
-
-	/**
-	@PageName console_read
-	@PageTitle Reading the content of the console
-	@PageFather console_draw
-	@FuncTitle Get the console's width
-	@FuncDesc This function returns the width of a console (either the root console or an offscreen console)
-	@Cpp int TCODConsole::getWidth() const
-	@C int TCOD_console_get_width(TCOD_console_t con)
-	@Py console_get_width(con)
-	@C# int TCODConsole::getWidth()
-	@Lua Console:getWidth()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	int getWidth() const;
-
-	/**
-	@PageName console_read
-	@FuncTitle Get the console's height
-	@FuncDesc This function returns the height of a console (either the root console or an offscreen console)
-	@Cpp int TCODConsole::getHeight() const
-	@C int TCOD_console_get_height(TCOD_console_t con)
-	@Py console_get_height(con)
-	@C# int TCODConsole::getHeight()
-	@Lua Console:getHeight()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	int getHeight() const;
-
-	/**
-	@PageName console_read
-	@FuncTitle Reading the default background color
-	@FuncDesc This function returns the default background color of a console.
-	@Cpp TCODColor TCODConsole::getDefaultBackground() const
-	@C TCOD_color_t TCOD_console_get_default_background(TCOD_console_t con)
-	@Py console_get_default_background(con)
-	@C# TCODColor TCODConsole::getBackgroundColor()
-	@Lua Console:getBackgroundColor()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	TCODColor getDefaultBackground() const;
-
-	/**
-	@PageName console_read
-	@FuncTitle Reading the default foreground color
-	@FuncDesc This function returns the default foreground color of a console.
-	@Cpp TCODColor TCODConsole::getDefaultForeground() const
-	@C TCOD_color_t TCOD_console_get_default_foreground(TCOD_console_t con)
-	@Py console_get_default_foreground(con)
-	@C# TCODColor TCODConsole::getForegroundColor()
-	@Lua Console:getForegroundColor()
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	*/
-	TCODColor getDefaultForeground() const;
-
-	/**
-	@PageName console_read
-	@FuncTitle Reading the background color of a cell
-	@FuncDesc This function returns the background color of a cell.
-	@Cpp TCODColor TCODConsole::getCharBackground(int x, int y) const
-	@C TCOD_color_t TCOD_console_get_char_background(TCOD_console_t con,int x, int y)
-	@Py console_get_char_background(con,x,y)
-	@C# TCODColor TCODConsole::getCharBackground(int x, int y)
-	@Lua Console::getCharBackground(x, y)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	*/
-	TCODColor getCharBackground(int x, int y) const;
-
-	/**
-	@PageName console_read
-	@FuncTitle Reading the foreground color of a cell
-	@FuncDesc This function returns the foreground color of a cell.
-	@Cpp TCODColor TCODConsole::getCharForeground(int x, int y) const
-	@C TCOD_color_t TCOD_console_get_char_foreground(TCOD_console_t con,int x, int y)
-	@Py console_get_char_foreground(con,x,y)
-	@C# TCODColor TCODConsole::getCharForeground(int x, int y)
-	@Lua Console::getCharForeground(x, y)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	*/
-	TCODColor getCharForeground(int x, int y) const;
-
-	/**
-	@PageName console_read
-	@FuncTitle Reading the ASCII code of a cell
-	@FuncDesc This function returns the ASCII code of a cell.
-	@Cpp int TCODConsole::getChar(int x, int y) const
-	@C int TCOD_console_get_char(TCOD_console_t con,int x, int y)
-	@Py console_get_char(con,x,y)
-	@C# int TCODConsole::getChar(int x, int y)
-	@Lua Console::getChar(x, y)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param x,y coordinates of the cell in the console.
-		0 <= x < console width
-		0 <= y < console height
-	*/
-	int getChar(int x, int y) const;
-
-	/**
-	@PageName console_fading
-	@PageTitle Screen fading functions
-	@PageFather console_draw
-	@PageDesc Use these functions to easily fade to/from a color
-	@FuncTitle Changing the fading parameters
-	@FuncDesc This function defines the fading parameters, allowing to easily fade the game screen to/from a color. Once they are defined, the fading parameters are valid for ever. You don't have to call setFade for each rendered frame (unless you change the fading parameters).
-	@Cpp static void TCODConsole::setFade(uint8 fade, const TCODColor &fadingColor)
-	@C void TCOD_console_set_fade(uint8 fade, TCOD_color_t fadingColor)
-	@Py console_set_fade(fade, fadingColor)
-	@C# static void TCODConsole::setFade(byte fade, TCODColor fadingColor)
-	@Lua tcod.console.setFade(fade, fadingColor)
-	@Param fade the fading amount. 0 => the screen is filled with the fading color. 255 => no fading effect
-	@Param fadingColor the color to use during the console flushing operation
-	@CppEx
-		for (int fade=255; fade >= 0; fade --) {
-			TCODConsole::setFade(fade,TCODColor::black);
-			TCODConsole::flush();
-		}
-	@CEx
-		int fade;
-		for (fade=255; fade >= 0; fade --) {
-			TCOD_console_setFade(fade,TCOD_black);
-			TCOD_console_flush();
-		}
-	@PyEx
-		for fade in range(255,0) :
-			libtcod.console_setFade(fade,libtcod.black)
-			libtcod.console_flush()
-	@LuaEx
-		for fade=255,0,-1 do
-			tcod.console.setFade(fade,tcod.color.black)
-			tcod.console.flush()
-		end
-	*/
-	static void setFade(uint8 fade, const TCODColor &fadingColor);
-
-	/**
-	@PageName console_fading
-	@FuncTitle Reading the fade amount
-	@FuncDesc This function returns the current fade amount, previously defined by setFade.
-	@Cpp static uint8 TCODConsole::getFade()
-	@C uint8 TCOD_console_get_fade()
-	@Py console_get_fade()
-	@C# static byte TCODConsole::getFade()
-	@Lua tcod.console.getFade()
-	*/
-	static uint8 getFade();
-
-	/**
-	@PageName console_fading
-	@FuncTitle Reading the fading color
-	@FuncDesc This function returns the current fading color, previously defined by setFade.
-	@Cpp static TCODColor TCODConsole::getFadingColor()
-	@C TCOD_color_t TCOD_console_get_fading_color()
-	@Py console_get_fading_color()
-	@C# static TCODColor TCODConsole::getFadingColor()
-	@Lua tcod.console.getFadingColor()
-	*/
-	static TCODColor getFadingColor();
-
-	/**
-	@PageName console_flush
-	@PageFather console
-	@PageTitle Flushing the root console
-	@FuncDesc Once the root console is initialized, you can use one of the printing functions to change the background colors, the foreground colors or the ASCII characters on the console.
-		Once you've finished rendering the root console, you have to actually apply the updates to the screen with this function.
-	@Cpp static void TCODConsole::flush()
-	@C void TCOD_console_flush()
-	@Py console_flush()
-	@C# static void TCODConsole::flush()
-	@Lua tcod.console.flush()
-	*/
-	static void flush();
-
-	/**
-	@PageName console_ascii
-	@PageTitle ASCII constants
-	@PageFather console_draw
-	@FuncDesc Some useful graphic characters in the terminal.bmp font. For the python version, remove TCOD_ from the constants. C# and Lua is in parenthesis :
-		Single line walls:
-		TCOD_CHAR_HLINE=196 (HorzLine)
-		TCOD_CHAR_VLINE=179 (VertLine)
-		TCOD_CHAR_NE=191 (NE)
-		TCOD_CHAR_NW=218 (NW)
-		TCOD_CHAR_SE=217 (SE)
-		TCOD_CHAR_SW=192 (SW)
-
-		Double lines walls:
-		TCOD_CHAR_DHLINE=205 (DoubleHorzLine)
-		TCOD_CHAR_DVLINE=186 (DoubleVertLine)
-		TCOD_CHAR_DNE=187 (DoubleNE)
-		TCOD_CHAR_DNW=201 (DoubleNW)
-		TCOD_CHAR_DSE=188 (DoubleSE)
-		TCOD_CHAR_DSW=200 (DoubleSW)
-
-		Single line vertical/horizontal junctions (T junctions):
-		TCOD_CHAR_TEEW=180 (TeeWest)
-		TCOD_CHAR_TEEE=195 (TeeEast)
-		TCOD_CHAR_TEEN=193 (TeeNorth)
-		TCOD_CHAR_TEES=194 (TeeSouth)
-
-		Double line vertical/horizontal junctions (T junctions):
-		TCOD_CHAR_DTEEW=185 (DoubleTeeWest)
-		TCOD_CHAR_DTEEE=204 (DoubleTeeEast)
-		TCOD_CHAR_DTEEN=202 (DoubleTeeNorth)
-		TCOD_CHAR_DTEES=203 (DoubleTeeSouth)
-
-		Block characters:
-		TCOD_CHAR_BLOCK1=176 (Block1)
-		TCOD_CHAR_BLOCK2=177 (Block2)
-		TCOD_CHAR_BLOCK3=178 (Block3)
-
-		Cross-junction between two single line walls:
-		TCOD_CHAR_CROSS=197 (Cross)
-
-		Arrows:
-		TCOD_CHAR_ARROW_N=24 (ArrowNorth)
-		TCOD_CHAR_ARROW_S=25 (ArrowSouth)
-		TCOD_CHAR_ARROW_E=26 (ArrowEast)
-		TCOD_CHAR_ARROW_W=27 (ArrowWest)
-
-		Arrows without tail:
-		TCOD_CHAR_ARROW2_N=30 (ArrowNorthNoTail)
-		TCOD_CHAR_ARROW2_S=31 (ArrowSouthNoTail)
-		TCOD_CHAR_ARROW2_E=16 (ArrowEastNoTail)
-		TCOD_CHAR_ARROW2_W=17 (ArrowWestNoTail)
-
-		Double arrows:
-		TCOD_CHAR_DARROW_H=29 (DoubleArrowHorz)
-		TCOD_CHAR_ARROW_V=18 (DoubleArrowVert)
-
-		GUI stuff:
-		TCOD_CHAR_CHECKBOX_UNSET=224
-		TCOD_CHAR_CHECKBOX_SET=225
-		TCOD_CHAR_RADIO_UNSET=9
-		TCOD_CHAR_RADIO_SET=10
-
-		Sub-pixel resolution kit:
-		TCOD_CHAR_SUBP_NW=226 (SubpixelNorthWest)
-		TCOD_CHAR_SUBP_NE=227 (SubpixelNorthEast)
-		TCOD_CHAR_SUBP_N=228 (SubpixelNorth)
-		TCOD_CHAR_SUBP_SE=229 (SubpixelSouthEast)
-		TCOD_CHAR_SUBP_DIAG=230 (SubpixelDiagonal)
-		TCOD_CHAR_SUBP_E=231 (SubpixelEast)
-		TCOD_CHAR_SUBP_SW=232 (SubpixelSouthWest)
-
-		Miscellaneous characters:
-		TCOD_CHAR_SMILY = 1 (Smilie)
-		TCOD_CHAR_SMILY_INV = 2 (SmilieInv)
-		TCOD_CHAR_HEART = 3 (Heart)
-		TCOD_CHAR_DIAMOND = 4 (Diamond)
-		TCOD_CHAR_CLUB = 5 (Club)
-		TCOD_CHAR_SPADE = 6 (Spade)
-		TCOD_CHAR_BULLET = 7 (Bullet)
-		TCOD_CHAR_BULLET_INV = 8 (BulletInv)
-		TCOD_CHAR_MALE = 11 (Male)
-		TCOD_CHAR_FEMALE = 12 (Female)
-		TCOD_CHAR_NOTE = 13 (Note)
-		TCOD_CHAR_NOTE_DOUBLE = 14 (NoteDouble)
-		TCOD_CHAR_LIGHT = 15 (Light)
-		TCOD_CHAR_EXCLAM_DOUBLE = 19 (ExclamationDouble)
-		TCOD_CHAR_PILCROW = 20 (Pilcrow)
-		TCOD_CHAR_SECTION = 21 (Section)
-		TCOD_CHAR_POUND = 156 (Pound)
-		TCOD_CHAR_MULTIPLICATION = 158 (Multiplication)
-		TCOD_CHAR_FUNCTION = 159 (Function)
-		TCOD_CHAR_RESERVED = 169 (Reserved)
-		TCOD_CHAR_HALF = 171 (Half)
-		TCOD_CHAR_ONE_QUARTER = 172 (OneQuarter)
-		TCOD_CHAR_COPYRIGHT = 184 (Copyright)
-		TCOD_CHAR_CENT = 189 (Cent)
-		TCOD_CHAR_YEN = 190 (Yen)
-		TCOD_CHAR_CURRENCY = 207 (Currency)
-		TCOD_CHAR_THREE_QUARTERS = 243 (ThreeQuarters)
-		TCOD_CHAR_DIVISION = 246 (Division)
-		TCOD_CHAR_GRADE = 248 (Grade)
-		TCOD_CHAR_UMLAUT = 249 (Umlaut)
-		TCOD_CHAR_POW1 = 251 (Pow1)
-		TCOD_CHAR_POW3 = 252 (Pow2)
-		TCOD_CHAR_POW2 = 253 (Pow3)
-		TCOD_CHAR_BULLET_SQUARE = 254 (BulletSquare)
-	*/
-
-	/**
-	@PageName console_input
-	@PageTitle Handling keyboard input
-	@PageDesc The keyboard handling functions allow you to get keyboard input from the user, either for turn by turn games (the function wait until the user press a key), or real time games (non blocking function).
-	<b>WARNING : for proper redraw event handling, the keyboard functions should always be called just after TCODConsole::flush !</b>
-	@PageFather console
-	*/
-
-/**
-	@PageName console_blocking_input
-	@PageTitle Blocking keyboard input
-	@PageFather console_input
-	@FuncDesc This function waits for the user to press a key. It returns the code of the key pressed as well as the corresponding character. See TCOD_key_t.
-		If the flush parameter is true, every pending keypress event is discarded, then the function wait for a new keypress.
-		If flush is false, the function waits only if there are no pending keypress events, else it returns the first event in the keyboard buffer.
-	@Cpp static TCOD_key_t TCODConsole::waitForKeypress(bool flush)
-	@C TCOD_key_t TCOD_console_wait_for_keypress(bool flush)
-	@Py console_wait_for_keypress(flush)
-	@C# static TCOD_key_t TCODConsole::waitForKeypress(bool flush)
-	@Lua tcod.console.waitForKeypress(flush)
-	@Param flush if true, all pending keypress events are flushed from the keyboard buffer. Else, return the first available event
-	@CppEx
-		TCOD_key_t key = TCODConsole::waitForKeypress(true);
-		if ( key.c == 'i' ) { ... open inventory ... }
-	@CEx
-		TCOD_key_t key = TCOD_console_wait_for_keypress(true);
-		if ( key.c == 'i' ) { ... open inventory ... }
-	@PyEx
-		key = libtcod.console_wait_for_keypress(True)
-		if key.c == ord('i') : # ... open inventory ...
-	@LuaEx
-		key = tcod.console.waitForKeypress(true)
-		if key.Character == 'i' then ... open inventory ... end
-	*/
-	static TCOD_key_t waitForKeypress(bool flush);
-	/**
-	@PageName console_non_blocking_input
-	@PageTitle Non blocking keyboard input
-	@PageFather console_input
-	@FuncDesc This function checks if the user has pressed a key. It returns the code of the key pressed as well as the corresponding character. See TCOD_key_t. If the user didn't press a key, this function returns the key code TCODK_NONE (NoKey for C# and Lua).
-		<b>Note that key repeat only results in TCOD_KEY_PRESSED events.</b>
-	@Cpp static TCOD_key_t TCODConsole::checkForKeypress(int flags=TCOD_KEY_RELEASED)
-	@C TCOD_key_t TCOD_console_check_for_keypress(int flags)
-	@Py console_check_for_keypress(flags=KEY_RELEASED)
-	@C# static TCODKey TCODConsole::checkForKeypress(int flags) // Use TCODKeyStatus
-	@Lua tcod.console.checkForKeypress(flags)
-	@Param flags A filter for key events (C# and Lua in parenthesis):
-		TCOD_KEY_PRESSED (KeyPressed) : only keypress events are returned
-		TCOD_KEY_RELEASED (KeyReleased): only key release events are returnes
-		TCOD_KEY_PRESSED|TCOD_KEY_RELEASED (KeyPressed+KeyReleased): events of both types are returned.
-	@CppEx
-		TCOD_key_t key = TCODConsole::checkForKeypress();
-		if ( key.vk == TCODK_NONE ) return; // no key pressed
-		if ( key.c == 'i' ) { ... open inventory ... }
-	@C
-		TCOD_key_t key = TCOD_console_check_for_keypress(TCOD_KEY_PRESSED);
-		if ( key.vk == TCODK_NONE ) return; // no key pressed
-		if ( key.c == 'i' ) { ... open inventory ... }
-	@Py
-		key = libtcod.console_check_for_keypress()
-		if key.vk == libtcod.KEY_NONE return # no key pressed
-		if key.c == ord('i') : # ... open inventory ...
-	@LuaEx
-		key = tcod.console.checkForKeypress()
-		if key.KeyCode == tcod.NoKey then return end -- no key pressed
-		if key.Character == 'i' then ... open inventory ... end
-	*/
-	static TCOD_key_t checkForKeypress(int flags=TCOD_KEY_RELEASED);
-	
-	/**
-	@PageName console_non_blocking_input
-	@PageTitle Non blocking keyboard input
-	@PageFather console_input
-	@FuncDesc You can also get the status of any special key at any time with :
-	@Cpp static bool TCODConsole::isKeyPressed(TCOD_keycode_t key)
-	@C bool TCOD_console_is_key_pressed(TCOD_keycode_t key)
-	@Py console_is_key_pressed(key)
-	@C# static bool TCODConsole::isKeyPressed(TCODKeyCode key)
-	@Lua tcod.console.isKeyPressed(key)
-	@Param key Any key code defined in keycode_t except TCODK_CHAR (Char) and TCODK_NONE (NoKey)
-	*/
-	static bool isKeyPressed(TCOD_keycode_t key);
-	/**
-	@PageName console_keyboard_repeat
-	@PageTitle Changing keyboard repeat delay
-	@PageFather console_input
-	@FuncDesc This function changes the keyboard repeat times.
-	@Cpp static void TCODConsole::setKeyboardRepeat(int initialDelay, int interval)
-	@C void TCOD_console_set_keyboard_repeat(int initial_delay, int interval)
-	@Py console_set_keyboard_repeat(initial_delay, interval)
-	@C# static void TCODConsole::setKeyboardRepeat(int initialDelay, int interval)
-	@Lua tcod.console.setKeyboardRepeat(initialDelay, interval)
-	@Param initialDelay delay in millisecond between the time when a key is pressed, and keyboard repeat begins. If 0, keyboard repeat is disabled
-	@Param interval interval in millisecond between keyboard repeat events
-	*/
-	static void setKeyboardRepeat(int initialDelay,int interval);
-	/**
-	@PageName console_keyboard_repeat
-	@FuncDesc You can also disable the keyboard repeat feature with this function (it's equivalent to setKeyboardRepeat(0,0) ).
-	@Cpp static void TCODConsole::disableKeyboardRepeat()
-	@C void TCOD_console_disable_keyboard_repeat()
-	@Py console_disable_keyboard_repeat()
-	@C# static void TCODConsole::disableKeyboardRepeat()
-	@Lua tcod.console.disableKeyboardRepeat()
-	*/
-	static void disableKeyboardRepeat();
-
-	/**
-	@PageName console_key_t
-	@PageTitle 	Keyboard event structure
-	@PageFather console_input
-	@PageDesc This structure contains information about a key pressed/released by the user.
-	@C
-		typedef struct {
-			TCOD_keycode_t vk;
-			char c;
-			bool pressed;
-			bool lalt;
-			bool lctrl;
-			bool ralt;
-			bool rctrl;
-			bool shift;
-		} TCOD_key_t;
-	@Lua
-		key.KeyCode
-		key.Character
-		key.Pressed
-		key.LeftAlt
-		key.LeftControl
-		key.RightAlt
-		key.RightControl
-		key.Shift
-	@Param vk An arbitrary value representing the physical key on the keyboard. Possible values are stored in the TCOD_keycode_t enum. If no key was pressed, the value is TCODK_NONE
-	@Param c If the key correspond to a printable character, the character is stored in this field. Else, this field contains 0.
-	@Param pressed true if the event is a key pressed, or false for a key released.
-	@Param lalt This field represents the status of the left Alt key : true => pressed, false => released.
-	@Param lctrl This field represents the status of the left Control key : true => pressed, false => released.
-	@Param ralt This field represents the status of the right Alt key : true => pressed, false => released.
-	@Param rctrl This field represents the status of the right Control key : true => pressed, false => released.
-	@Param shift This field represents the status of the shift key : true => pressed, false => released.
-	*/
-
-	/**
-	@PageName console_keycode_t
-	@PageTitle 	Key codes
-	@PageFather console_input
-	@PageDesc TCOD_keycode_t is a libtcod specific code representing a key on the keyboard.
-		For python, replace TCODK by KEY: libtcod.KEY_NONE. C# and Lua, the value is in parenthesis. Possible values are :
-		When no key was pressed (see checkForKeypress) : TCOD_NONE (NoKey)
-		Special keys :
-		TCODK_ESCAPE (Escape)
-		TCODK_BACKSPACE (Backspace)
-		TCODK_TAB (Tab)
-		TCODK_ENTER (Enter)
-		TCODK_SHIFT (Shift)
-		TCODK_CONTROL (Control)
-		TCODK_ALT (Alt)
-		TCODK_PAUSE (Pause)
-		TCODK_CAPSLOCK (CapsLock)
-		TCODK_PAGEUP (PageUp)
-		TCODK_PAGEDOWN (PageDown)
-		TCODK_END (End)
-		TCODK_HOME (Home)
-		TCODK_UP (Up)
-		TCODK_LEFT (Left)
-		TCODK_RIGHT (Right)
-		TCODK_DOWN (Down)
-		TCODK_PRINTSCREEN (Printscreen)
-		TCODK_INSERT (Insert)
-		TCODK_DELETE (Delete)
-		TCODK_LWIN (Lwin)
-		TCODK_RWIN (Rwin)
-		TCODK_APPS (Apps)
-		TCODK_KPADD (KeypadAdd)
-		TCODK_KPSUB (KeypadSubtract)
-		TCODK_KPDIV (KeypadDivide)
-		TCODK_KPMUL (KeypadMultiply)
-		TCODK_KPDEC (KeypadDecimal)
-		TCODK_KPENTER (KeypadEnter)
-		TCODK_F1 (F1)
-		TCODK_F2 (F2)
-		TCODK_F3 (F3)
-		TCODK_F4 (F4)
-		TCODK_F5 (F5)
-		TCODK_F6 (F6)
-		TCODK_F7 (F7)
-		TCODK_F8 (F8)
-		TCODK_F9 (F9)
-		TCODK_F10 (F10)
-		TCODK_F11 (F11)
-		TCODK_F12 (F12)
-		TCODK_NUMLOCK (Numlock)
-		TCODK_SCROLLLOCK (Scrolllock)
-		TCODK_SPACE (Space)
-
-		numeric keys :
-
-		TCODK_0 (Zero)
-		TCODK_1 (One)
-		TCODK_2 (Two)
-		TCODK_3 (Three)
-		TCODK_4 (Four)
-		TCODK_5 (Five)
-		TCODK_6 (Six)
-		TCODK_7 (Seven)
-		TCODK_8 (Eight)
-		TCODK_9 (Nine)
-		TCODK_KP0 (KeypadZero)
-		TCODK_KP1 (KeypadOne)
-		TCODK_KP2 (KeypadTwo)
-		TCODK_KP3 (KeypadThree)
-		TCODK_KP4 (KeypadFour)
-		TCODK_KP5 (KeypadFive)
-		TCODK_KP6 (KeypadSix)
-		TCODK_KP7 (KeypadSeven)
-		TCODK_KP8 (KeypadEight)
-		TCODK_KP9 (KeypadNine)
-
-		Any other (printable) key :
-
-		TCODK_CHAR (Char)
-
-		Codes starting with TCODK_KP represents keys on the numeric keypad (if available).
-	*/
-
-	/**
-	@PageName console_offscreen
-	@PageFather console
-	@PageTitle Using off-screen consoles
-	@PageDesc The offscreen consoles allow you to draw on secondary consoles as you would do with the root console. You can then blit those secondary consoles on the root console. This allows you to use local coordinate space while rendering a portion of the final screen, and easily move components of the screen without modifying the rendering functions.
-	@FuncTitle Creating an offscreen console
-	@FuncDesc You can create as many off-screen consoles as you want by using this function. You can draw on them as you would do with the root console, but you cannot flush them to the screen. Else, you can blit them on other consoles, including the root console. See blit. The C version of this function returns a console handler that you can use in most console drawing functions.
-	@Cpp TCODConsole::TCODConsole(int w, int h)
-	@C TCOD_console_t TCOD_console_new(int w, int h)
-	@Py console_new(w,h)
-	@C# TCODConsole::TCODConsole(int w, int h)
-	@Lua tcod.Console(w,h)
-	@Param w,h the console size.
-		0 < w
-		0 < h
-	@CppEx
-		// Creating a 40x20 offscreen console, filling it with red and blitting it on the root console at position 5,5
-		TCODConsole *offscreenConsole = new TCODConsole(40,20);
-		offscreenConsole->setDefaultBackground(TCODColor::red);
-		offscreenConsole->clear();
-		TCODConsole::blit(offscreenConsole,0,0,40,20,TCODConsole::root,5,5,255);
-	@CEx
-		TCOD_console_t offscreen_console = TCOD_console_new(40,20);
-		TCOD_console_set_default_background(offscreen_console,TCOD_red);
-		TCOD_console_clear(offscreen_console);
-		TCOD_console_blit(offscreen_console,0,0,40,20,NULL,5,5,255);
-	@PyEx
-		offscreen_console = libtcod.console_new(40,20)
-		libtcod.console_set_background_color(offscreen_console,libtcod.red)
-		libtcod.console_clear(offscreen_console)
-		libtcod.console_blit(offscreen_console,0,0,40,20,0,5,5,255)
-	@LuaEx
-		-- Creating a 40x20 offscreen console, filling it with red and blitting it on the root console at position 5,5
-		offscreenConsole = tcod.Console(40,20)
-		offscreenConsole:setBackgroundColor(tcod.color.red)
-		offscreenConsole:clear()
-		tcod.console.blit(offscreenConsole,0,0,40,20,libtcod.TCODConsole_root,5,5,255)
-	*/
-	TCODConsole(int w, int h);
-	
-	/**
-	@PageName console_offscreen
-	@FuncTitle Creating an offscreen console from a .asc or .apf file
-	@FuncDesc You can create an offscreen console from a file created with Ascii Paint with this constructor
-	@Cpp TCODConsole::TCODConsole(const char *filename)
-	@C TCOD_console_t TCOD_console_from_file(const char *filename)
-	@Param filename path to the .asc or .apf file created with Ascii Paint
-	@CppEx
-		// Creating an offscreen console, filling it with data from the .asc file
-		TCODConsole *offscreenConsole = new TCODConsole("myfile.asc");
-	@CEx
-		TCOD_console_t offscreen_console = TCOD_console_from_file("myfile.apf");
-	*/
-	TCODConsole(const char *filename);
-
-	/**
-	@PageName console_offscreen
-	@FuncTitle Loading an offscreen console from a .asc file
-	@FuncDesc You can load data from a file created with Ascii Paint with this function. When needed, the console will be resized to fit the file size. The function returns false if it couldn't read the file.
-	@Cpp bool TCODConsole::loadAsc(const char *filename)
-	@C bool TCOD_console_load_asc(TCOD_console_t con, const char *filename)
-	@Param con in the C and Python versions, the offscreen console handler
-	@Param filename path to the .asc file created with Ascii Paint
-	@CppEx
-		// Creating a 40x20 offscreen console
-		TCODConsole *offscreenConsole = new TCODConsole(40,20);
-		// possibly resizing it and filling it with data from the .asc file
-		offscreenConsole->loadAsc("myfile.asc");
-	@CEx
-		TCOD_console_t offscreen_console = TCOD_console_new(40,20);
-		TCOD_console_load_asc(offscreen_console,"myfile.asc");
-	*/
-	bool loadAsc(const char *filename);
-	/**
-	@PageName console_offscreen
-	@FuncTitle Loading an offscreen console from a .apf file
-	@FuncDesc You can load data from a file created with Ascii Paint with this function. When needed, the console will be resized to fit the file size. The function returns false if it couldn't read the file.
-	@Cpp bool TCODConsole::loadApf(const char *filename)
-	@C bool TCOD_console_load_apf(TCOD_console_t con, const char *filename)
-	@Param con in the C and Python versions, the offscreen console handler
-
-	@Param filename path to the .apf file created with Ascii Paint
-
-	@CppEx
-		// Creating a 40x20 offscreen console
-		TCODConsole *offscreenConsole = new TCODConsole(40,20);
-		// possibly resizing it and filling it with data from the .apf file
-		offscreenConsole->loadApf("myfile.apf");
-	@CEx
-		TCOD_console_t offscreen_console = TCOD_console_new(40,20);
-		TCOD_console_load_apf(offscreen_console,"myfile.asc");
-	*/
-	bool loadApf(const char *filename);
-
-    /**
-	@PageName console_offscreen
-	@FuncTitle Saving a console to a .asc file
-	@FuncDesc You can save data from a console to Ascii Paint format with this function. The function returns false if it couldn't write the file. This is the only ASC function that works also with the root console !
-	@Cpp bool TCODConsole::saveAsc(const char *filename) const
-	@C bool TCOD_console_save_asc(TCOD_console_t con, const char *filename)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param filename path to the .asc file to be created
-	@CppEx
-		console->saveAsc("myfile.asc");
-	@CEx
-		TCOD_console_save_asc(console,"myfile.asc");
-	*/
-	bool saveAsc(const char *filename) const;
-
-    /**
-	@PageName console_offscreen
-	@FuncTitle Saving a console to a .apf file
-	@FuncDesc You can save data from a console to Ascii Paint format with this function. The function returns false if it couldn't write the file. This is the only ASC function that works also with the root console !
-	@Cpp bool TCODConsole::saveApf(const char *filename) const
-	@C bool TCOD_console_save_apf(TCOD_console_t con, const char *filename)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param filename path to the .apf file to be created
-	@CppEx
-		console->saveApf("myfile.apf");
-	@CEx
-		TCOD_console_save_apf(console,"myfile.apf");
-	*/
-	bool saveApf(const char *filename) const;
-	
-	/**
-	@PageName console_offscreen
-	@FuncTitle Blitting a console on another one
-	@FuncDesc This function allows you to blit a rectangular area of the source console at a specific position on a destination console. It can also simulate alpha transparency with the fade parameter.
-	@Cpp static void blit(const TCODConsole *src,int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole *dst, int xDst, int yDst, float foregroundAlpha=1.0f, float backgroundAlpha=1.0f)
-	@C void TCOD_console_blit(TCOD_console_t src,int xSrc, int ySrc, int wSrc, int hSrc, TCOD_console_t dst, int xDst, int yDst, float foreground_alpha, float background_alpha)
-	@Py console_blit(src,xSrc,ySrc,xSrc,hSrc,dst,xDst,yDst,foregroundAlpha=1.0,backgroundAlpha=1.0)
-	@C#
-		static void TCODConsole::blit(TCODConsole src, int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole dst, int xDst, int yDst)
-		static void TCODConsole::blit(TCODConsole src, int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole dst, int xDst, int yDst, float foreground_alpha)
-		static void TCODConsole::blit(TCODConsole src, int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole dst, int xDst, int yDst, float foreground_alpha, float background_alpha)
-	@Lua
-		tcod.console.blit(src, xSrc, ySrc, wSrc, hSrc, dst, xDst, yDst)
-		tcod.console.blit(src, xSrc, ySrc, wSrc, hSrc, dst, xDst, yDst, foreground_alpha)
-		tcod.console.blit(src, xSrc, ySrc, wSrc, hSrc, dst, xDst, yDst, foreground_alpha, background_alpha)
-	@Param src The source console that must be blitted on another one.
-	@Param xSrc,ySrc,wSrc,hSrc The rectangular area of the source console that will be blitted. If wSrc and/or hSrc == 0, the source console width/height are used
-	@Param dst The destination console.
-	@Param xDst,yDst Where to blit the upper-left corner of the source area in the destination console.
-	@Param foregroundAlpha,backgroundAlpha Alpha transparency of the blitted console.
-		0.0 => The source console is completely transparent. This function does nothing.
-		1.0 => The source console is opaque. Its cells replace the destination cells.
-		0 < fade < 1.0 => The source console is partially blitted, simulating real transparency.
-	@CppEx
-		// Cross-fading between two offscreen consoles. We use two offscreen consoles with the same size as the root console. We render a different screen on each offscreen console. When the user hits a key, we do a cross-fading from the first screen to the second screen.
-		TCODConsole *off1 = new TCODConsole(80,50);
-		TCODConsole *off2 = new TCODConsole(80,50);
-		... print screen1 on off1
-		... print screen2 of off2
-		// render screen1 in the game window
-		TCODConsole::blit(off1,0,0,80,50,TCODConsole::root,0,0);
-		TCODConsole::flush();
-		// wait or a keypress
-		TCODConsole::waitForKeypress(true);
-		// do a cross-fading from off1 to off2
-		for (int i=1; i <= 255; i++) {
-			TCODConsole::blit(off1,0,0,80,50,TCODConsole::root,0,0); // renders the first screen (opaque)
-			TCODConsole::blit(off2,0,0,80,50,TCODConsole::root,0,0,i/255.0,i/255.0); // renders the second screen (transparent)
-			TCODConsole::flush();
-		}
-	@CEx
-		TCOD_console_t off1 = TCOD_console_new(80,50);
-		TCOD_console_t off2 = TCOD_console_new(80,50);
-		int i;
-		... print screen1 on off1
-		... print screen2 of off2
-		// render screen1 in the game window
-		TCOD_console_blit(off1,0,0,80,50,NULL,0,0,1.0,1.0);
-		TCOD_console_flush();
-		// wait or a keypress
-		TCOD_console_wait_for_keypress(true);
-		// do a cross-fading from off1 to off2
-		for (i=1; i <= 255; i++) {
-			TCOD_console_blit(off1,0,0,80,50,NULL,0,0,1.0,1.0); // renders the first screen (opaque)
-			TCOD_console_blit(off2,0,0,80,50,NULL,0,0,i/255.0,i/255.0); // renders the second screen (transparent)
-			TCOD_console_flush();
-		}
-	@PyEx
-		off1 = libtcod.console_new(80,50)
-		off2 = libtcod.console_new(80,50)
-		... print screen1 on off1
-		... print screen2 of off2
-		# render screen1 in the game window
-		libtcod.console_blit(off1,0,0,80,50,0,0,0)
-		libtcod.console_flush()
-		# wait or a keypress
-		libtcod.console_wait_for_keypress(True)
-		# do a cross-fading from off1 to off2
-		for i in range(1,256) :
-			litbcod.console_blit(off1,0,0,80,50,0,0,0) # renders the first screen (opaque)
-			litbcod.console_blit(off2,0,0,80,50,0,0,0,i/255.0,i/255.0) # renders the second screen (transparent)
-			litbcod.console_flush()
-	@LuaEx
-		-- Cross-fading between two offscreen consoles. We use two offscreen consoles with the same size as the root console. We render a different screen on each offscreen console. When the user hits a key, we do a cross-fading from the first screen to the second screen.
-		off1 = tcod.Console(80,50)
-		off2 = tcod.Console(80,50)
-		... print screen1 on off1
-		... print screen2 of off2
-		-- render screen1 in the game window
-		root=libtcod.TCODConsole_root
-		tcod.console.blit(off1,0,0,80,50,root,0,0)
-		tcod.console.flush()
-		-- wait or a keypress
-		tcod.console.waitForKeypress(true)
-		-- do a cross-fading from off1 to off2
-		for i=1,255,1 do
-			tcod.console.blit(off1,0,0,80,50,root,0,0) -- renders the first screen (opaque)
-			tcod.console.blit(off2,0,0,80,50,root,0,0,i/255,i/255) -- renders the second screen (transparent)
-			tcod.console.flush()
-		end
-	*/
-	static void blit(const TCODConsole *src,int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole *dst, int xDst, int yDst, float foreground_alpha=1.0f, float background_alpha=1.0f);
-	/**
-	@PageName console_offscreen
-	@FuncTitle Define a blit-transparent color
-	@FuncDesc This function defines a transparent background color for an offscreen console. All cells with this background color are ignored by the blit operation. You can use it to blit only some parts of the console.
-	@Cpp void TCODConsole::setKeyColor(const TCODColor &col)
-	@C void TCOD_console_set_key_color(TCOD_console_t con,TCOD_color_t col)
-	@Py console_set_key_color(con,col)
-	@C# void TCODConsole::setKeyColor(TCODColor col)
-	@Lua Console:setKeyColor(col)
-	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
-	@Param col the transparent background color
-	*/
-	void setKeyColor(const TCODColor &col);
-	/**
-	@PageName console_offscreen
-	@FuncTitle Destroying an offscreen console
-	@FuncDesc Use this function to destroy an offscreen console and release any resources allocated. Don't use it on the root console.
-	@Cpp TCODConsole::~TCODConsole()
-	@C void TCOD_console_delete(TCOD_console_t con)
-	@Py console_delete(con)
-	@C# void TCODConsole::Dispose()
-	@Lua through garbage collector
-	@Param con in the C and Python versions, the offscreen console handler
-	@CppEx
-		TCODConsole *off1 = new TCODConsole(80,50);
-		... use off1
-		delete off1; // destroy the offscreen console
-	@CEx
-		TCOD_console_t off1 = TCOD_console_new(80,50);
-		... use off1
-		TCOD_console_delete(off1); // destroy the offscreen console
-	@PyEx
-		off1 = libtcod.console_new(80,50)
-		... use off1
-		libtcod.console_delete(off1) # destroy the offscreen console
-	@LuaEx
-		off1 = tcod.Console(80,50)
-		... use off1
-		off1=nil -- release the reference
-	*/
-	virtual ~TCODConsole();
-
-	void setDirty(int x, int y, int w, int h);
-
-
-	TCODConsole(TCOD_console_t con) : data(con) {}
-
-    // ctrl = TCOD_COLCTRL_1...TCOD_COLCTRL_5 or TCOD_COLCTRL_STOP
-	static const char *getColorControlString( TCOD_colctrl_t ctrl );
-	// ctrl = TCOD_COLCTRL_FORE_RGB or TCOD_COLCTRL_BACK_RGB
-	static const char *getRGBColorControlString( TCOD_colctrl_t ctrl, const TCODColor & col );
-
-protected :
-	friend class TCODLIB_API TCODImage;
-	friend class TCODLIB_API TCODZip;
-	friend class TCODLIB_API TCODText;
-	TCODConsole();
-	TCOD_console_t data;
-};
-
-#endif
--- a/include/fov.hpp
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_FOV_HPP
-#define _TCOD_FOV_HPP
-
-#include "fov_types.h"
-
-class TCODPath;
-
-/**
- @PageName fov
- @PageCategory Roguelike toolkits
- @PageTitle Field of view
- @PageDesc This toolkit allows to easily calculate the potential visible set of map cells from the player position.
-A cell is potentially visible if the line of sight from the player to the cell in unobstructed.
- */
-
-class TCODLIB_API TCODMap {
-	public :
-		/**
-		@PageName fov_init
-		@PageFather fov
-		@PageTitle Building the map
-		@FuncTitle Creating the map object
-		@FuncDesc First, you have to allocate a map of the same size as your dungeon.
-		@Cpp TCODMap::TCODMap (int width, int height)
-		@C TCOD_map_t TCOD_map_new (int width, int height)
-		@Py map_new (width, height)
-		@C# TCODMap::TCODMap(int width, int height)
-		@Param width, height	The size of the map (in map cells).
-		*/		
-		TCODMap(int width, int height);
-		
-		/**
-		@PageName fov_init
-		@PageFather fov
-		@FuncTitle Defining the cell properties
-		@FuncDesc Then, build your dungeon by defining which cells let the light pass (by default, all cells block the light) and which cells are walkable (by default, all cells are not-walkable).
-		@Cpp void TCODMap::setProperties (int x, int y, bool isTransparent, bool isWalkable)
-		@C void TCOD_map_set_properties (TCOD_map_t map, int x, int y, bool is_transparent, bool is_walkable)
-		@Py map_set_properties (map, x, y, is_transparent, is_walkable)
-		@C# void TCODMap::setProperties (int x, int y, bool isTransparent, bool isWalkable)
-		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
-		@Param x, y	Coordinate of the cell that we want to update.
-		@Param isTransparent	If true, this cell will let the light pass else it will block the light.
-		@Param isWalkable	If true, creatures can walk true this cell (it is not a wall).
-		*/		
-		void setProperties(int x,int y, bool isTransparent, bool isWalkable);
-		
-		/**
-		@PageName fov_init
-		@PageFather fov
-		@FuncTitle Clearing the map
-		@FuncDesc You can clear an existing map (setting all cells to the chosen walkable/transparent values) with:
-		@Cpp void TCODMap::clear (bool transparent = false, bool walkable = false)
-		@C void TCOD_map_clear (TCOD_map_t map, bool transparent, bool walkable)
-		@Py map_clear (map, transparent = False, walkable = False)
-		@C#
-			void TCODMap::clear()
-			void TCODMap::clear(bool transparent)
-			void TCODMap::clear(bool transparent, bool walkable)
-		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
-		@Param walkable	Whether the cells should be walkable.
-		@Param transparent	Whether the cells should be transparent.
-		*/		
-		void clear(bool transparent=false, bool walkable=false);
-		
-		/**
-		@PageName fov_init
-		@PageFather fov
-		@FuncTitle Copying a map
-		@FuncDesc You can copy an existing map into another. You have to allocate the destination map first.
-		@Cpp void TCODMap::copy (const TCODMap * source)
-		@C void TCOD_map_copy (TCOD_map_t source, TCOD_map_t dest)
-		@Py map_copy (source, dest)
-		@C# void TCODMap::copy (TCODMap source)
-		@Param source	The map containing the source data.
-		@Param dest	In C and python version, the map where data is copied.
-		@CppEx 
-			TCODMap * map = new TCODMap(50,50); // allocate the map
-			map->setProperties(10,10,true,true); // set a cell as 'empty'
-			TCODMap * map2 = new TCODMap(10,10); // allocate another map
-			map2->copy(map); // copy map data into map2, reallocating it to 50x50
-		@CEx 
-			TCOD_map_t map = TCOD_map_new(50,50);
-			TCOD_map_t map2 = TCOD_map_new(10,10);
-			TCOD_map_set_properties(map,10,10,true,true);
-			TCOD_map_copy(map,map2);
-		@PyEx 
-			map = libtcod.map_new(50,50)
-			map2 = libtcod.map_new(10,10)
-			libtcod.map_set_properties(map,10,10,True,True)
-			libtcod.map_copy(map,map2)
-		*/		
-		void copy (const TCODMap *source);
-
-		/**
-		@PageName fov_compute
-		@PageTitle Computing the field of view
-		@PageFather fov
-		@FuncDesc Once your map is allocated and empty cells have been defined, you can calculate the field of view with :
-			<div class="code"><pre>typedef enum { FOV_BASIC, 
-               FOV_DIAMOND, 
-               FOV_SHADOW, 
-               FOV_PERMISSIVE_0,FOV_PERMISSIVE_1,FOV_PERMISSIVE_2,FOV_PERMISSIVE_3,
-               FOV_PERMISSIVE_4,FOV_PERMISSIVE_5,FOV_PERMISSIVE_6,FOV_PERMISSIVE_7,FOV_PERMISSIVE_8, 
-               FOV_RESTRICTIVE,
-               NB_FOV_ALGORITHMS } TCOD_fov_algorithm_t;
-            </pre></div>
-			* FOV_BASIC : classic libtcod fov algorithm (ray casted from the player to all the cells on the submap perimeter)
-			* FOV_DIAMOND : based on <a href="http://www.geocities.com/temerra/los_rays.html">this</a> algorithm
-			* FOV_SHADOW : based on <a href="http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting">this</a> algorithm
-			* FOV_PERMISSIVE_x : based on <a href="http://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View">this</a> algorithm
-			Permissive has a variable permissiveness parameter. You can either use the constants FOV_PERMISSIVE_x, x between 0 (the less permissive) and 8 (the more permissive), or using the macro FOV_PERMISSIVE(x). 
-			* FOV_RESTRICTIVE : Mingos' Restrictive Precise Angle Shadowcasting (MRPAS). Original implementation <a href="http://umbrarumregnum.110mb.com/download/mrpas">here</a>. Comparison of the algorithms :
-			Check <a href="http://roguecentral.org/libtcod/fov/fov.pdf">this</a>.
-		@Cpp void TCODMap::computeFov(int playerX,int playerY, int maxRadius=0,bool light_walls = true, TCOD_fov_algorithm_t algo = FOV_BASIC)
-		@C void TCOD_map_compute_fov(TCOD_map_t map, int player_x, int player_y, int max_radius, bool light_walls, TCOD_fov_algorithm_t algo)
-		@Py map_compute_fov(map, player_x, player_y, max_radius=0, light_walls=True, algo=FOV_BASIC )
-		@C# 
-			void TCODMap::computeFov(int playerX, int playerY)
-			void TCODMap::computeFov(int playerX, int playerY, int maxRadius)
-			void TCODMap::computeFov(int playerX, int playerY, int maxRadius,bool light_walls)
-			void TCODMap::computeFov(int playerX, int playerY, int maxRadius,bool light_walls, TCODFOVTypes algo)
-		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
-		@Param player_x,player_y	Position of the player in the map.
-			0 <= player_x < map width.
-			0 <= player_y < map height.
-		@Param maxRadius	If > 0, the fov is only computed up to maxRadius cells away from the player. Else, the range is unlimited.
-		@Param light_walls	Wether the wall cells near ground cells in fov must be in fov too.
-		@Param algo	FOV algorithm to use.
-		@CppEx 
-			TCODMap *map = new TCODMap(50,50); // allocate the map
-			map->setProperties(10,10,true,true); // set a cell as 'empty'
-			map->computeFov(10,10); // calculate fov from the cell 10x10 (basic raycasting, unlimited range, walls lighting on)
-		@CEx 
-			TCOD_map_t map = TCOD_map_new(50,50);
-			TCOD_map_set_properties(map,10,10,true,true);
-			TCOD_map_compute_fov(map,10,10,0,true,FOV_SHADOW); // using shadow casting
-		@PyEx 
-			map = libtcod.map_new(50,50)
-			libtcod.map_set_properties(map,10,10,True,True)
-			libtcod.map_compute_fov(map,10,10,0,True,libtcod.FOV_PERMISSIVE(2)) 
-		*/
-		void computeFov(int playerX,int playerY, int maxRadius = 0,bool light_walls = true, TCOD_fov_algorithm_t algo = FOV_BASIC);
-
-		/**
-		@PageName fov_get
-		@PageFather fov
-		@PageTitle Reading fov information
-		@FuncTitle Checking if a cell is in fov
-		@FuncDesc Once your computed the field of view, you can know if a cell is visible with :
-		@Cpp bool TCODMap::isInFov(int x, int y) const
-		@C bool TCOD_map_is_in_fov(TCOD_map_t map, int x, int y)
-		@Py map_is_in_fov(map, x, y)
-		@C# bool TCODMap::isInFov(int x, int y)
-		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
-		@Param x,y	Coordinates of the cell we want to check.
-			0 <= x < map width.
-			0 <= y < map height.
-		@CppEx 
-			TCODMap *map = new TCODMap(50,50); // allocate the map
-			map->setProperties(10,10,true,true); // set a cell as 'empty'
-			map->computeFov(10,10); // calculate fov from the cell 10x10
-			bool visible=map->isInFov(10,10); // is the cell 10x10 visible ?      
-		@CEx 
-			TCOD_map_t map = TCOD_map_new(50,50);
-			TCOD_map_set_properties(map,10,10,true,true);
-			TCOD_map_compute_fov(map,10,10);
-			bool visible = TCOD_map_is_in_fov(map,10,10);
-		@PyEx 
-			map = libtcod.map_new(50,50)
-			libtcod.map_set_properties(map,10,10,True,True)
-			libtcod.map_compute_fov(map,10,10)
-			visible = libtcod.map_is_in_fov(map,10,10)
-		*/		
-   		bool isInFov(int x,int y) const;
-   		/**
-   		@PageName fov_get
-   		@FuncTitle Checking a cell transparency/walkability
-   		@FuncDesc You can also retrieve transparent/walkable informations with :
-		@Cpp 
-			bool TCODMap::isTransparent(int x, int y) const
-			bool TCODMap::isWalkable(int x, int y) const
-		@C 
-			bool TCOD_map_is_transparent(TCOD_map_t map, int x, int y)
-			bool TCOD_map_is_walkable(TCOD_map_t map, int x, int y)
-		@Py 
-			map_is_transparent(map, x, y)
-			map_is_walkable(map, x, y)
-		@C# 
-			bool TCODMap::isTransparent(int x, int y)
-			bool TCODMap::isWalkable(int x, int y)
-		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
-		@Param x,y	Coordinates of the cell we want to check.
-			0 <= x < map width.
-			0 <= y < map height.
-		*/   		
-		bool isTransparent(int x, int y) const;
-		bool isWalkable(int x, int y) const;
-
-   		/**
-   		@PageName fov_get
-   		@FuncTitle Getting the map size
-   		@FuncDesc You can retrieve the map size with :
-		@Cpp 
-			int TCODMap::getWidth() const
-			int TCODMap::getHeight() const
-		@C 
-			int TCOD_map_get_width(TCOD_map_t map)
-			int TCOD_map_get_height(TCOD_map_t map)
-		@Py 
-			map_get_width(map)
-			map_get_height(map)
-		@C#
-			int TCODMap::getWidth()
-			int TCODMap::getHeight()
-		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
-		*/   		
-   		int getWidth() const;
-		int getHeight() const;
-
-		virtual ~TCODMap();
-		void setInFov(int x,int y, bool fov);
-		int getNbCells() const;
-		friend class TCODLIB_API TCODPath;
-		friend class TCODLIB_API TCODDijkstra;
-//	protected :
-		TCOD_map_t data;
-};
-
-#endif
--- a/include/heightmap.hpp
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifndef _TCOD_HEIGHTMAP_HPP
-#define _TCOD_HEIGHTMAP_HPP
-
-/**
- @PageName heightmap
- @PageCategory Roguelike toolkits
- @PageTitle Heightmap toolkit
- @PageDesc This toolkit allows to create a 2D grid of float values using various algorithms.
-
-The code using the heightmap toolkit can be automatically generated with the heightmap tool (hmtool) included in the libtcod package.
- */
-class TCODLIB_API TCODHeightMap {
-public :
-	int w,h;
-	float *values;
-
-	/**
-	@PageName heightmap_init
-	@PageFather heightmap
-	@PageTitle Creating a heightmap
-	@FuncTitle Creating an empty map
-	@FuncDesc As with other modules, you have to create a heightmap object first :
-		Note that whereas most other modules use opaque structs, the TCOD_heightmap_t fields can be freely accessed. Thus, the TCOD_heightmap_new function returns a TCOD_heightmap_t pointer, not a TCOD_heightmap_t. The w and h fields should not be modified after the heightmap creation. The newly created heightmap is filled with 0.0 values.
-	@Cpp TCODHeightMap::TCODHeightMap(int w, int h)
-	@C
-		typedef struct {
-			int w,h;
-			float *values;
-		} TCOD_heightmap_t;
-		TCOD_heightmap_t *TCOD_heightmap_new(int w,int h)
-	@Py heightmap_new(w,h)
-	@C# TCODHeightMap::TCODHeightMap(int w, int h)
-	@Param w,h	The width and height of the heightmap.
-	@CppEx TCODHeightMap myMap(50,50);
-	@CEx TCOD_heightmap_t *my_map=TCOD_heightmap_new(50,50);
-	@PyEx
-		map=libtcod.heightmap_new(50,50)
-		print map.w, map.h
-	*/
-	TCODHeightMap(int w, int h);
-
-	/**
-	@PageName heightmap_init
-	@FuncTitle Destroying a heightmap
-	@FuncDesc To release the resources used by a heightmap, destroy it with :
-	@Cpp TCODHeightMap::~TCODHeightMap()
-	@C void TCOD_heightmap_delete(TCOD_heightmap_t *hm)
-	@Py heightmap_delete(hm)
-	@C# void TCODHeightMap::Dispose()
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	*/
-	virtual ~TCODHeightMap();
-
-	/**
-	@PageName heightmap_base
-	@PageFather heightmap
-	@PageTitle Basic operations
-	@PageDesc Those are simple operations applied either on a single map cell or on every map cell.
-	@FuncTitle Setting a cell value
-	@FuncDesc Once the heightmap has been created, you can do some basic operations on the values inside it.
-		You can set a single value :
-	@Cpp void TCODHeightMap::setValue(int x, int y, float v)
-	@C void TCOD_heightmap_set_value(TCOD_heightmap_t *hm, int x, int y, float value)
-	@Py heightmap_set_value(hm, x, y, value)
-	@C# void TCODHeightMap::setValue(int x, int y, float v)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the cells to modify inside the map.
-		0 <= x < map width
-		0 <= y < map height
-	@Param value	The new value of the map cell.
-	*/
-	inline void setValue(int x, int y, float v) {
-		values[x+y*w]=v;
-	}
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Adding a float value to all cells
-	@Cpp void TCODHeightMap::add(float value)
-	@C void TCOD_heightmap_add(TCOD_heightmap_t *hm, float value)
-	@Py heightmap_add(hm, value)
-	@C# void TCODHeightMap::add(float value)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param value	Value to add to every cell.
-	*/
-	void add(float f);
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Multiplying all values by a float
-	@Cpp void TCODHeightMap::scale(float value)
-	@C void TCOD_heightmap_scale(TCOD_heightmap_t *hm, float value)
-	@Py heightmap_scale(hm, value)
-	@C# void TCODHeightMap::scale(float value)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param value	Every cell's value is multiplied by this value.
-	*/
-	void scale(float f);
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Resetting all values to 0.0
-	@Cpp void TCODHeightMap::clear()
-	@C void TCOD_heightmap_clear(TCOD_heightmap_t *hm)
-	@Py heightmap_clear(hm)
-	@C# void TCODHeightMap::clear()
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	*/
-	void clear(); // resets all values to 0.0
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Clamping all values
-	@Cpp void TCODHeightMap::clamp(float min, float max)
-	@C void TCOD_heightmap_clamp(TCOD_heightmap_t *hm, float min, float max)
-	@Py heightmap_clamp(hm, mi, ma)
-	@C# void TCODHeightMap::clamp(float min, float max)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param min,max	Every cell value is clamped between min and max.
-		min < max
-	*/
-	void clamp(float min, float max);
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Copying values from another heightmap
-	@Cpp void TCODHeightMap::copy(const TCODHeightMap *source)
-	@C void TCOD_heightmap_copy(const TCOD_heightmap_t *source,TCOD_heightmap_t *dest)
-	@Py heightmap_copy(source,dest)
-	@C# void TCODHeightMap::copy(TCODHeightMap source)
-	@Param source	Each cell value from the source heightmap is copied in the destination (this for C++) heightmap.
-		The source and destination heightmap must have the same width and height.
-	@Param dest	In the C and python versions, the address of the destination heightmap.
-	*/
-	void copy(const TCODHeightMap *source);
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Normalizing values
-	@Cpp void TCODHeightMap::normalize(float min=0.0f, float max=1.0f)
-	@C void TCOD_heightmap_normalize(TCOD_heightmap_t *hm, float min, float max)
-	@Py heightmap_normalize(hm, mi=0.0, ma=1.0)
-	@C#
-		void TCODHeightMap::normalize()
-		void TCODHeightMap::normalize(float min)
-		void TCODHeightMap::normalize(float min, float max)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param min,max	The whole heightmap is translated and scaled so that the lowest cell value becomes min and the highest cell value becomes max
-		min < max
-	*/
-	void normalize(float newMin=0.0f, float newMax=1.0f); // scales the values to the range [newMin;newMax]
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Doing a lerp operation between two heightmaps
-	@Cpp void TCODHeightMap::lerp(const TCODHeightMap *a, const TCODHeightMap *b,float coef)
-	@C void TCOD_heightmap_lerp_hm(const TCOD_heightmap_t *a, const TCOD_heightmap_t *b, TCOD_heightmap_t *res, float coef)
-	@Py heightmap_lerp_hm(a, b, res, coef)
-	@C# void TCODHeightMap::lerp(TCODHeightMap a, TCODHeightMap b, float coef)
-	@Param a	First heightmap in the lerp operation.
-	@Param b	Second heightmap in the lerp operation.
-	@Param coef	lerp coefficient.
-		For each cell in the destination map (this for C++), value = a.value + (b.value - a.value) * coef
-	@Param res	In the C and python versions, the address of the destination heightmap.
-	*/
-	void lerp(const TCODHeightMap *a, const TCODHeightMap *b,float coef);
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Adding two heightmaps
-	@Cpp void TCODHeightMap::add(const TCODHeightMap *a, const TCODHeightMap *b)
-	@C void TCOD_heightmap_add_hm(const TCOD_heightmap_t *a, const TCOD_heightmap_t *b, TCOD_heightmap_t *res)
-	@Py heightmap_add_hm(a, b, res)
-	@C# void TCODHeightMap::add(TCODHeightMap a, TCODHeightMap b)
-	@Param a	First heightmap.
-	@Param b	Second heightmap. For each cell in the destination map (this for C++), value = a.value + b.value
-	@Param res	In the C and python versions, the address of the destination heightmap.
-	*/
-	void add(const TCODHeightMap *a, const TCODHeightMap *b);
-
-	/**
-	@PageName heightmap_base
-	@FuncTitle Multiplying two heightmaps
-	@Cpp void TCODHeightMap::multiply(const TCODHeightMap *a, const TCODHeightMap *b)
-	@C void TCOD_heightmap_multiply_hm(const TCOD_heightmap_t *a, const TCOD_heightmap_t *b, TCOD_heightmap_t *res)
-	@Py heightmap_multiply_hm(a, b, res)
-	@C# void TCODHeightMap::multiply(TCODHeightMap a, TCODHeightMap b)
-	@Param a	First heightmap.
-	@Param b	Second heightmap. For each cell in the destination map (this for C++), value = a.value * b.value
-	@Param res	In the C and python versions, the address of the destination heightmap.
-	*/
-	void multiply(const TCODHeightMap *a, const TCODHeightMap *b);
-
-	/**
-	@PageName heightmap_modify
-	@PageFather heightmap
-	@PageTitle Modifying the heightmap
-	@PageDesc Those are advanced operations involving several or all map cells.
-	@FuncTitle Add hills
-	@FuncDesc This function adds a hill (a half spheroid) at given position.
-	@Cpp void TCODHeightMap::addHill(float x, float y, float radius, float height)
-	@C void TCOD_heightmap_add_hill(TCOD_heightmap_t *hm, float x, float y, float radius, float height)
-	@Py heightmap_add_hill(hm, x, y, radius, height)
-	@C# void TCODHeightMap::addHill(float x, float y, float radius, float height)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the center of the hill.
-		0 <= x < map width
-		0 <= y < map height
-	@Param radius	The hill radius.
-	@Param height	The hill height. If height == radius or -radius, the hill is a half-sphere.
-	*/
-	void addHill(float x, float y, float radius, float height); // adds a hill (half sphere) at given position
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Dig hills
-	@FuncDesc This function takes the highest value (if height > 0) or the lowest (if height < 0) between the map and the hill.
-		It's main goal is to carve things in maps (like rivers) by digging hills along a curve.
-	@Cpp void TCODHeightMap::digHill(float hx, float hy, float hradius, float height)
-	@C void TCOD_heightmap_dig_hill(TCOD_heightmap_t *hm, float x, float y, float radius, float height)
-	@Py heightmap_dig_hill(hm, x, y, radius, height)
-	@C# void TCODHeightMap::digHill(float hx, float hy, float hradius, float height)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the center of the hill.
-		0 <= x < map width
-		0 <= y < map height
-	@Param radius	The hill radius.
-	@Param height	The hill height. Can be < 0 or > 0
-	*/
-	void digHill(float hx, float hy, float hradius, float height);
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Simulate rain erosion
-	@FuncDesc This function simulates the effect of rain drops on the terrain, resulting in erosion patterns.
-	@Cpp void TCODHeightMap::rainErosion(int nbDrops,float erosionCoef,float sedimentationCoef,TCODRandom *rnd)
-	@C void TCOD_heightmap_rain_erosion(TCOD_heightmap_t *hm, int nbDrops,float erosionCoef,float sedimentationCoef,TCOD_random_t rnd)
-	@Py heightmap_rain_erosion(hm, nbDrops,erosionCoef,sedimentationCoef,rnd=0)
-	@C# void TCODHeightMap::rainErosion(int nbDrops, float erosionCoef, float sedimentationCoef, TCODRandom rnd)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param nbDrops	Number of rain drops to simulate. Should be at least width * height.
-	@Param erosionCoef	Amount of ground eroded on the drop's path.
-	@Param sedimentationCoef	Amount of ground deposited when the drops stops to flow
-	@Param rnd	RNG to use, NULL for default generator.
-	*/
-	void rainErosion(int nbDrops,float erosionCoef,float sedimentationCoef,TCODRandom *rnd);
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Do a generic transformation
-	@FuncDesc This function allows you to apply a generic transformation on the map, so that each resulting cell value is the weighted sum of several neighbour cells. This can be used to smooth/sharpen the map. See examples below for a simple horizontal smoothing kernel : replace value(x,y) with 0.33*value(x-1,y) + 0.33*value(x,y) + 0.33*value(x+1,y).To do this, you need a kernel of size 3 (the sum involves 3 surrounding cells). The dx,dy array will contain :
-	dx=-1,dy = 0 for cell x-1,y
-	dx=1,dy=0 for cell x+1,y
-	dx=0,dy=0 for current cell (x,y)
-	The weight array will contain 0.33 for each cell.
-	@Cpp void TCODHeightMap::kernelTransform(int kernelSize, int *dx, int *dy, float *weight, float minLevel,float maxLevel)
-	@C void TCOD_heightmap_kernel_transform(TCOD_heightmap_t *hm, int kernelsize, int *dx, int *dy, float *weight, float minLevel,float maxLevel)
-	@Py heightmap_kernel_transform(hm, kernelsize, dx, dy, weight, minLevel,maxLevel)
-	@C# void TCODHeightMap::kernelTransform(int kernelSize, int[] dx, int[] dy, float[] weight, float minLevel, float maxLevel)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-		kernelSize	Number of neighbour cells involved.
-	@Param dx,dy	Array of kernelSize cells coordinates. The coordinates are relative to the current cell (0,0) is current cell, (-1,0) is west cell, (0,-1) is north cell, (1,0) is east cell, (0,1) is south cell, ...
-	@Param weight	Array of kernelSize cells weight. The value of each neighbour cell is scaled by its corresponding weight
-	@Param minLevel	The transformation is only applied to cells which value is >= minLevel.
-	@Param maxLevel	The transformation is only applied to cells which value is <= maxLevel.
-	@CEx
-		int dx [] = {-1,1,0};
-		int dy[] = {0,0,0};
-		float weight[] = {0.33f,0.33f,0.33f};
-		TCOD_heightMap_kernel_transform(heightmap,3,dx,dy,weight,0.0f,1.0f);
-	@CppEx
-		int dx [] = {-1,1,0};
-		int dy[] = {0,0,0};
-		float weight[] = {0.33f,0.33f,0.33f};
-		heightmap->kernelTransform(heightmap,3,dx,dy,weight,0.0f,1.0f);
-	*/
-	void kernelTransform(int kernelSize, const int *dx, const int *dy, const float *weight, float minLevel,float maxLevel);
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Add a Voronoi diagram
-	@FuncDesc This function adds values from a Voronoi diagram to the map.
-	@Cpp void TCODHeightMap::addVoronoi(int nbPoints, int nbCoef, float *coef,TCODRandom *rnd)
-	@C void TCOD_heightmap_add_voronoi(TCOD_heightmap_t *hm, int nbPoints, int nbCoef, float *coef,TCOD_random_t rnd)
-	@Py heightmap_add_voronoi(hm, nbPoints, nbCoef, coef,rnd=0)
-	@C# void TCODHeightMap::addVoronoi(int nbPoints, int nbCoef, float[] coef, TCODRandom rnd)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param nbPoints	Number of Voronoi sites.
-	@Param nbCoef	The diagram value is calculated from the nbCoef closest sites.
-	@Param coef	The distance to each site is scaled by the corresponding coef.
-		Closest site : coef[0], second closest site : coef[1], ...
-	@Param rnd	RNG to use, NULL for default generator.
-	*/
-	void addVoronoi(int nbPoints, int nbCoef, const float *coef,TCODRandom *rnd);
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Add a fbm
-		This function adds values from a simplex fbm function to the map.
-	@Cpp void TCODHeightMap::addFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
-	@C void TCOD_heightmap_add_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
-	@Py heightmap_add_fbm(hm, noise,mulx, muly, addx, addy, octaves, delta, scale)
-	@C# void TCODHeightMap::addFbm(TCODNoise noise, float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param noise	The 2D noise to use.
-	@Param mulx, muly / addx, addy	The noise coordinate for map cell (x,y) are (x + addx)*mulx / width , (y + addy)*muly / height.
-		Those values allow you to scale and translate the noise function over the heightmap.
-	@Param octaves	Number of octaves in the fbm sum.
-	@Param delta / scale	The value added to the heightmap is delta + noise * scale.
-	@Param noise is between -1.0 and 1.0
-	*/
-	void addFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale);
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Scale with a fbm
-	@FuncDesc This function works exactly as the previous one, but it multiplies the resulting value instead of adding it to the heightmap.
-	@Cpp void TCODHeightMap::scaleFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
-	@C void TCOD_heightmap_scale_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
-	@Py heightmap_scale_fbm(hm, noise,mulx, muly, addx, addy, octaves, delta, scale)
-	@C# void TCODHeightMap::scaleFbm(TCODNoise noise, float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
-	*/
-	void scaleFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale);
-
-	/**
-	@PageName heightmap_modify
-	@FuncTitle Dig along a Bezier curve
-	@FuncDesc This function carve a path along a cubic Bezier curve using the digHill function.
-		Could be used for roads/rivers/...
-		Both radius and depth can vary linearly along the path.
-	@Cpp void TCODHeightMap::digBezier(int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth)
-	@C void TCOD_heightmap_dig_bezier(TCOD_heightmap_t *hm, int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth)
-	@Py heightmap_dig_bezier(hm, px, py,  startRadius,  startDepth, endRadius, endDepth)
-	@C# void TCODHeightMap::digBezier(int[] px, int[] py, float startRadius, float startDepth, float endRadius, float endDepth)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param px,py	The coordinates of the 4 Bezier control points.
-	@Param startRadius	The path radius in map cells at point P0. Might be < 1.0
-	@Param startDepth	The path depth at point P0.
-	@Param endRadius	The path radius in map cells at point P3. Might be < 1.0
-	@Param endDepth	The path depth at point P3.
-	*/
-	void digBezier(int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth);
-
-	/**
-	@PageName heightmap_read
-	@PageFather heightmap
-	@PageTitle Reading data from the heightmap
-	@PageDesc Those functions return raw or computed information about the heightmap.
-	@FuncTitle Get the value of a cell
-	@FuncDesc This function returns the height value of a map cell.
-	@Cpp float TCODHeightMap::getValue(int x, int y) const
-	@C float TCOD_heightmap_get_value(const TCOD_heightmap_t *hm, int x, int y)
-	@Py heightmap_get_value(hm,  x, y)
-	@C# float TCODHeightMap::getValue(int x, int y)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the map cell.
-		0 <= x < map width
-		0 <= y < map height
-	*/
-	inline float getValue(int x, int y) const {
-		return values[x+y*w];
-	}
-
-	/**
-	@PageName heightmap_read
-	@FuncTitle  Interpolate the height
-	@FuncDesc This function returns the interpolated height at non integer coordinates.
-	@Cpp float TCODHeightMap::getInterpolatedValue(float x, float y) const
-	@C float TCOD_heightmap_get_interpolated_value(const TCOD_heightmap_t *hm, float x, float y)
-	@Py heightmap_get_interpolated_value(hm, x, y)
-	@C# float TCODHeightMap::getInterpolatedValue(float x, float y)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the map cell.
-		0 <= x < map width
-		0 <= y < map height
-	*/
-	float getInterpolatedValue(float x, float y) const;
-
-	/**
-	@PageName heightmap_read
-	@FuncTitle Get the map slope
-	@FuncDesc This function returns the slope between 0 and PI/2 at given coordinates.
-	@Cpp float TCODHeightMap::getSlope(int x, int y) const
-	@C float TCOD_heightmap_get_slope(const TCOD_heightmap_t *hm, int x, int y)
-	@Py heightmap_get_slope(hm, x, y)
-	@C# float TCODHeightMap::getSlope(int x, int y)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the map cell.
-		0 <= x < map width
-		0 <= y < map height
-	*/
-	float getSlope(int x, int y) const; // returns the slope in radian between 0 and PI/2
-
-	/**
-	@PageName heightmap_read
-	@FuncTitle Get the map normal
-	@FuncDesc This function returns the map normal at given coordinates.
-	@Cpp void TCODHeightMap::getNormal(float x, float y,float n[3], float waterLevel=0.0f) const
-	@C void TCOD_heightmap_get_normal(const TCOD_heightmap_t *hm, float x, float y, float n[3], float waterLevel)
-	@Py heightmap_get_normal(hm, x, y, waterLevel) # returns nx,ny,nz
-	@C# void TCODHeightMap::getNormal(float x, float y, float[] n, float waterLevel)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param x,y	Coordinates of the map cell.
-		0 <= x < map width
-		0 <= y < map height
-	@Param n	The function stores the normalized normal vector in this array.
-	@Param waterLevel	The map height is clamped at waterLevel so that the sea is flat.
-	*/
-	void getNormal(float x, float y,float n[3], float waterLevel=0.0f) const; // returns the surface normal or (0,0,1) if beyond water level.
-
-	/**
-	@PageName heightmap_read
-	@FuncTitle Count the map cells inside a height range
-	@FuncDesc This function returns the number of map cells which value is between min and max.
-	@Cpp int TCODHeightMap::countCells(float min,float max) const
-	@C int TCOD_heightmap_count_cells(const TCOD_heightmap_t *hm, float min, float max)
-	@Py heightmap_count_cells(hm, min, max)
-	@C# int TCODHeightMap::countCells(float min, float max)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param min,max	Only cells which value is >=min and <= max are counted.
-	*/
-	int countCells(float min,float max) const;
-
-	/**
-	@PageName heightmap_read
-	@FuncTitle Check if the map is an island
-	@FuncDesc This function checks if the cells on the map border are below a certain height.
-	@Cpp bool TCODHeightMap::hasLandOnBorder(float waterLevel) const
-	@C bool TCOD_heightmap_has_land_on_border(const TCOD_heightmap_t *hm, float waterLevel)
-	@Py heightmap_has_land_on_border(hm, waterLevel)
-	@C# bool TCODHeightMap::hasLandOnBorder(float waterLevel)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param waterLevel	Return true only if no border cell is > waterLevel.
-	*/
-	bool hasLandOnBorder(float waterLevel) const;
-
-	/**
-	@PageName heightmap_read
-	@FuncTitle Get the map min and max values
-	@FuncDesc This function calculates the min and max of all values inside the map.
-	@Cpp void TCODHeightMap::getMinMax(float *min, float *max) const
-	@C void TCOD_heightmap_get_minmax(const TCOD_heightmap_t *hm, float *min, float *max)
-	@Py heightmap_get_minmax(hm) # returns min,max
-	@C# void TCODHeightMap::getMinMax(out float min, out float max)
-	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
-	@Param min, max	The min and max values are returned in these variables.
-	*/
-	void getMinMax(float *min, float *max) const;
-
-//	void heatErosion(int nbPass,float minSlope,float erosionCoef,float sedimentationCoef,TCODRandom *rnd);
-//	void midPointDeplacement(TCODRandom *rnd);
-	void islandify(float seaLevel,TCODRandom *rnd); // lowers the terrain near the heightmap borders
-	// TODO : checks island connectivity with floodfill
-private :
-//	void setMPDHeight(TCODRandom *rnd,int x,int y, float z, float offset);
-//	void setMDPHeightSquare(TCODRandom *rnd,int x, int y, int initsz, int sz,float offset);
-};
-
-#endif
--- a/include/image.hpp
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-class TCODLIB_API TCODImage {
-public :
-	/**
-	@PageName image
-	@PageTitle Image toolkit
-	@PageCategory Base toolkits
-	@PageDesc This toolkit contains some image manipulation utilities.	
-	*/	
-	
-	/**
-	@PageName image_create
-	@PageTitle Creating an image
-	@PageFather image
-	@FuncTitle Creating an empty image
-	@FuncDesc You can create an image of any size, filled with black with this function.
-	@Cpp TCODImage::TCODImage(int width, int height)
-	@C TCOD_image_t TCOD_image_new(int width, int height)
-	@Py image_new( width, height)
-	@C# TCODImage::TCODImage(int width, int height)
-	@Param width,height	Size of the image in pixels.
-	@CppEx TCODImage *pix = new TCODImage(80,50);
-	@CEx TCOD_image_t pix = TCOD_image_new(80,50);
-	@PyEx pix = litbcod.image_new(80,50)	
-	*/	
-	TCODImage(int width, int height);
-
-	/**
-	@PageName image_create
-	@FuncTitle Loading a .bmp or .png image
-	@FuncDesc You can read data from a .bmp or .png file (for example to draw an image using the background color of the console cells).
-		Note that only 24bits and 32bits PNG files are currently supported.
-	@Cpp TCODImage::TCODImage(const char *filename)
-	@C TCOD_image_t TCOD_image_load(const char *filename)
-	@Py image_load(filename)
-	@C# TCODImage::TCODImage(string filename)
-	@Param filename Name of the .bmp or .png file to load.
-	@CppEx TCODImage *pix = new TCODImage("mypic.bmp");
-	@CEx TCOD_image_t pix = TCOD_image_load("mypic.bmp");
-	@PyEx pix = libtcod.image_load("mypic.bmp")	
-	*/	
-	TCODImage(const char *filename);
-	
-	/**
-	@PageName image_create
-	@FuncTitle Creating an image from a console
-	@FuncDesc You can create an image from any console (either the root console or an offscreen console).
-		The image size will depend on the console size and the font characters size.
-		You can then save the image to a file with the save function.
-	@Cpp TCODImage::TCODImage(const TCODConsole *console)
-	@C TCOD_image_t TCOD_image_from_console(TCOD_console_t console)
-	@Py image_from_console(console)
-	@C# TCODImage::TCODImage(TCODConsole console)
-	@Param console The console to convert. In the C version, use NULL for the root console.
-	@CppEx TCODImage *pix = new TCODImage(TCODConsole::root);
-	@CEx TCOD_image_t pix = TCOD_image_from_console(NULL);
-	@PyEx pix = libtcod.image_from_console(0)
-	*/	
-	TCODImage(const TCODConsole *console);
-	
-	/**
-	@PageName image_create
-	@FuncTitle refreshing an image created from a console
-	@FuncDesc If you need to refresh the image with the console's new content, you don't have to delete it and create another one. Instead, use this function. Note that you must use the same console that was used in the TCOD_image_from_console call (or at least a console with the same size).
-	@Cpp void TCODImage::refreshConsole(const TCODConsole *console)
-	@C void TCOD_image_refresh_console(TCOD_image_t image, TCOD_console_t console)
-	@Py image_refresh_console(image, console)
-	@C# void TCODImage::refreshConsole(TCODConsole console)
-	@Param image In the C version, the image created with TCOD_image_from_console.
-	@Param console The console to capture. In the C version, use NULL for the root console.
-	@CppEx 
-		TCODImage *pix = new TCODImage(TCODConsole::root); // create an image from the root console
-		// ... modify the console
-		pix->refreshConsole(TCODConsole::root); // update the image with the console's new content
-	@CEx 
-		TCOD_image_t pix = TCOD_image_from_console(NULL);
-		// ... modify the console .. 
-		TCOD_image_refresh_console(pix,NULL);
-	@PyEx 
-		pix = libtcod.image_from_console(0)
-		# ... modify the console .. 
-		libtcod.image_refresh_console(pix,0)
-	*/
-	void refreshConsole(const TCODConsole *console);
-
-	/**
-	@PageName image_read
-	@PageTitle Reading data from a TCODImage
-	@PageFather image
-	@FuncTitle Getting the size of an image
-	@FuncDesc You can read the size of an image in pixels with this function.
-	@Cpp void TCODImage::getSize(int *w,int *h) const
-	@C void TCOD_image_get_size(TCOD_image_t image, int *w,int *h)
-	@Py image_get_size(image) # returns w,h
-	@C# void TCODImage::getSize(out int w, out int h)
-	@Param image In the C version, the image handler, obtained with the load function.
-	@Param w,h When the function returns, those variables contain the size of the image.
-	@CppEx 
-		TCODImage *pix = new TCODImage(80,50);
-		int w,h;
-		pix->getSize(&w,&h); // w = 80, h = 50
-	@CEx 
-		TCOD_image_t pix = TCOD_image_new(80,50);
-		int w,h;
-		TCOD_image_get_size(pix,&w,&h); // w = 80, h = 50
-	@PyEx 
-		pix = libtcod.image_new(80,50)
-		w,h=libtcod.image_get_size(pix)
-		# w = 80, h = 50 
-	*/		
-	void getSize(int *w,int *h) const;
-
-	/**
-	@PageName image_read
-	@FuncTitle Getting the color of a pixel
-	@FuncDesc You can read the colors from an image with this function.
-	@Cpp TCODColor TCODImage::getPixel(int x, int y) const
-	@C TCOD_color_t TCOD_image_get_pixel(TCOD_image_t image,int x, int y)
-	@Py image_get_pixel(image, x, y)
-	@C# TCODColor TCODImage::getPixel(int x, int y)
-	@Param image In the C and python version, the image handler, obtained with the load function.
-	@Param x,y The pixel coordinates inside the image.
-		0 <= x < width
-		0 <= y < height
-	@CppEx 
-		TCODImage *pix = new TCODImage(80,50);
-		TCODColor col=pix->getPixel(40,25);
-	@CEx 
-		TCOD_image_t pix = TCOD_image_new(80,50);
-		TCOD_color_t col=TCOD_image_get_pixel(pix,40,25);
-	@PyEx 
-		pix = litbcod.image_new(80,50)
-		col=litbcod.image_get_pixel(pix,40,25)
-	*/
-	TCODColor getPixel(int x, int y) const;
-
-	/**
-	@PageName image_read
-	@FuncTitle Getting the alpha value of a pixel
-	@FuncDesc If you have set a key color for this image with setKeyColor, or if this image was created from a 32 bits PNG file (with alpha layer), you can get the pixel transparency with this function. This function returns a value between 0 (transparent pixel) and 255 (opaque pixel).
-	@Cpp int TCODImage::getAlpha(int x, int y) const
-	@C int TCOD_image_get_alpha(TCOD_image_t image, int x, int y)
-	@Py image_get_alpha(image, x, y)
-	@C# int TCODImage::getAlpha(int x, int y)
-	@Param image In the C and python version, the image handler, obtained with the load function.
-	@Param x,y The pixel coordinates inside the image.
-		0 <= x < width
-		0 <= y < height
-	*/
-	int getAlpha(int x,int y) const;
-
-	/**
-	@PageName image_read
-	@FuncTitle Checking if a pixel is transparent
-	@FuncDesc You can use this simpler version (for images with alpha layer, returns true only if alpha == 0) :
-	@Cpp bool TCODImage::isPixelTransparent(int x,int y) const
-	@C bool TCOD_image_is_pixel_transparent(TCOD_image_t image,int x, int y)
-	@Py image_is_pixel_transparent(image, x, y)
-	@C# bool TCODImage::isPixelTransparent(int x,int y)
-	@Param image In the C and python version, the image handler, obtained with the load function.
-	@Param x,y The pixel coordinates inside the image.
-		0 <= x < width
-		0 <= y < height
-	*/
-   	bool isPixelTransparent(int x, int y) const;
-
-	/**
-	@PageName image_read
-	@FuncTitle Getting the average color of a part of the image
-	@FuncDesc This method uses mipmaps to get the average color of an arbitrary rectangular region of the image.
-		It can be used to draw a scaled-down version of the image. It's used by libtcod's blitting functions.
-	@Cpp TCODColor TCODImage::getMipmapPixel(float x0,float y0, float x1, float y1)
-	@C TCOD_color_t TCOD_image_get_mipmap_pixel(TCOD_image_t image,float x0,float y0, float x1, float y1)
-	@Py image_get_mipmap_pixel(image,x0,y0, x1, y1)
-	@C# TCODColor TCODImage::getMipmapPixel(float x0,float y0, float x1, float y1)
-	@Param image	In the C version, the image handler, obtained with the load function.
-	@Param x0,y0	Coordinates in pixels of the upper-left corner of the region.
-		0.0 <= x0 < x1
-		0.0 <= y0 < y1
-	@Param x1,y1	Coordinates in pixels of the lower-right corner of the region.
-		x0 < x1 < width
-		y0 < y1 < height
-	@CppEx 
-		// Get the average color of a 5x5 "superpixel" in the center of the image.
-		TCODImage *pix = new TCODImage(80,50);
-		TCODColor col=pix->getMipMapPixel(37.5f, 22.5f, 42.5f, 28.5f);
-	@CEx 
-		TCOD_image_t pix = TCOD_image_new(80,50);
-		TCOD_color_t col=TCOD_image_get_mipmap_pixel(pix,37.5f, 22.5f, 42.5f, 28.5f);
-	@PyEx
-		pix = libtcod.image_new(80,50)
-		col=libtcod.image_get_mipmap_pixel(pix,37.5, 22.5, 42.5, 28.5)
-	*/
-   	TCODColor getMipmapPixel(float x0,float y0, float x1, float y1);
-
-	/**
-	@PageName image_update
-	@PageTitle Updating an image
-	@PageFather image
-	@FuncTitle Filling an image with a color
-	@FuncDesc You can fill the whole image with a color with :
-	@Cpp void TCODImage::clear(const TCODColor color)
-	@C void TCOD_image_clear(TCOD_image_t image, TCOD_color_t color)
-	@Py image_clear(image,color)
-	@C# void TCODImage::clear(TCODColor color)
-	@Param image	In the C and python version, the image to fill.
-	@Param color	The color to use.
-	*/
-	void clear(const TCODColor col);
-
-	/**
-	@PageName image_update
-	@FuncTitle 	Changing the color of a pixel
-	@Cpp TCODColor TCODImage::putPixel(int x, int y, const TCODColor col)
-	@C void TCOD_image_put_pixel(TCOD_image_t image,int x, int y,TCOD_color_t col)
-	@Py image_put_pixel(image,x, y,col)
-	@C# TCODColor TCODImage::putPixel(int x, int y, TCODColor col)
-	@Param image	In the C version, the image handler, obtained with the load function.
-	@Param x,y	The pixel coordinates inside the image.
-		0 <= x < width
-		0 <= y < height
-	@Param col	The new color of the pixel.
-	*/
-	void putPixel(int x, int y, const TCODColor col);
-	
-	/**
-	@PageName image_update
-	@FuncTitle Scaling an image
-	@FuncDesc You can resize an image and scale its content. If neww < oldw or newh < oldh, supersampling is used to scale down the image. Else the image is scaled up using nearest neightbor.
-	@Cpp void TCODImage::scale(int neww, int newh)
-	@C void TCOD_image_scale(TCOD_image_t image,int neww, int newh)
-	@Py image_scale(image, neww,newh)
-	@C# void TCODImage::scale(int neww, int newh)
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	@Param neww,newh	The new size of the image.
-	*/
-	void scale(int neww, int newh);
-
-	/**
-	@PageName image_update
-	@FuncTitle Flipping the image horizontally
-	@Cpp void TCODImage::hflip()
-	@C void TCOD_image_hflip(TCOD_image_t image)
-	@Py image_hflip(image)
-	@C# void TCODImage::hflip()
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	*/
-	void hflip();
-
-    /**
-	@PageName image_update
-	@FuncTitle Flipping the image vertically
-	@Cpp void TCODImage::vflip()
-	@C void TCOD_image_vflip(TCOD_image_t image)
-	@Py image_vflip(image)
-	@C# void TCODImage::vflip()
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	*/
-	void vflip();
-
-    /**
-	@PageName image_update
-	@FuncTitle Rotating the image clockwise
-	@FuncDesc Rotate the image clockwise by increment of 90 degrees. 
-	@Cpp void TCODImage::rotate90(int numRotations=1)
-	@C void TCOD_image_rotate90(TCOD_image_t image, int numRotations)
-	@Py image_rotate90(image, num=1)
-	@C# void TCODImage::rotate90(int numRotations)
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	@Param numRotations	Number of 90 degrees rotations. Should be between 1 and 3.
-	*/
-	void rotate90(int numRotations=1);
-
-    /**
-	@PageName image_update
-	@FuncTitle Inverting the colors of the image
-	@Cpp void TCODImage::invert()
-	@C void TCOD_image_invert(TCOD_image_t image)
-	@Py image_invert(image)
-	@C# void TCODImage::invert()
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	*/
-	void invert();
-
-	/**
-	@PageName image_save
-	@PageFather image
-	@PageTitle Saving an image to a bmp or png file.
-	@PageDesc You can save an image to a 24 bits .bmp or .png file.
-	@Cpp void TCODImage::save(const char *filename)
-	@C void TCOD_image_save(TCOD_image_t image, const char *filename)
-	@Py image_save(image, filename)
-	@C# void TCODImage::save(string filename)
-	@Param image	In the C version, the image handler, obtained with any image creation function.
-	@Param filename	Name of the .bmp or .png file.
-	@CppEx 
-		TCODImage *pix = new TCODImage(10,10);
-		pix->save("mypic.bmp");
-	@CEx 
-		TCOD_image_t pix = TCOD_image_from_console(my_offscreen_console);
-		TCOD_image_save(pix,"mypic.bmp");
-	@PyEx 
-		pix = libtcod.image_from_console(my_offscreen_console)
-		libtcod.image_save(pix,"mypic.bmp")
-	  */	
-	void save(const char *filename) const;
-
-	/**
-	@PageName image_blit
-	@PageFather image
-	@PageTitle Blitting an image on a console
-	@FuncTitle Standard blitting
-	@FuncDesc This function blits a rectangular part of the image on a console without scaling it or rotating it. Each pixel of the image fills a console cell.
-	@Cpp void TCODImage::blitRect(TCODConsole *console, int x, int y, int w=-1, int h=-1, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET ) const
-	@C void TCOD_image_blit_rect(TCOD_image_t image, TCOD_console_t console, int x, int y, int w, int h, TCOD_bkgnd_flag_t bkgnd_flag)
-	@Py image_blit_rect(image, console, x, y, w, h, bkgnd_flag)
-	@C# 
-		void TCODImage::blitRect(TCODConsole console, int x, int y) 
-		void TCODImage::blitRect(TCODConsole console, int x, int y, int w)
-		void TCODImage::blitRect(TCODConsole console, int x, int y, int w, int h)
-		void TCODImage::blitRect(TCODConsole console, int x, int y, int w, int h, TCODBackgroundFlag bkgnd_flag)	
-	@Param image	In the C version, the image handler, obtained with the load function.
-	@Param console	The console on which the image will be drawn. In the C version, use NULL for the root console.
-	@Param x,y	Coordinates in the console of the upper-left corner of the image.
-	@Param w,h	Dimension of the image on the console. Use -1,-1 to use the image size.
-	@Param flag	This flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t.	
-	*/	
-	void blitRect(TCODConsole *console, int x, int y, int w=-1, int h=-1, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET ) const;
-	
-	/**
-	@PageName image_blit
-	@FuncTitle Blitting with scaling and/or rotation
-	@FuncDesc This function allows you to specify the floating point coordinates of the center
-		of the image, its scale and its rotation angle.
-	@Cpp void TCODImage::blit(TCODConsole *console, float x, float y, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET, float scalex=1.0f, float scaley=1.0f, float angle=0.0f) const
-	@C void TCOD_image_blit(TCOD_image_t image, TCOD_console_t console, int x, int y, TCOD_bkgnd_flag_t bkgnd_flag, float scalex, float scaley, float angle)
-	@Py image_blit(image, console, x, y, bkgnd_flag, scalex, scaley, angle)
-	@C#
-		void TCODImage::blit(TCODConsole console, float x, float y)
-		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag)
-		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag, float scalex)
-		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag, float scalex, float scaley)
-		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag, float scalex, float scaley, float angle)
-	@Param image	In the C version, the image handler, obtained with the load function.
-	@Param console	The console on which the image will be drawn. In the C version, use NULL for the root console.
-	@Param x,y	Coordinates in the console of the center of the image.
-	@Param flag	This flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t.
-	@Param scalex,scaley	Scale coefficient. Must be > 0.0.
-	@Param angle	Rotation angle in radians.
-	*/	
-	void blit(TCODConsole *console, float x, float y, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET, float scalex=1.0f, float scaley=1.0f, float angle=0.0f) const;
-	/**
-	@PageName image_blit
-	@FuncTitle Blitting with a mask
-	@FuncDesc When blitting an image, you can define a key color that will be ignored by the blitting function. This makes it possible to blit non rectangular images or images with transparent pixels.
-	@Cpp void TCODImage::setKeyColor(const TCODColor keyColor)
-	@C void TCOD_image_set_key_color(TCOD_image_t image, TCOD_color_t keyColor)
-	@Py image_set_key_color(image, keyColor)
-	@C# void TCODImage::setKeyColor(TCODColor keyColor)
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	@Param color	Pixels with this color will be skipped by blitting functions.
-	@CppEx 
-		TCODImage *pix = TCODImage("mypix.bmp");
-		pix->setKeyColor(TCODColor::red);
-		// blitting the image, omitting red pixels
-		pix->blitRect(TCODConsole::root,40,25);
-	@CEx 
-		TCOD_image_t pix = TCOD_image_new(10,10);
-		TCOD_image_set_key_color(pix,TCOD_red);
-		TCOD_image_blit_rect(pix,NULL,40,25,5,5,TCOD_BKGND_SET);
-	@PyEx 
-		pix = libtcod.image_new(10,10)
-		libtcod.image_set_key_color(pix,libtcod.red)
-		libtcod.image_blit_rect(pix,0,40,25,5,5,libtcod.BKGND_SET)
-	*/	
-	void setKeyColor(const TCODColor keyColor);
-	
-	/**
-	@PageName image_blit
-	@FuncTitle Blitting with subcell resolution
-	@FuncDesc Eventually, you can use some special characters in the libtcod fonts :
-		<img src="subcell.png">
-		to double the console resolution using this blitting function.
-		<table><tr><td> 
-		Comparison before/after subcell resolution in TCOD :<br /> 
-		<img src="subcell_comp.png"></td><td> 
-		Pyromancer ! screenshot, making full usage of subcell resolution :<br /> 
-		<img src="subcell_pyro.png"></td></tr></table>
-	@Cpp void TCODImage::blit2x(TCODConsole *dest, int dx, int dy, int sx=0, int sy=0, int w=-1, int h=-1 ) const;
-	@C void TCOD_image_blit_2x(TCOD_image_t image, TCOD_console_t dest, int dx, int dy, int sx, int sy, int w, int h);
-	@Py image_blit_2x(image, dest, dx, dy, sx=0, sy=0, w=-1, h=-1)
-	@C#
-		void TCODImage::blit2x(TCODConsole dest, int dx, int dy);
-		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx);
-		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx, int sy);
-		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx, int sy, int w);
-		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx, int sy, int w, int h);
-	@Param image	In the C and python version, the image handler, obtained with the load function.
-	@Param dest	The console of which the image will be blited. Foreground, background and character data will be overwritten.
-	@Param dx,dy	Coordinate of the console cell where the upper left corner of the blitted image will be.
-	@Param sx,sy,w,h	Part of the image to blit. Use -1 in w and h to blit the whole image.
-	*/	
-	void blit2x(TCODConsole *dest, int dx, int dy, int sx=0, int sy=0, int w=-1, int h=-1) const;
-
-	TCODImage(TCOD_image_t img) : data(img), deleteData(false) {}
-	virtual ~TCODImage();
-
-protected :
-	friend class TCODLIB_API TCODSystem;
-	friend class TCODLIB_API TCODZip;
-	void *data;
-	bool deleteData;
-};
-
--- a/include/lex.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_LEX_HPP
-#define _TCOD_LEX_HPP
-/*
- * This is a libtcod internal module.
- * Use at your own risks...
- */
- 
-class TCODLIB_API TCODLex {
-public :
-	TCODLex();
-	TCODLex( const char **symbols, const char **keywords, const char *simpleComment="//", 
-		const char *commentStart="/*", const char *commentStop="*/", const char *javadocCommentStart="/**", 
-		const char *stringDelim="\"", int flags=TCOD_LEX_FLAG_NESTING_COMMENT);
-	~TCODLex();
-
-	void setDataBuffer(char *dat);
-	bool setDataFile(const char *filename);
-
-	int parse(void);
-	int parseUntil(int tokenType);
-	int parseUntil(const char *tokenValue);
-
-	bool expect(int tokenType);
-	bool expect(int tokenType,const char *tokenValue);
-
-	void savepoint(TCODLex *savept);
-	void restore(TCODLex *savept);
-	char *getLastJavadoc();
-
-	int getFileLine() { return ((TCOD_lex_t *)data)->file_line; }
-	int getTokenType() { return ((TCOD_lex_t *)data)->token_type; }
-	int getTokenIntVal() { return ((TCOD_lex_t *)data)->token_int_val; }
-	int getTokenIdx() { return ((TCOD_lex_t *)data)->token_idx; }
-	float getTokenFloatVal() { return ((TCOD_lex_t *)data)->token_float_val; }
-	char *getToken() { return ((TCOD_lex_t *)data)->tok; }
-	char getStringLastDelimiter() { return ((TCOD_lex_t *)data)->lastStringDelim; }
-	char *getPos() { return ((TCOD_lex_t *)data)->pos; }
-	char *getBuf() { return ((TCOD_lex_t *)data)->buf; }
-	char *getFilename() { return ((TCOD_lex_t *)data)->filename; }
-	char *getLastJavadocComment() { return ((TCOD_lex_t *)data)->last_javadoc_comment; }
-	static const char *getTokenName(int tokenType) { return TCOD_lex_get_token_name(tokenType); }
-protected :
-	void *data;
-};
-
-#endif
--- /dev/null
+++ b/include/libtcod/bresenham.hpp
@@ -0,0 +1,138 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_BRESENHAM_HPP
+#define _TCOD_BRESENHAM_HPP
+class TCODLIB_API TCODLineListener {
+public :
+	virtual bool putPoint(int x,int y) = 0;
+	virtual ~TCODLineListener() {}
+};
+
+class TCODLIB_API TCODLine {
+public :
+	/**
+	@PageName line
+	@PageCategory Base toolkits
+	@PageTitle Line drawing toolkit
+	@PageDesc This toolkit is a very simple and lightweight implementation of the bresenham line drawing algorithm. It allows you to follow straight paths on your map very easily.
+	@FuncTitle Initializing the line
+	@FuncDesc First, you have to initialize the toolkit with your starting and ending coordinates.
+	@Cpp static void TCODLine::init (int xFrom, int yFrom, int xTo, int yTo)
+	@C void TCOD_line_init (int xFrom, int yFrom, int xTo, int yTo)
+	@Py line_init (xFrom, yFrom, xTo, yTo)
+	@C# static void TCODLine::init(int xFrom, int yFrom, int xTo, int yTo)
+	@Lua tcod.line.init(xFrom,yFrom, xTo,yTo)
+	@Param xFrom,yFrom Coordinates of the line's starting point.
+	@Param xTo,yTo Coordinates of the line's ending point.
+	*/
+	static void init(int xFrom, int yFrom, int xTo, int yTo);
+	
+	/**
+	@PageName line
+	@FuncTitle Walking the line
+	@FuncDesc You can then step through each cell with this function. It returns true when you reach the line's ending point.
+	@Cpp static bool TCODLine::step (int * xCur, int * yCur)
+	@C bool TCOD_line_step (int * xCur, int * yCur)
+	@Py line_step () # returns x,y or None,None if finished
+	@C# static bool TCODLine::step(ref int xCur, ref int yCur)
+	@Lua tcod.line.step(x,y) -- returns lineEnd,x,y
+	@Param xCur,yCur the coordinates of the next cell on the line are stored here when the function returns
+	@CppEx 
+		// Going from point 5,8 to point 13,4
+		int x = 5, y = 8;
+		TCODLine::init(x,y,13,4);
+		do {
+		    // update cell x,y
+		} while (!TCODLine::step(&x,&y));
+	@CEx 
+		int x = 5, y = 8;
+		TCOD_line_init(x,y,13,4);
+		do {
+		    // update cell x,y 
+		} while (!TCOD_line_step(&x,&y));
+	@PyEx 
+		libtcod.line_init(5,8,13,4)
+		# update cell 5,8
+		x,y=libtcod.line_step()
+		while (not x is None) :
+		    # update cell x,y
+		x,y=libtcod.line_step()
+	@LuaEx
+		x=5
+		y=8
+		tcod.line.init(x,y,13,4)
+		repeat
+			-- update cell x,y
+			lineEnd,x,y = tcod.line.step(x,y)
+		until lineEnd		
+	*/	
+	static bool step(int *xCur, int *yCur);
+
+	/**
+	@PageName line
+	@FuncTitle Callback-based function
+	@FuncDesc The function returns false if the line has been interrupted by the callback (it returned false before the last point).
+	@Cpp
+		class TCODLIB_API TCODLineListener {
+			virtual bool putPoint (int x, int y) = 0;
+		};
+		static bool TCODLine::line (int xFrom, int yFrom, int xTo, int yTo, TCODLineListener * listener)
+	@C
+		typedef bool (*TCOD_line_listener_t) (int x, int y);
+		bool TCOD_line(int xFrom, int yFrom, int xTo, int yTo, TCOD_line_listener_t listener)
+	@Py
+		def line_listener(x,y) : # ...
+		line(xFrom, yFrom, xTo, yTo, listener)
+	@C# static bool line(int xFrom, int yFrom, int xTo, int yTo, TCODLineListener listener)
+	@Param xFrom,yFrom	Coordinates of the line's starting point.
+	@Param xTo,yTo	Coordinates of the line's ending point.
+	@Param listener	Callback called for each line's point. The function stops if the callback returns false.
+	@CppEx // Going from point 5,8 to point 13,4
+class MyLineListener : public TCODLineListener {
+    public:
+    bool putPoint (int x,int y) {
+        printf ("%d %d\n",x,y);
+        return true;
+    }
+};
+MyLineListener myListener;
+TCODLine::line(5,8,13,4,&myListener);
+	@CEx bool my_listener(int x,int y) {
+    printf ("%d %d\n",x,y);
+    return true;
+}
+TCOD_line_line(5,8,13,4,my_listener);
+	@PyEx def my_listener(x,y):
+    print x,y
+    return True
+libtcod.line_line(5,8,13,4,my_listener)	 
+	*/
+	static bool line(int xFrom, int yFrom, int xTo, int yTo, TCODLineListener *listener);
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/bsp.hpp
@@ -0,0 +1,406 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_BSP_HPP
+#define _TCOD_BSP_HPP
+
+class TCODBsp;
+
+class TCODLIB_API ITCODBspCallback {
+public :
+	virtual ~ITCODBspCallback() {}
+	virtual bool visitNode(TCODBsp *node, void *userData) = 0;
+};
+
+/**
+ @PageName bsp
+ @PageCategory Roguelike toolkits
+ @PageTitle BSP toolkit
+ @PageDesc This toolkit allows to create and manipulate 2D Binary Space Partition trees. They can be used to split a rectangular region into non overlapping sub-regions.
+ */
+
+class TCODLIB_API TCODBsp : public TCODTree {
+public :
+	int x,y,w,h; // 
+	int position; // position of splitting
+	bool horizontal; // horizontal splitting ?
+	uint8 level; // level in the tree 
+	
+	/**
+	@PageName bsp_init
+	@PageFather bsp
+	@PageTitle Creating a BSP tree
+	@FuncTitle Creating the root node
+	@FuncDesc First, you have to create the root node of the tree. This node encompasses the whole rectangular region.
+	@Cpp TCODBsp::TCODBsp(int x,int y,int w, int h)
+	@C TCOD_bsp_t *TCOD_bsp_new_with_size(int x,int y,int w, int h)
+	@Py bsp_new_with_size(x,y,w, h)
+	@C# TCODBsp::TCODBsp(int x, int y, int w, int h)
+	@Param x,y,w,h	Top left corner position and size of the rectangular region covered by the BSP tree.
+	@CppEx TCODBsp *myBSP = new TCODBsp(0,0,50,50);
+	@CEx TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
+	@PyEx my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
+	*/
+	TCODBsp() : level(0) {}
+	TCODBsp(int x,int y,int w, int h) : x(x),y(y),w(w),h(h),level(0) {}
+
+	/**
+	@PageName bsp_init
+	@FuncTitle Deleting a part of the tree
+	@FuncDesc You can delete a part of the tree, releasing resources for all sub nodes with :
+	@Cpp void TCODBsp::removeSons()
+	@C void TCOD_bsp_remove_sons(TCOD_bsp_t *node)
+	@Py bsp_remove_sons(node)
+	@C# TCODBsp::removeSons()
+	@Param node	In the C version, the node reference.
+	@CppEx 
+		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
+		// create a tree
+		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
+		// clear it (keep only the root)
+		myBSP->removeSons();
+		// and rebuild another random tree
+		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
+	@CEx 
+		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
+		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
+		TCOD_bsp_remove_sons(my_bsp);
+		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
+	@PyEx 
+		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
+		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
+		libtcod.bsp_remove_sons(my_bsp)
+		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
+	*/
+	void removeSons();
+
+	/**
+	@PageName bsp_init
+	@FuncTitle deleting the tree
+	@FuncDesc You can also completely delete the tree, including the root node to release every resource used :
+	@Cpp void TCODBsp::~TCODBsp()
+	@C void TCOD_bsp_delete(TCOD_bsp_t *node)
+	@Py bsp_delete(node)
+	@C# void TCODBsp::Dispose()
+	@Param node	In the C version, the node reference.
+	@CppEx 
+		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
+		// create a tree
+		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
+		// use the tree ...
+		// delete the tree
+		delete myBSP; 
+	@CEx 
+		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
+		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
+		// use the tree ... 
+		TCOD_bsp_delete(my_bsp);
+	@PyEx 
+		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
+		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
+		# use the tree ...
+		libtcod.bsp_delete(my_bsp)
+	*/
+	virtual ~TCODBsp();
+
+	/**
+	@PageName bsp_split
+	@PageFather bsp
+	@PageTitle Splitting the tree
+	@FuncTitle Splitting a node once
+	@FuncDesc Once you have the root node, you can split it into two smaller non-overlapping nodes.
+	@Cpp void TCODBsp::splitOnce(bool horizontal, int position)
+	@C void TCOD_bsp_split_once(TCOD_bsp_t *node, bool horizontal, int position)
+	@Py bsp_split_once(node, horizontal, position)
+	@C# void TCODBsp::splitOnce(bool horizontal, int position)
+	@Param node	In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.
+	@Param horizontal	If true, the node will be splitted horizontally, else, vertically.
+	@Param position	Coordinate of the splitting position.
+		If horizontal is true, x <= position < x+w
+		Else, y <= position < y+h
+	@CppEx 
+		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
+		myBSP->splitOnce(true,20); // horizontal split into two nodes : (0,0,50,20) and (0,20,50,30)
+	@CEx 
+		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
+		TCOD_bsp_split_once(my_bsp,false,20); // vertical split into two nodes : (0,0,20,50) and (20,0,30,50)
+	@PyEx 
+		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
+		libtcod.bsp_split_once(my_bsp,False,20) # vertical split into two nodes : (0,0,20,50) and (20,0,30,50)
+	*/
+	void splitOnce(bool horizontal, int position);
+
+	/**
+	@PageName bsp_split
+	@FuncTitle Recursively splitting a node
+	@FuncDesc You can also recursively split the bsp. At each step, a random orientation (horizontal/vertical) and position are choosen :
+	@Cpp void TCODBsp::splitRecursive(TCODRandom *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio);
+	@C void TCOD_bsp_split_recursive(TCOD_bsp_t *node, TCOD_random_t randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)
+	@Py bsp_split_recursive(node, randomizer, nb, minHSize, minVSize, maxHRatio, maxVRatio)
+	@C# void TCODBsp::splitRecursive(TCODRandom randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio)
+	@Param node	In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.
+	@Param randomizer	The random number generator to use. Use NULL for the default one.
+	@Param nb	Number of recursion levels.
+	@Param minHSize, minVSize	minimum values of w and h for a node. A node is splitted only if the resulting sub-nodes are bigger than minHSize x minVSize
+	@Param maxHRatio, maxVRation	maximum values of w/h and h/w for a node. If a node does not conform, the splitting orientation is forced to reduce either the w/h or the h/w ratio. Use values near 1.0 to promote square nodes.
+	@CppEx 
+		// Do a 4 levels BSP tree (the region is splitted into a maximum of 2*2*2*2 sub-regions).
+		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
+		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
+	@CEx 
+		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
+		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
+	@PyEx 
+		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
+		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
+	*/
+	void splitRecursive(TCODRandom *randomizer, int nb, int minHSize, int minVSize, float maxHRatio, float maxVRatio);
+
+	/**
+	@PageName bsp_resize
+	@PageTitle Resizing a tree
+	@PageFather bsp
+	@FuncDesc This operation resets the size of the tree nodes without changing the splitting data (orientation/position). It should be called with the initial region size or a bigger size, else some splitting position may be out of the region.
+You can use it if you changed the nodes size and position while using the BSP tree, which happens typically when you use the tree to build a dungeon. You create rooms inside the tree leafs, then shrink the leaf to fit the room size. Calling resize on the root node with the original region size allows you to reset all nodes to their original size.
+	@Cpp void TCODBsp::resize(int x,int y, int w, int h)
+	@C void TCOD_bsp_resize(TCOD_bsp_t *node, int x,int y, int w, int h)
+	@Py bsp_resize(node,  x,y, w, h)
+	@C# void TCODBsp::resize(int x, int y, int w, int h)
+	@Param node	In the C version, the root node created with TCOD_bsp_new_with_size, or a node obtained by splitting.
+	@Param x,y,w,h	New position and size of the node. The original rectangular area covered by the node should be included in the new one to ensure that every splitting edge stay inside its node.
+	@CppEx 
+		// We create a BSP, do some processing that will modify the x,y,w,h fields of the tree nodes, then reset all the nodes to their original size.
+		TCODBsp *myBSP = new TCODBsp(0,0,50,50);
+		myBSP->splitRecursive(NULL,4,5,5,1.5f,1.5f); 
+		// ... do something with the tree here
+		myBSP->resize(0,0,50,50);
+	@CEx 
+		TCOD_bsp_t *my_bsp=TCOD_bsp_new_with_size(0,0,50,50);
+		TCOD_bsp_split_recursive(my_bsp,NULL,4,5,5,1.5f,1.5f);
+		// ... do something with the tree here 
+		TCOD_bsp_resize(my_bsp,0,0,50,50);
+	@PyEx 
+		my_bsp=libtcod.bsp_new_with_size(0,0,50,50)
+		libtcod.bsp_split_recursive(my_bsp,0,4,5,5,1.5,1.5)
+		# ... do something with the tree here 
+		libtcod.bsp_resize(my_bsp,0,0,50,50)
+	*/
+	void resize(int x,int y, int w, int h);
+
+	/**
+	@PageName bsp_read
+	@PageFather bsp
+	@PageTitle Reading information from the tree
+	@FuncDesc Once you have built a BSP tree, you can retrieve information from any node. The node gives you free access to its fields :
+	@Cpp 
+		class TCODBsp {
+		public :
+			int x,y,w,h; // 
+			int position; // position of splitting
+			bool horizontal; // horizontal splitting ?
+			uint8 level; // level in the tree 
+			...
+		}
+	@C 
+		typedef struct {
+			int x,y,w,h;
+			int position;
+			bool horizontal;
+			uint8 level;
+			...
+		} TCOD_bsp_t;
+	@C# 
+		class TCODBsp
+		{
+		  public int x { get; set; }
+		  public int y { get; set; }
+		  public int h { get; set; }
+		  public int w { get; set; }
+		  public int position { get; set; }
+		  public bool horizontal { get; set; }
+		  public byte level { get; set; }
+		}
+	@Param x,y,w,h	Rectangular region covered by this node.
+	@Param position	If this node is not a leaf, splitting position.
+	@Param horizontal	If this node is not a leaf, splitting orientation.
+	@Param level	Level in the BSP tree (0 for the root, 1 for the root's sons, ...).
+	*/
+
+	/**
+	@PageName bsp_read
+	@FuncTitle Navigate in the tree
+	@FuncDesc You can navigate from a node to its sons or its parent using one of those functions. Each function returns NULL if the corresponding node does not exists (if the node is not splitted for getLeft and getRight, and if the node is the root node for getFather).
+	@Cpp 
+		TCODBsp *TCODBsp::getLeft() const
+		TCODBsp *TCODBsp::getRight() const
+		TCODBsp *TCODBsp::getFather() const
+	@C 
+		TCOD_bsp_t * TCOD_bsp_left(TCOD_bsp_t *node)
+		TCOD_bsp_t * TCOD_bsp_right(TCOD_bsp_t *node)
+		TCOD_bsp_t * TCOD_bsp_father(TCOD_bsp_t *node)
+	@Py 
+		bsp_left(node)
+		bsp_right(node)
+		bsp_father(node)
+	@C# 
+		TCODBsp TCODBsp::getLeft()
+		TCODBsp TCODBsp::getRight()
+		TCODBsp TCODBsp::getFather()
+	@Param node	In the C version, the node reference.
+	*/
+	TCODBsp *getLeft() const {
+		return (TCODBsp *)sons;
+	}
+	TCODBsp *getRight() const {
+		return sons ? (TCODBsp *)(sons->next) : NULL;
+	}
+	TCODBsp *getFather() const {
+		return (TCODBsp *)father;
+	}
+
+	/**
+	@PageName bsp_read
+	@FuncTitle Checking if a node is a leaf
+	@FuncDesc You can know if a node is a leaf (not splitted, no sons) with this function :
+	@Cpp bool TCODBsp::isLeaf() const
+	@C bool TCOD_bsp_is_leaf(TCOD_bsp_t *node)
+	@Py bsp_is_leaf(node)
+	@C# bool TCODBsp::isLeaf()
+	*/
+	bool isLeaf() const { return sons == NULL ; }
+
+	/**
+	@PageName bsp_read
+	@FuncTitle Check if a cell is inside a node
+	@FuncDesc You can check if a map cell is inside a node.
+	@Cpp bool TCODBsp::contains(int cx, int cy) const
+	@C bool TCOD_bsp_contains(TCOD_bsp_t *node, int cx, int cy)
+	@Py bsp_contains(node, cx, cy)
+	@C# bool TCODBsp::contains(int x, int y)
+	@Param node	In the C version, the node reference.
+	@Param cx,cy	Map cell coordinates.
+	*/
+	bool contains(int x, int y) const;
+
+	/**
+	@PageName bsp_read
+	@FuncTitle Getting the node containing a cell
+	@FuncDesc You can search the tree for the smallest node containing a map cell. If the cell is outside the tree, the function returns NULL :
+	@Cpp TCODBsp *TCODBsp::findNode(int cx, int cy)
+	@C TCOD_bsp_t * TCOD_bsp_find_node(TCOD_bsp_t *node, int cx, int cy)
+	@Py bsp_find_node(node, cx, cy)
+	@C# TCODBsp TCODBsp::findNode(int x, int y)
+	@Param node	In the C version, the node reference.
+	@Param cx,cy	Map cell coordinates.
+	*/
+	TCODBsp *findNode(int x, int y);
+
+	/**
+	@PageName bsp_traverse
+	@PageFather bsp
+	@PageTitle Traversing the tree
+	@FuncDesc You can scan all the nodes of the tree and have a custom function called back for each node.
+		Each traversal function returns false if the traversal has been interrupted (a callback returned false).
+		* Pre-order : the callback is called for the current node, then for the left son, then for the right son.
+		* In-order : the callback is called for the left son, then for current node, then for the right son.
+		* Post-order : the callback is called for the left son, then for the right son, then for the current node.
+		* Level-order : the callback is called for the nodes level by level, from left to right.
+		* Inverted level-order : the callback is called in the exact inverse order as Level-order.
+		<table class="param">
+		<tbody><tr><th>Pre order</th><th>In order</th><th>Post order</th><th>Level order</th><th>Inverted level<br>order</th></tr>
+		<tr><td><img src="bsp_preorder.png"></td><td><img src="bsp_inorder.png"></td><td><img src="bsp_postorder.png"></td><td><img src="bsp_levelorder.png"></td><td><img src="bsp_invlevelorder.png"></td></tr>
+		</tbody></table>
+	@Cpp 
+		class ITCODBspCallback {
+		public :
+			virtual bool visitNode(TCODBsp *node, void *userData) = 0;
+		};
+		
+		bool TCODBsp::traversePreOrder(ITCODBspCallback *callback, void *userData)
+		bool TCODBsp::traverseInOrder(ITCODBspCallback *callback, void *userData)
+		bool TCODBsp::traversePostOrder(ITCODBspCallback *callback, void *userData)
+		bool TCODBsp::traverseLevelOrder(ITCODBspCallback *callback, void *userData)
+		bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback *callback, void *userData)
+	@C 
+		typedef bool (*TCOD_bsp_callback_t)(TCOD_bsp_t *node, void *userData)
+		
+		bool TCOD_bsp_traverse_pre_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
+		bool TCOD_bsp_traverse_in_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
+		bool TCOD_bsp_traverse_post_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
+		bool TCOD_bsp_traverse_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
+		bool TCOD_bsp_traverse_inverted_level_order(TCOD_bsp_t *node, TCOD_bsp_callback_t callback, void *userData)
+	@Py 
+		def bsp_callback(node, userData) : # ...
+		
+		bsp_traverse_pre_order(node, callback, userData=0)
+		bsp_traverse_in_order(node, callback, userData=0)
+		bsp_traverse_post_order(node, callback, userData=0)
+		bsp_traverse_level_order(node, callback, userData=0)
+		bsp_traverse_inverted_level_order(node, callback, userData=0)
+	@C#
+		bool TCODBsp::traversePreOrder(ITCODBspCallback callback)
+		bool TCODBsp::traverseInOrder(ITCODBspCallback callback)
+		bool TCODBsp::traversePostOrder(ITCODBspCallback callback)
+		bool TCODBsp::traverseLevelOrder(ITCODBspCallback callback)
+		bool TCODBsp::traverseInvertedLevelOrder(ITCODBspCallback callback)
+	@Param node	In the C version, the node reference (generally, the root node).
+	@Param callback	The function to call for each node.
+		It receives the current node and the custom data as parameters
+		If it returns false, the traversal is interrupted.
+	@Param userData	Custom data to pass to the callback.
+	@CppEx 
+		class MyCallback : public ITCODBspCallback {
+		public :
+			bool visitNode(TCODBsp *node, void *userData) {
+				printf("node pos %dx%d size %dx%d level %d\n",node->x,node->y,node->w,node->h,node->level);
+				return true;
+			}
+		};
+		myBSP->traversePostOrder(new MyListener(),NULL);
+	@CEx 
+		bool my_callback(TCOD_bsp_t *node, void *userData) {
+			printf("node pos %dx%d size %dx%d level %d\n",node->x,node->y,node->w,node->h,node->level);
+			return true;
+		}
+		TCOD_bsp_traverse_post_order(my_bsp,my_callback,NULL);
+	@PyEx 
+		def my_callback(node, userData) :
+			print "node pos %dx%d size %dx%d level %d"%(node.x,node.y,node.w,node.h,node.level))
+			return True
+		libtcod.bsp_traverse_post_order(my_bsp,my_callback)
+	*/
+	bool traversePreOrder(ITCODBspCallback *listener, void *userData);
+	bool traverseInOrder(ITCODBspCallback *listener, void *userData);
+	bool traversePostOrder(ITCODBspCallback *listener, void *userData);
+	bool traverseLevelOrder(ITCODBspCallback *listener, void *userData);
+	bool traverseInvertedLevelOrder(ITCODBspCallback *listener, void *userData);
+protected :
+	TCODBsp(TCODBsp *father, bool left);
+
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/color.hpp
@@ -0,0 +1,690 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_COLOR_HPP
+#define _TCOD_COLOR_HPP
+
+// color constants uses to generate @ColorTable
+/**
+	@ColorCategory STANDARD COLORS
+	@Color red 255,0,0
+	@Color flame 255,63,0
+	@Color orange 255,127,0
+	@Color amber 255,191,0
+	@Color yellow 255,255,0,
+	@Color lime 191,255,0
+	@Color chartreuse 127,255,0
+	@Color green 0,255,0
+	@Color sea 0,255,127
+	@Color turquoise 0,255,191
+	@Color cyan 0,255,255
+	@Color sky 0,191,255
+	@Color azure 0,127,255
+	@Color blue 0,0,255
+	@Color han 63,0,255
+	@Color violet 127,0,255
+	@Color purple 191,0,255
+	@Color fuchsia 255,0,255
+	@Color magenta 255,0,191
+	@Color pink 255,0,127
+	@Color crimson 255,0,63
+	@ColorCategory METALLIC COLORS
+	@Color brass 191,151,96
+	@Color copper 196,136,124
+	@Color gold 229,191,0
+	@Color silver 203,203,203
+	@ColorCategory MISCELLANEOUS COLORS
+	@Color celadon 172,255,175
+	@Color peach 255,159,127
+	@ColorCategory GREYSCALE & SEPIA
+	@Color grey 127,127,127
+	@Color sepia 127,101,63
+	@ColorCategory BLACK AND WHITE
+	@Color black 0,0,0
+	@Color white 255,255,255
+*/
+
+/**
+	@PageName color
+	@PageCategory Core
+	@PageTitle Colors
+	@PageDesc The Doryen library uses 32bits colors. Thus, your OS desktop must use 32bits colors.
+A color is defined by its red, green and blue component between 0 and 255.
+You can use the following predefined colors (hover over a color to see its full name and R,G,B values):
+	@ColorTable
+	@CppEx 
+		TCODColor::desaturatedRed
+		TCODColor::lightestRed
+		TCODColor::lighterRed
+		TCODColor::lightRed
+		TCODColor::red
+		TCODColor::darkRed
+		TCODColor::darkerRed
+		TCODColor::darkestRed
+	@CEx 
+		TCOD_desaturated_red
+		TCOD_lightest_red
+		TCOD_lighter_red
+		TCOD_light_red
+		TCOD_red
+		TCOD_dark_red
+		TCOD_darker_red
+		TCOD_darkest_red
+	@PyEx 
+		libtcod.desaturated_red
+		libtcod.lightest_red
+		libtcod.lighter_red
+		libtcod.light_red
+		libtcod.red
+		libtcod.dark_red
+		libtcod.darker_red
+		libtcod.darkest_red
+	@C#Ex 
+		TCODColor::desaturatedRed
+		TCODColor::lightestRed
+		TCODColor::lighterRed
+		TCODColor::lightRed
+		TCODColor::red
+		TCODColor::darkRed
+		TCODColor::darkerRed
+		TCODColor::darkestRed
+	@LuaEx
+		tcod.color.desaturatedRed
+		tcod.color.lightestRed
+		tcod.color.lighterRed
+		tcod.color.lightRed
+		tcod.color.red
+		tcod.color.darkRed
+		tcod.color.darkerRed
+		tcod.color.darkestRed
+ */
+
+class TCODLIB_API TCODColor {
+public :
+	uint8 r,g,b;
+
+	TCODColor() : r(0),g(0),b(0) {}
+	/**
+	@PageName color
+	@FuncTitle Create your own colors
+	@FuncDesc You can create your own colours using a set of constructors, both for RGB and HSV values.
+	@CppEx 
+		TCODColor myColor(24,64,255); //RGB
+		TCODColor myOtherColor(321.0f,0.7f,1.0f); //HSV
+	@CEx 
+		TCOD_color_t my_color={24,64,255}; <span>/</span>* RGB *<span>/</span>
+		TCOD_color_t my_other_color = TCOD_color_RGB(24,64,255); <span>/</span>* RGB too *<span>/</span>
+		TCOD_color_t my_yet_another_color = TCOD_color_HSV(321.0f,0.7f,1.0f); <span>/</span>* HSV *<span>/</span>
+	@PyEx my_color=libtcod.Color(24,64,255)
+	@C#Ex TCODColor myColor = new TCODColor(24,64,255); //RGB
+	     TCODColor myColor = new TCODColor(321.0f,0.7f,1.0f); //HSV
+	@LuaEx myColor = tcod.Color(24,24,255)
+	*/
+	TCODColor(uint8 r, uint8 g, uint8 b): r(r), g(g), b(b) {}
+	TCODColor(int r, int g, int b): r(r), g(g), b(b) {}
+	TCODColor(const TCOD_color_t &col): r(col.r), g(col.g), b(col.b) {}
+	TCODColor(float h, float s, float v);
+
+	/**
+	@PageName color
+	@FuncTitle Compare two colors
+	@CppEx 
+		if (myColor == TCODColor::yellow) { ... }
+		if (myColor != TCODColor::white) { ... }
+	@CEx 
+		if (TCOD_color_equals(my_color,TCOD_yellow)) { ... }
+		if (!TCOD_color_equals(my_color,TCOD_white)) { ... }
+	@PyEx 
+		if my_color == libtcod.yellow : ...
+		if my_color != litbcod.white : ...
+	@C#Ex 
+		if (myColor.Equal(TCODColor.yellow)) { ... }
+		if (myColor.NotEqual(TCODColor.white)) { ... }
+	@LuaEx 
+		if myColor == tcod.color.yellow then ... end
+	*/
+	bool operator == (const TCODColor & c) const {
+		return (c.r == r && c.g == g && c.b == b);
+	}
+	bool operator != (const TCODColor & c) const {
+		return (c.r != r || c.g != g || c.b != b);
+	}
+
+	/**
+	@PageName color
+	@FuncTitle Multiply two colors
+	@FuncDesc c1 = c2 * c3 =>
+    c1.r = c2.r * c3.r / 255
+    c1.g = c2.g * c3.g / 255
+    c1.b = c2.b * c3.b / 255
+	darkishRed = darkGrey * red
+<table><tr><td style="background-color: rgb(96, 0, 0); width: 60px; height: 30px;"></td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr></table>
+	@CppEx TCODColor myDarkishRed = TCODColor::darkGrey * TCODColor::lightRed;
+	@CEx TCOD_color_t my_darkish_red = TCOD_color_multiply(TCOD_dark_grey, TCOD_light_red);
+	@PyEx my_darkish_red = libtcod.dark_grey * libtcod.light_red
+	@C#Ex TCODColor myDarkishRed = TCODColor.darkGrey.Multiply(TCODColor.lightRed);
+	@LuaEx myDarkishRed = tcod.color.darkGrey * tcod.color.lightRed
+	*/
+	TCODColor operator * (const TCODColor & a) const {
+		TCODColor ret;
+		ret.r=(uint8)(((int)r)*a.r/255);
+		ret.g=(uint8)(((int)g)*a.g/255);
+		ret.b=(uint8)(((int)b)*a.b/255);
+		return ret;
+	}
+
+	/**
+	@PageName color
+	@FuncTitle Multiply a color by a float
+	@FuncDesc c1 = c2 * v =>
+    c1.r = CLAMP(0, 255, c2.r * v)
+    c1.g = CLAMP(0, 255, c2.g * v)
+    c1.b = CLAMP(0, 255, c2.b * v)
+	darkishRed = red * 0.5
+<table><tr><td style="background-color: rgb(128, 0, 0); width: 60px; height: 30px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td><td style="width: 60px;"></td></tr></table>
+</tbody>
+	@CppEx TCODColor myDarkishRed = TCODColor::lightRed * 0.5f;
+	@CEx TCOD_color_t my_darkish_red = TCOD_color_multiply_scalar(TCOD_light_red, 0.5f);
+	@PyEx myDarkishRed = litbcod.light_red * 0.5
+	@C#Ex TCODColor myDarkishRed = TCODColor.lightRed.Multiply(0.5f);
+	@LuaEx myDarkishRed = tcod.color.lightRed * 0.5
+	*/
+	TCODColor operator *(float value) const {
+		TCOD_color_t ret;
+		int r,g,b;
+		r = (int)(this->r * value);
+		g = (int)(this->g * value);
+		b = (int)(this->b * value);
+		r = CLAMP(0,255,r);
+		g = CLAMP(0,255,g);
+		b = CLAMP(0,255,b);
+		ret.r=(uint8)r;
+		ret.g=(uint8)g;
+		ret.b=(uint8)b;
+		return ret;
+	}
+
+	/**
+	@PageName color
+	@FuncTitle Adding two colors
+	@FuncDesc c1 = c1 + c2 => c1.r = MIN(255, c1.r + c2.r)
+                  c1.g = MIN(255, c1.g + c2.g)
+                  c1.b = MIN(255, c1.b + c2.b)
+	lightishRed = red + darkGrey
+<table><tr><td style="background-color: rgb(255, 128, 128); width: 60px; height: 30px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td><td style="background-color: rgb(128, 128, 128); width: 60px;"></td></tr></table>
+	@CppEx TCODColor myLightishRed = TCODColor::red + TCODColor::darkGrey
+	@CEx TCOD_color_t my_lightish_red = TCOD_color_add(TCOD_red, TCOD_dark_grey);
+	@PyEx myLightishRed = libtcod.red + libtcod.dark_grey
+	@C#Ex TCODColor myLightishRed = TCODColor.red.Plus(TCODColor.darkGrey)
+	@LuaEx myLightishRed = tcod.color.red + tcod.color.darkGrey
+	*/
+	TCODColor operator + (const TCODColor & a) const {
+		TCODColor ret;
+		int r=(int)(this->r)+a.r;
+		int g=(int)(this->g)+a.g;
+		int b=(int)(this->b)+a.b;
+		r = MIN(255,r);
+		g = MIN(255,g);
+		b = MIN(255,b);
+		ret.r=(uint8)r;
+		ret.g=(uint8)g;
+		ret.b=(uint8)b;
+		return ret;
+	}
+
+	/**
+	@PageName color
+	@FuncTitle Subtract two colors
+	@FuncDesc  c1 = c1 - c2 => c1.r = MAX(0, c1.r - c2.r)
+                  c1.g = MAX(0, c1.g - c2.g)
+                  c1.b = MAX(0, c1.b - c2.b)
+	redish = red - darkGrey
+<table><tr><td style="background-color: rgb(127, 0, 0); width: 60px; height: 30px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td><td style="background-color: rgb(128, 128, 128); width: 60px;"></td></tr></table>
+	@CppEx TCODColor myRedish = TCODColor::red - TCODColor::darkGrey
+	@CEx TCOD_color_t my_redish = TCOD_color_subtract(TCOD_red, TCOD_dark_grey);
+	@PyEx myRedish = libtcod.red - libtcod.dark_grey
+	@C#Ex TCODColor myRedish = TCODColor.red.Minus(TCODColor.darkGrey)
+	@LuaEx myRedish = tcod.color.red - tcod.color.darkGrey
+	*/
+	TCODColor operator - (const TCODColor & a) const {
+		TCODColor ret;
+		int r=(int)(this->r)-a.r;
+		int g=(int)(this->g)-a.g;
+		int b=(int)(this->b)-a.b;
+		r = MAX(0,r);
+		g = MAX(0,g);
+		b = MAX(0,b);
+		ret.r=(uint8)r;
+		ret.g=(uint8)g;
+		ret.b=(uint8)b;
+		return ret;
+	}
+
+	/**
+	@PageName color
+	@FuncTitle Interpolate between two colors
+	@FuncDesc   c1 = lerp (c2, c3, coef) => c1.r = c2.r  + (c3.r - c2.r ) * coef
+                              c1.g = c2.g  + (c3.g - c2.g ) * coef
+                              c1.b = c2.b  + (c3.b - c2.b ) * coef
+coef should be between 0.0 and 1.0 but you can as well use other values
+<table><tr><td style="background-color: rgb(96, 96, 96); color: rgb(255, 255, 255);" align="center">coef == 0.0f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
+	<tr><td style="background-color: rgb(135, 72, 72); color: rgb(255, 255, 255);" align="center">coef == 0.25f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
+	<tr><td style="background-color: rgb(175, 48, 48); color: rgb(255, 255, 255);" align="center">coef == 0.5f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
+
+	<tr><td style="background-color: rgb(215, 24, 24); color: rgb(255, 255, 255);" align="center">coef == 0.75f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr>
+	<tr><td style="background-color: rgb(255, 0, 0); color: rgb(255, 255, 255);" align="center">coef == 1.0f</td><td style="background-color: rgb(96, 96, 96); width: 60px;"></td><td style="background-color: rgb(255, 0, 0); width: 60px;"></td></tr></table>
+	@CppEx TCODColor myColor = TCODColor::lerp ( TCODColor::darkGrey, TCODColor::lightRed,coef );
+	@CEx TCOD_color_t my_color = TCOD_color_lerp ( TCOD_dark_grey, TCOD_light_red,coef);
+	@PyEx my_color = libtcod.color_lerp ( libtcod.dark_grey, litbcod.light_red,coef)
+	@C#Ex TCODColor myColor = TCODColor.Interpolate( TCODColor.darkGrey, TCODColor.lightRed, coef );
+	@LuaEx myColor = tcod.color.Interpolate( tcod.color.darkGrey, tcod.color.lightRed, coef )
+	*/
+	static TCODColor lerp(const TCODColor &a, const TCODColor &b, float coef) {
+		TCODColor ret;
+		ret.r=(uint8)(a.r+(b.r-a.r)*coef);
+		ret.g=(uint8)(a.g+(b.g-a.g)*coef);
+		ret.b=(uint8)(a.b+(b.b-a.b)*coef);
+		return ret;
+	}
+
+	/**
+	@PageName color
+	@FuncTitle Define a color by its hue, saturation and value
+	@FuncDesc After this function is called, the r,g,b fields of the color are calculated according to the h,s,v parameters.
+	@Cpp void TCODColor::setHSV(float h, float s, float v)
+	@C void TCOD_color_set_HSV(TCOD_color_t *c,float h, float s, float v)
+	@Py color_set_hsv(c,h,s,v)
+	@C# void TCODColor::setHSV(float h, float s, float v)
+	@Lua Color:setHSV( h, s ,v )
+	@Param c In the C and python versions, the color to modify
+	@Param h,s,v Color components in the HSV space
+		0.0 <= h < 360.0
+		0.0 <= s <= 1.0
+		0.0 <= v <= 1.0
+	*/
+	void setHSV(float h, float s, float v);
+
+	/**
+	@PageName color
+	@FuncTitle Define a color's hue, saturation or lightness
+	@FuncDesc These functions set only a single component in the HSV color space.
+	@Cpp 
+		void TCODColor::setHue (float h)
+		void TCODColor::setSaturation (float s)
+		void TCODColor::setValue (float v)
+	@C 
+		void TCOD_color_set_hue (TCOD_color_t *c, float h)
+		void TCOD_color_set_saturation (TCOD_color_t *c, float s)
+		void TCOD_color_set_value (TCOD_color_t *c, float v)
+	@Lua 
+		Color:setHue(h)
+		Color:setSaturation(s)
+		Color:setValue(v)
+	@Param h,s,v	Color components in the HSV space
+	@Param c	In the C and python versions, the color to modify
+	*/
+	void setHue (float h);
+	void setSaturation (float s);
+	void setValue (float v);
+
+	/**
+	@PageName color
+	@FuncTitle Get a color hue, saturation and value components
+	@Cpp void TCODColor::getHSV(float *h, float *s, float *v) const
+	@C void TCOD_color_get_HSV(TCOD_color_t c,float * h, float * s, float * v)
+	@Py color_get_HSV(c) # returns [h,s,v]
+	@C# void TCODColor::getHSV(out float h, out float s, out float v)
+	@Lua Color:getHSV() -- returns h,s,v
+	@Param c	In the C and python versions, the TCOD_color_t from which to read.
+	@Param  h,s,v	Color components in the HSV space
+		0.0 <= h < 360.0
+		0.0 <= s <= 1.0
+		0.0 <= v <= 1.0
+	*/
+	void getHSV(float *h, float *s, float *v) const;
+
+	/**
+	@PageName color
+	@FuncTitle Get a color's hue, saturation or value
+	@FuncDesc Should you need to extract only one of the HSV components, these functions are what you should call. Note that if you need all three values, it's way less burdensome for the CPU to call TCODColor::getHSV().
+	@Cpp 
+		float TCODColor::getHue ()
+		float TCODColor::getSaturation ()
+		float TCODColor::getValue ()
+	@C 
+		float TCOD_color_get_hue (TCOD_color_t c)
+		float TCOD_color_get_saturation (TCOD_color_t c)
+		float TCOD_color_get_value (TCOD_color_t c)
+	@Lua
+		Color:getHue()
+		Color:getSaturation()
+		Color:getValue()
+	@C#
+		float TCODColor::getHue()
+		float TCODColor::getSaturation()
+		float TCODColor::getValue()
+	@Param c	the TCOD_color_t from which to read
+	*/
+	float getHue ();
+	float getSaturation ();
+	float getValue ();
+
+	/**
+	@PageName color
+	@FuncTitle Shift a color's hue up or down
+	@FuncDesc The hue shift value is the number of grades the color's hue will be shifted. The value can be negative for shift left, or positive for shift right.
+		Resulting values H < 0 and H >= 360 are handled automatically.
+	@Cpp void TCODColor::shiftHue (float hshift)
+	@C void TCOD_color_shift_hue (TCOD_color_t *c, float hshift)
+	@C# TCODColor::shiftHue(float hshift)
+	@Lua Color:shiftHue(hshift)
+	@Param c	The color to modify
+	@Param hshift	The hue shift value
+	*/
+	void shiftHue (float hshift);
+
+	/**
+	@PageName color
+	@FuncTitle Scale a color's saturation and value
+	@Cpp void TCODColor::scaleHSV (float sscale, float vscale)
+	@C void TCOD_color_scale_HSV (TCOD_color_t *c, float scoef, float vcoef)
+	@Py color_scale_HSV(c, scoef, vcoef)
+	@C# TCODColor::scaleHSV (float sscale, float vscale)
+	@Lua Color:scaleHSV(sscale,vscale)
+	@Param c	The color to modify
+	@Param sscale	saturation multiplier (1.0f for no change)
+	@Param vscale	value multiplier (1.0f for no change)
+	*/
+	void scaleHSV (float sscale, float vscale);
+
+	/**
+	@PageName color
+	@FuncTitle Generate a smooth color map
+	@FuncDesc You can define a color map from an array of color keys. Colors will be interpolated between the keys.
+	0 -> black
+	4 -> red
+	8 -> white
+	Result :
+	<table>
+	<tbody><tr><td class="code"><pre>map[0]</pre></td><td style="background-color: rgb(0, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td><td>black</td></tr>
+
+	<tr><td class="code"><pre>map[1]</pre></td><td style="background-color: rgb(63, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
+	<tr><td class="code"><pre>map[2]</pre></td><td style="background-color: rgb(127, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
+	<tr><td class="code"><pre>map[3]</pre></td><td style="background-color: rgb(191, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
+	<tr><td class="code"><pre>map[4]</pre></td><td style="background-color: rgb(255, 0, 0); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td><td>red</td></tr>
+	<tr><td class="code"><pre>map[5]</pre></td><td style="background-color: rgb(255, 63, 63); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
+	<tr><td class="code"><pre>map[6]</pre></td><td style="background-color: rgb(255, 127, 127); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
+
+	<tr><td class="code"><pre>map[7]</pre></td><td style="background-color: rgb(255, 191, 191); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td></tr>
+	<tr><td class="code"><pre>map[8]</pre></td><td style="background-color: rgb(255, 255, 255); color: rgb(255, 255, 255); width: 50px;" align="center">&nbsp;</td><td>white</td></tr>
+</tbody></table>
+	@Cpp static void genMap(TCODColor *map, int nbKey, TCODColor const *keyColor, int const *keyIndex)
+	@C void TCOD_gen_map(TCOD_color_t *map, int nb_key, TCOD_color_t const *key_color, int const *key_index)
+	@Py color_gen_map(keyColor,keyIndex) # returns an array of colors
+	@Param map	An array of colors to be filled by the function.
+	@Param nbKey	Number of color keys
+	@Param keyColor	Array of nbKey colors containing the color of each key
+	@Param keyIndex	Array of nbKey integers containing the index of each key.
+		If you want to fill the map array, keyIndex[0] must be 0 and keyIndex[nbKey-1] is the number of elements in map minus 1 but you can also use the function to fill only a part of the map array.
+	@CppEx 
+		int idx[] = { 0, 4, 8 }; // indexes of the keys
+		TCODColor col[] = { TCODColor( 0,0,0 ), TCODColor(255,0,0), TCODColor(255,255,255) }; // colors : black, red, white
+		TCODColor map[9];
+		TCODColor::genMap(map,3,col,idx);
+	@CEx 
+		int idx[] = { 0, 4, 8 }; // indexes of the keys
+		TCOD_color_t col[] = { { 0,0,0 }, {255,0,0}, {255,255,255} }; // colors : black, red, white
+		TCOD_color_t map[9];
+		TCOD_color_gen_map(map,3,col,idx);
+	@PyEx 
+		idx = [ 0, 4, 8 ] # indexes of the keys
+		col = [ libtcod.Color( 0,0,0 ), libtcod.Color( 255,0,0 ), libtcod.Color(255,255,255) ] # colors : black, red, white
+		map=libtcod.color_gen_map(col,idx)
+	*/
+	static void genMap(TCODColor *map, int nbKey, TCODColor const *keyColor, int const *keyIndex);
+
+	// color array
+	static const TCODColor colors[TCOD_COLOR_NB][TCOD_COLOR_LEVELS];
+
+	// grey levels
+	static const TCODColor black;
+	static const TCODColor darkestGrey;
+	static const TCODColor darkerGrey;
+	static const TCODColor darkGrey;
+	static const TCODColor grey;
+	static const TCODColor lightGrey;
+	static const TCODColor lighterGrey;
+	static const TCODColor lightestGrey;
+	static const TCODColor white;
+
+	//sepia
+	static const TCODColor darkestSepia;
+	static const TCODColor darkerSepia;
+	static const TCODColor darkSepia;
+	static const TCODColor sepia;
+	static const TCODColor lightSepia;
+	static const TCODColor lighterSepia;
+	static const TCODColor lightestSepia;
+
+	// standard colors
+	static const TCODColor red;
+  static const TCODColor flame;
+  static const TCODColor orange;
+  static const TCODColor amber;
+  static const TCODColor yellow;
+  static const TCODColor lime;
+  static const TCODColor chartreuse;
+  static const TCODColor green;
+  static const TCODColor sea;
+  static const TCODColor turquoise;
+  static const TCODColor cyan;
+  static const TCODColor sky;
+  static const TCODColor azure;
+  static const TCODColor blue;
+  static const TCODColor han;
+  static const TCODColor violet;
+  static const TCODColor purple;
+  static const TCODColor fuchsia;
+  static const TCODColor magenta;
+  static const TCODColor pink;
+  static const TCODColor crimson;
+
+	// dark colors
+	static const TCODColor darkRed;
+  static const TCODColor darkFlame;
+  static const TCODColor darkOrange;
+  static const TCODColor darkAmber;
+  static const TCODColor darkYellow;
+  static const TCODColor darkLime;
+  static const TCODColor darkChartreuse;
+  static const TCODColor darkGreen;
+  static const TCODColor darkSea;
+  static const TCODColor darkTurquoise;
+  static const TCODColor darkCyan;
+  static const TCODColor darkSky;
+  static const TCODColor darkAzure;
+  static const TCODColor darkBlue;
+  static const TCODColor darkHan;
+  static const TCODColor darkViolet;
+  static const TCODColor darkPurple;
+  static const TCODColor darkFuchsia;
+  static const TCODColor darkMagenta;
+  static const TCODColor darkPink;
+  static const TCODColor darkCrimson;
+
+	// darker colors
+	static const TCODColor darkerRed;
+  static const TCODColor darkerFlame;
+  static const TCODColor darkerOrange;
+  static const TCODColor darkerAmber;
+  static const TCODColor darkerYellow;
+  static const TCODColor darkerLime;
+  static const TCODColor darkerChartreuse;
+  static const TCODColor darkerGreen;
+  static const TCODColor darkerSea;
+  static const TCODColor darkerTurquoise;
+  static const TCODColor darkerCyan;
+  static const TCODColor darkerSky;
+  static const TCODColor darkerAzure;
+  static const TCODColor darkerBlue;
+  static const TCODColor darkerHan;
+  static const TCODColor darkerViolet;
+  static const TCODColor darkerPurple;
+  static const TCODColor darkerFuchsia;
+  static const TCODColor darkerMagenta;
+  static const TCODColor darkerPink;
+  static const TCODColor darkerCrimson;
+
+  // darkest colors
+  static const TCODColor darkestRed;
+  static const TCODColor darkestFlame;
+  static const TCODColor darkestOrange;
+  static const TCODColor darkestAmber;
+  static const TCODColor darkestYellow;
+  static const TCODColor darkestLime;
+  static const TCODColor darkestChartreuse;
+  static const TCODColor darkestGreen;
+  static const TCODColor darkestSea;
+  static const TCODColor darkestTurquoise;
+  static const TCODColor darkestCyan;
+  static const TCODColor darkestSky;
+  static const TCODColor darkestAzure;
+  static const TCODColor darkestBlue;
+  static const TCODColor darkestHan;
+  static const TCODColor darkestViolet;
+  static const TCODColor darkestPurple;
+  static const TCODColor darkestFuchsia;
+  static const TCODColor darkestMagenta;
+  static const TCODColor darkestPink;
+  static const TCODColor darkestCrimson;
+
+	// light colors
+	static const TCODColor lightRed;
+  static const TCODColor lightFlame;
+  static const TCODColor lightOrange;
+  static const TCODColor lightAmber;
+  static const TCODColor lightYellow;
+  static const TCODColor lightLime;
+  static const TCODColor lightChartreuse;
+  static const TCODColor lightGreen;
+  static const TCODColor lightSea;
+  static const TCODColor lightTurquoise;
+  static const TCODColor lightCyan;
+  static const TCODColor lightSky;
+  static const TCODColor lightAzure;
+  static const TCODColor lightBlue;
+  static const TCODColor lightHan;
+  static const TCODColor lightViolet;
+  static const TCODColor lightPurple;
+  static const TCODColor lightFuchsia;
+  static const TCODColor lightMagenta;
+  static const TCODColor lightPink;
+  static const TCODColor lightCrimson;
+
+  //lighter colors
+  static const TCODColor lighterRed;
+  static const TCODColor lighterFlame;
+  static const TCODColor lighterOrange;
+  static const TCODColor lighterAmber;
+  static const TCODColor lighterYellow;
+  static const TCODColor lighterLime;
+  static const TCODColor lighterChartreuse;
+  static const TCODColor lighterGreen;
+  static const TCODColor lighterSea;
+  static const TCODColor lighterTurquoise;
+  static const TCODColor lighterCyan;
+  static const TCODColor lighterSky;
+  static const TCODColor lighterAzure;
+  static const TCODColor lighterBlue;
+  static const TCODColor lighterHan;
+  static const TCODColor lighterViolet;
+  static const TCODColor lighterPurple;
+  static const TCODColor lighterFuchsia;
+  static const TCODColor lighterMagenta;
+  static const TCODColor lighterPink;
+  static const TCODColor lighterCrimson;
+
+  // lightest colors
+  static const TCODColor lightestRed;
+  static const TCODColor lightestFlame;
+  static const TCODColor lightestOrange;
+  static const TCODColor lightestAmber;
+  static const TCODColor lightestYellow;
+  static const TCODColor lightestLime;
+  static const TCODColor lightestChartreuse;
+  static const TCODColor lightestGreen;
+  static const TCODColor lightestSea;
+  static const TCODColor lightestTurquoise;
+  static const TCODColor lightestCyan;
+  static const TCODColor lightestSky;
+  static const TCODColor lightestAzure;
+  static const TCODColor lightestBlue;
+  static const TCODColor lightestHan;
+  static const TCODColor lightestViolet;
+  static const TCODColor lightestPurple;
+  static const TCODColor lightestFuchsia;
+  static const TCODColor lightestMagenta;
+  static const TCODColor lightestPink;
+  static const TCODColor lightestCrimson;
+
+	// desaturated colors
+  static const TCODColor desaturatedRed;
+  static const TCODColor desaturatedFlame;
+  static const TCODColor desaturatedOrange;
+  static const TCODColor desaturatedAmber;
+  static const TCODColor desaturatedYellow;
+  static const TCODColor desaturatedLime;
+  static const TCODColor desaturatedChartreuse;
+  static const TCODColor desaturatedGreen;
+  static const TCODColor desaturatedSea;
+  static const TCODColor desaturatedTurquoise;
+  static const TCODColor desaturatedCyan;
+  static const TCODColor desaturatedSky;
+  static const TCODColor desaturatedAzure;
+  static const TCODColor desaturatedBlue;
+  static const TCODColor desaturatedHan;
+  static const TCODColor desaturatedViolet;
+  static const TCODColor desaturatedPurple;
+  static const TCODColor desaturatedFuchsia;
+  static const TCODColor desaturatedMagenta;
+  static const TCODColor desaturatedPink;
+  static const TCODColor desaturatedCrimson;
+
+	// metallic
+	static const TCODColor brass;
+	static const TCODColor copper;
+	static const TCODColor gold;
+	static const TCODColor silver;
+
+	// miscellaneous
+	static const TCODColor celadon;
+	static const TCODColor peach;
+};
+
+TCODLIB_API TCODColor operator *(float value, const TCODColor &c);
+
+#endif
--- /dev/null
+++ b/include/libtcod/console.hpp
@@ -0,0 +1,1759 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_CONSOLE_HPP
+#define _TCOD_CONSOLE_HPP
+
+#include "console_types.h"
+
+/**
+	@PageName console
+	@PageCategory Core
+	@PageTitle Console
+	@PageDesc The console emulator handles the rendering of the game screen and the keyboard input.
+Classic real time game loop:
+	@Cpp
+		TCODConsole::initRoot(80,50,"my game",false);
+		TCODSystem::setFps(25); // limit framerate to 25 frames per second
+		while (!endGame && !TCODConsole::isWindowClosed()) {
+			// ... draw on TCODConsole::root
+			TCODConsole::flush();
+			TCOD_key_t key = TCODConsole::checkForKeypress();
+			updateWorld (key, TCODSystem::getLastFrameLength());
+			// updateWorld(TCOD_key_t key, float elapsed) (using key if key.vk != TCODK_NONE)
+			// use elapsed to scale any update that is time dependant.
+		}
+	@Lua
+		tcod.console.initRoot(80,50,"my game", false)
+		root=libtcod.TCODConsole_root
+		tcod.system.setFps(25)
+		while not tcod.console.isWindowClosed() do
+			-- ... draw on root
+			tcod.console.flush()
+			key=tcod.console.checkForKeypress()
+			-- ... update world, using key and tcod.system.getLastFrameLength
+		end
+
+*/
+/**
+	@PageName console
+	@FuncDesc Classic turn by turn game loop:
+	@Cpp
+		TCODConsole::initRoot(80,50,"my game",false);
+		while (!endGame && !TCODConsole::isWindowClosed()) {
+			// ... draw on TCODConsole::root
+			TCODConsole::flush();
+			TCOD_key_t key = TCODConsole::waitForKeypress(true);
+			//... update world, using key
+		}
+*/
+
+class TCODLIB_API TCODConsole {
+public :
+	/**
+	@PageName console_init
+	@PageTitle Initializing the console
+	@PageFather console
+	*/
+
+	static TCODConsole *root;
+
+	/**
+	@PageName console_init_root
+	@PageTitle Creating the game window
+	@PageFather console_init
+	@Cpp static void TCODConsole::initRoot (int w, int h, const char * title, bool fullscreen = false, TCOD_renderer_t renderer = TCOD_RENDERER_SDL)
+	@C void TCOD_console_init_root (int w, int h, const char * title, bool fullscreen, TCOD_renderer_t renderer)
+	@Py console_init_root (w, h, title, fullscreen = False, renderer = RENDERER_SDL)
+	@C#
+		static void TCODConsole::initRoot(int w, int h, string title)
+		static void TCODConsole::initRoot(int w, int h, string title, bool fullscreen)
+		static void TCODConsole::initRoot(int w, int h, string title, bool fullscreen, TCODRendererType renderer)
+	@Lua
+		tcod.console.initRoot(w,h,title) -- fullscreen = false, renderer = SDL
+		tcod.console.initRoot(w,h,title,fullscreen) -- renderer = SDL
+		tcod.console.initRoot(w,h,title,fullscreen,renderer)
+		-- renderers : tcod.GLSL, tcod.OpenGL, tcod.SDL
+	@Param w,h size of the console(in characters). The default font in libtcod (./terminal.png) uses 8x8 pixels characters.
+		You can change the font by calling TCODConsole::setCustomFont before calling initRoot.
+	@Param title title of the window. It's not visible when you are in fullscreen.
+		Note 1 : you can dynamically change the window title with TCODConsole::setWindowTitle
+	@Param fullscreen wether you start in windowed or fullscreen mode.
+		Note 1 : you can dynamically change this mode with TCODConsole::setFullscreen
+		Note 2 : you can get current mode with TCODConsole::isFullscreen
+	@Param renderer which renderer to use. Possible values are :
+    * TCOD_RENDERER_GLSL : works only on video cards with pixel shaders
+    * TCOD_RENDERER_OPENGL : works on all video cards supporting OpenGL 1.4
+    * TCOD_RENDERER_SDL : should work everywhere!
+		Note 1: if you select a renderer that is not supported by the player's machine, libtcod scan the lower renderers until it finds a working one.
+		Note 2: on recent video cards, GLSL results in up to 900% increase of framerates in the true color sample compared to SDL renderer.
+		Note 3: whatever renderer you use, it can always be overriden by the player through the libtcod.cfg file.
+		Note 4: you can dynamically change the renderer after calling initRoot with TCODSystem::setRenderer.
+		Note 5: you can get current renderer with TCODSystem::getRenderer. It might be different from the one you set in initRoot in case it's not supported on the player's computer.
+	@CppEx TCODConsole::initRoot(80, 50, "The Chronicles Of Doryen v0.1");
+	@CEx TCOD_console_init_root(80, 50, "The Chronicles Of Doryen v0.1", false, TCOD_RENDERER_OPENGL);
+	@PyEx libtcod.console_init_root(80, 50, 'The Chronicles Of Doryen v0.1')
+	@LuaEx tcod.console.initRoot(80,50,"The Chronicles Of Doryen v0.1")
+	*/
+	static void initRoot(int w, int h, const char * title, bool fullscreen = false, TCOD_renderer_t renderer=TCOD_RENDERER_SDL);
+
+	/**
+	@PageName console_set_custom_font
+	@PageTitle Using a custom bitmap font
+	@PageFather console_init
+	@FuncTitle setCustomFont
+	@FuncDesc This function allows you to use a bitmap font (png or bmp) with custom character size or layout.
+		It should be called before initializing the root console with initRoot.
+		Once this function is called, you can define your own custom mappings using mapping functions
+		<h5>Different font layouts</h5>
+		<table>
+		<tr><td>ASCII_INROW</td><td>ASCII_INCOL</td><td>TCOD</td></tr>
+
+		<tr><td><img src='terminal8x8_gs_ro.png' /></td><td><img src='terminal8x8_gs_as.png' /></td><td><img src='terminal8x8_gs_tc.png' /></td></tr>
+		</table>
+		<ul>
+		<li>ascii, in columns : characters 0 to 15 are in the first column. The space character is at coordinates 2,0.</li>
+		<li>ascii, in rows : characters 0 to 15 are in the first row. The space character is at coordinates 0,2.</li>
+		<li>tcod : special mapping. Not all ascii values are mapped. The space character is at coordinates 0,0.</li>
+		</ul>
+		<h5>Different font types</h5>
+		<table>
+		<tr><td>standard<br />(non antialiased)</td><td>antialiased<br />(32 bits PNG)</td><td>antialiased<br />(greyscale)</td></tr>
+
+		<tr><td><img src='terminal.png' /></td><td><img src='terminal8x8_aa_as.png' /></td><td><img src='terminal8x8_gs_as2.png' /></td></tr>
+		</table>
+		<ul>
+		<li>standard : transparency is given by a key color automatically detected by looking at the color of the space character</li>
+		<li>32 bits : transparency is given by the png alpha layer. The font color does not matter but it must be desaturated</li>
+		<li>greyscale : transparency is given by the pixel value. You can use white characters on black background or black characters on white background. The background color is automatically detected by looking at the color of the space character</li>
+		</ul>
+		Examples of fonts can be found in libtcod's fonts directory. Check the Readme file there.
+	@Cpp static void TCODConsole::setCustomFont(const char *fontFile, int flags=TCOD_FONT_LAYOUT_ASCII_INCOL,int nbCharHoriz=0, int nbCharVertic=0)
+	@C void TCOD_console_set_custom_font(const char *fontFile, int flags,int nb_char_horiz, int nb_char_vertic)
+	@Py console_set_custom_font(fontFile, flags=FONT_LAYOUT_ASCII_INCOL,nb_char_horiz=0, nb_char_vertic=0)
+	@C#
+		static void TCODConsole::setCustomFont(string fontFile)
+		static void TCODConsole::setCustomFont(string fontFile, int flags)
+		static void TCODConsole::setCustomFont(string fontFile, int flags, int nbCharHoriz)
+		static void TCODConsole::setCustomFont(string fontFile, int flags, int nbCharHoriz, int nbCharVertic)
+	@Lua
+		tcod.console.setCustomFont(fontFile)
+		tcod.console.setCustomFont(fontFile, flags)
+		tcod.console.setCustomFont(fontFile, nbCharHoriz)
+		tcod.console.setCustomFont(fontFile, flags, nbCharHoriz, nbCharVertic)
+		-- flags : tcod.LayoutAsciiInColumn, tcod.LayoutAsciiInRow, tcod.LayoutTCOD, tcod.Greyscale
+	@Param fontFile Name of a .bmp or .png file containing the font.
+	@Param flags Used to define the characters layout in the bitmap and the font type :
+		TCOD_FONT_LAYOUT_ASCII_INCOL : characters in ASCII order, code 0-15 in the first column
+		TCOD_FONT_LAYOUT_ASCII_INROW : characters in ASCII order, code 0-15 in the first row
+		TCOD_FONT_LAYOUT_TCOD : simplified layout. See examples below.
+		TCOD_FONT_TYPE_GREYSCALE : create an anti-aliased font from a greyscale bitmap
+		For python, remove TCOD _ :
+		libtcod.FONT_LAYOUT_ASCII_INCOL
+	@Param nbCharHoriz,nbCharVertic Number of characters in the font.
+		Should be 16x16 for ASCII layouts, 32x8 for TCOD layout.
+		But you can use any other layout.
+		If set to 0, there are deduced from the font layout flag.
+	@CppEx
+		TCODConsole::setCustomFont("standard_8x8_ascii_in_col_font.bmp",TCOD_FONT_LAYOUT_ASCII_INCOL);
+		TCODConsole::setCustomFont("32bits_8x8_ascii_in_row_font.png",TCOD_FONT_LAYOUT_ASCII_INROW);
+		TCODConsole::setCustomFont("greyscale_8x8_tcod_font.png",TCOD_FONT_LAYOUT_TCOD | TCOD_FONT_TYPE_GREYSCALE);
+	@CEx
+		TCOD_console_set_custom_font("standard_8x8_ascii_in_col_font.bmp",TCOD_FONT_LAYOUT_ASCII_INCOL,16,16);
+		TCOD_console_set_custom_font("32bits_8x8_ascii_in_row_font.png",TCOD_FONT_LAYOUT_ASCII_INROW,32,8);
+		TCOD_console_set_custom_font("greyscale_8x8_tcod_font.png",TCOD_FONT_LAYOUT_TCOD | TCOD_FONT_TYPE_GREYSCALE,32,8);
+	@PyEx
+		libtcod.console_set_custom_font("standard_8x8_ascii_in_col_font.bmp",libtcod.FONT_LAYOUT_ASCII_INCOL)
+		libtcod.console_set_custom_font("32bits_8x8_ascii_in_row_font.png",libtcod.FONT_LAYOUT_ASCII_INROW)
+		libtcod.console_set_custom_font("greyscale_8x8_tcod_font.png",libtcod.FONT_LAYOUT_TCOD | libtcod.FONT_TYPE_GREYSCALE)
+	@LuaEx
+		tcod.console.setCustomFont("standard_8x8_ascii_in_col_font.bmp",tcod.LayoutAsciiInColumn);
+		tcod.console.setCustomFont("32bits_8x8_ascii_in_row_font.png",tcod.LayoutAsciiInRow);
+		tcod.console.setCustomFont("greyscale_8x8_tcod_font.png",tcod.LayoutTCOD + tcod.Greyscale);
+	*/
+	static void setCustomFont(const char *fontFile, int flags=TCOD_FONT_LAYOUT_ASCII_INCOL,int nbCharHoriz=0, int nbCharVertic=0);
+
+	/**
+	@PageName console_map
+	@PageTitle Using custom characters mapping
+	@PageFather console_init
+	@FuncTitle Mapping a single ASCII code to a character
+	@PageDesc These functions allow you to map characters in the bitmap font to ASCII codes.
+		They should be called after initializing the root console with initRoot.
+		You can dynamically change the characters mapping at any time, allowing to use several fonts in the same screen.
+	@Cpp static void TCODConsole::mapAsciiCodeToFont(int asciiCode, int fontCharX, int fontCharY)
+	@C void TCOD_console_map_ascii_code_to_font(int asciiCode, int fontCharX, int fontCharY)
+	@Py console_map_ascii_code_to_font(asciiCode, fontCharX, fontCharY)
+	@C# static void TCODConsole::mapAsciiCodeToFont(int asciiCode, int fontCharX, int fontCharY)
+	@Lua tcod.console.mapAsciiCodeToFont(asciiCode, fontCharX, fontCharY)
+	@Param asciiCode ASCII code to map.
+	@Param fontCharX,fontCharY Coordinate of the character in the bitmap font (in characters, not pixels).
+	*/
+	static void mapAsciiCodeToFont(int asciiCode, int fontCharX, int fontCharY);
+
+	/**
+	@PageName console_map
+	@FuncTitle Mapping consecutive ASCII codes to consecutive characters
+	@Cpp static void TCODConsole::mapAsciiCodesToFont(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY)
+	@C void TCOD_console_map_ascii_codes_to_font(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY)
+	@Py console_map_ascii_codes_to_font(firstAsciiCode, nbCodes, fontCharX, fontCharY)
+	@C# static void TCODConsole::mapAsciiCodesToFont(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY)
+	@Lua tcod.console.mapAsciiCodesToFont(firstAsciiCode, nbCodes, fontCharX, fontCharY)
+	@Param firstAsciiCode first ASCII code to map
+	@Param nbCodes number of consecutive ASCII codes to map
+	@Param fontCharX,fontCharY coordinate of the character in the bitmap font (in characters, not pixels) corresponding to the first ASCII code
+	*/
+	static void mapAsciiCodesToFont(int firstAsciiCode, int nbCodes, int fontCharX, int fontCharY);
+
+	/**
+	@PageName console_map
+	@FuncTitle Mapping ASCII code from a string to consecutive characters
+	@Cpp static void TCODConsole::mapStringToFont(const char *s, int fontCharX, int fontCharY)
+	@C void TCOD_console_map_string_to_font(const char *s, int fontCharX, int fontCharY)
+	@Py console_map_string_to_font(s, fontCharX, fontCharY)
+	@C# static void TCODConsole::mapStringToFont(string s, int fontCharX, int fontCharY)
+	@Lua tcod.console.mapStringToFont(s, fontCharX, fontCharY)
+	@Param s string containing the ASCII codes to map
+	@Param fontCharX,fontCharY coordinate of the character in the bitmap font (in characters, not pixels) corresponding to the first ASCII code in the string
+	*/
+	static void mapStringToFont(const char *s, int fontCharX, int fontCharY);
+
+	/**
+	@PageName console_fullscreen
+	@PageTitle Fullscreen mode
+	@PageFather console_init
+	@FuncTitle Getting the current mode
+	@FuncDesc This function returns true if the current mode is fullscreen.
+	@Cpp static bool TCODConsole::isFullscreen()
+	@C bool TCOD_console_is_fullscreen()
+	@Py console_is_fullscreen()
+	@C# static bool TCODConsole::isFullscreen()
+	@Lua tcod.console.isFullscreen()
+	*/
+	static bool isFullscreen();
+	/**
+	@PageName console_fullscreen
+	@FuncTitle Switching between windowed and fullscreen modes
+	@FuncDesc This function switches the root console to fullscreen or windowed mode.
+		Note that there is no predefined key combination to switch to/from fullscreen. You have to do this in your own code.
+	@Cpp static void TCODConsole::setFullscreen(bool fullscreen)
+	@C void TCOD_console_set_fullscreen(bool fullscreen)
+	@Py console_set_fullscreen(fullscreen)
+	@C# static void TCODConsole::setFullscreen(bool fullscreen)
+	@Lua tcod.console.setFullscreen(fullscreen)
+	@Param fullscreen true to switch to fullscreen mode.
+		false to switch to windowed mode.
+	@CppEx
+		TCOD_key_t key=TCODConsole::checkForKeypress();
+		if ( key.vk == TCODK_ENTER && key.lalt )
+			TCODConsole::setFullscreen(!TCODConsole::isFullscreen());
+	@CEx
+		TCOD_key_t key=TCOD_console_check_for_keypress();
+		if ( key.vk == TCODK_ENTER && key.lalt )
+			TCOD_console_set_fullscreen(!TCOD_console_is_fullscreen());
+	@PyEx
+		key=libtcod.console_check_for_keypress()
+		if key.vk == libtcod.KEY_ENTER and key.lalt :
+			libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())
+	@LuaEx
+		key=tcod.console.checkForKeypress()
+		if key.KeyCode == tcod.Enter and key.LeftAlt then
+			tcod.console.setFullscreen(not tcod.console.isFullscreen())
+		end
+	*/
+	static void setFullscreen(bool fullscreen);
+
+	/**
+	@PageName console_window
+	@PageFather console_init
+	@PageTitle Communicate with the window manager
+	@FuncTitle Changing the window title
+	@FuncDesc This function dynamically changes the title of the game window.
+		Note that the window title is not visible while in fullscreen.
+	@Cpp static void TCODConsole::setWindowTitle(const char *title)
+ 	@C void TCOD_console_set_window_title(const char *title)
+	@Py console_set_window_title(title)
+	@C# static void TCODConsole::setWindowTitle(string title)
+	@Lua tcod.console.setWindowTitle(title)
+	@Param title New title of the game window
+	*/
+	static void setWindowTitle(const char *title);
+
+	/**
+	@PageName console_window
+	@FuncTitle Handling "close window" events
+	@FuncDesc When you start the program, this returns false. Once a "close window" event has been sent by the window manager, it will allways return true. You're supposed to exit cleanly the game.
+	@Cpp static bool TCODConsole::isWindowClosed()
+	@C bool TCOD_console_is_window_closed()
+	@Py console_is_window_closed()
+	@C# static bool TCODConsole::isWindowClosed()
+	@Lua tcod.console.isWindowClosed()
+	*/
+	static bool isWindowClosed();
+
+	/**
+	@PageName console_credits
+	@PageTitle libtcod's credits
+	@PageFather console_init
+	@PageDesc Use these functions to display credits, as seen in the samples.
+	@FuncTitle Using a separate credit page
+	@FuncDesc You can print a "Powered by libtcod x.y.z" screen during your game startup simply by calling this function after initRoot.
+		The credits screen can be skipped by pressing any key.
+	@Cpp static void TCODConsole::credits()
+	@C void TCOD_console_credits()
+	@Py console_credits()
+	@C# static void TCODConsole::credits()
+	@Lua tcod.console.credits()
+	*/
+	static void credits();
+
+	/**
+	@PageName console_credits
+	@FuncTitle Embedding credits in an existing page
+	@FuncDesc You can also print the credits on one of your game screens (your main menu for example) by calling this function in your main loop.
+		This function returns true when the credits screen is finished, indicating that you no longer need to call it.
+	@Cpp static bool TCODConsole::renderCredits(int x, int y, bool alpha)
+	@C bool TCOD_console_credits_render(int x, int y, bool alpha)
+	@Py bool TCOD_console_credits_render(int x, int y, bool alpha)
+	@C# static bool TCODConsole::renderCredits(int x, int y, bool alpha)
+	@Lua tcod.console.renderCredits(x, y, alpha)
+	@Param x,y Position of the credits text in your root console
+	@Param alpha If true, credits are transparently added on top of the existing screen.
+		For this to work, this function must be placed between your screen rendering code and the console flush.
+	@CppEx
+      TCODConsole::initRoot(80,50,"The Chronicles Of Doryen v0.1",false); // initialize the root console
+      bool endCredits=false;
+      while ( ! TCODConsole::isWindowClosed() ) { // your game loop
+          // your game rendering here...
+          // render transparent credits near the center of the screen
+          if (! endCredits ) endCredits=TCODConsole::renderCredits(35,25,true);
+          TCODConsole::flush();
+      }
+	@CEx
+      TCOD_console_init_root(80,50,"The Chronicles Of Doryen v0.1",false);
+      bool end_credits=false;
+      while ( ! TCOD_console_is_window_closed() ) {
+          // your game rendering here...
+          // render transparent credits near the center of the screen
+          if (! end_credits ) end_credits=TCOD_console_credits_render(35,25,true);
+          TCOD_console_flush();
+      }
+	@PyEx
+      libtcod.console_init_root(80,50,"The Chronicles Of Doryen v0.1",False)
+      end_credits=False
+      while not libtcod.console_is_window_closed() :
+          // your game rendering here...
+          // render transparent credits near the center of the screen
+          if (not end_credits )  : end_credits=libtcod.console_credits_render(35,25,True)
+          libtcod.console_flush()
+	@LuaEx
+		tcod.console.initRoot(80,50,"The Chronicles Of Doryen v0.1") -- initialize the root console
+		endCredits=false
+		while not tcod.console.isWindowClosed() do -- your game loop
+			-- your game rendering here...
+			-- render transparent credits near the center of the screen
+			if not endCredits then endCredits=tcod.console.renderCredits(35,25,true) end
+			tcod.console.flush()
+		end
+	*/
+	static bool renderCredits(int x, int y, bool alpha);
+
+	/**
+	@PageName console_credits
+	@FuncTitle Restart the credits animation
+	@FuncDesc When using rederCredits, you can restart the credits animation from the begining before it's finished by calling this function.
+	@Cpp static void TCODConsole::resetCredits()
+	@C void TCOD_console_credits_reset()
+	@Py console_credits_reset()
+	@C# static void TCODConsole::resetCredits()
+	@Lua tcod.console.resetCredits()
+	*/
+	static void resetCredits();
+
+	/**
+	@PageName console_draw
+	@PageTitle Drawing on the root console
+	@PageFather console
+	*/
+
+	/**
+	@PageName console_draw_basic
+	@PageTitle Basic printing functions
+	@PageFather console_draw
+	@FuncTitle Setting the default background color
+	@FuncDesc This function changes the default background color for a console. The default background color is used by several drawing functions like clear, putChar, ...
+	@Cpp void TCODConsole::setDefaultBackground(TCODColor back)
+	@C void TCOD_console_set_default_background(TCOD_console_t con,TCOD_color_t back)
+	@Py console_set_default_background(con,back)
+	@C# void TCODConsole::setBackgroundColor(TCODColor back)
+	@Lua Console:setBackgroundColor(back)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param back the new default background color for this console
+	@CppEx TCODConsole::root->setDefaultBackground(myColor)
+	@CEx TCOD_console_set_default_background(NULL, my_color)
+	@PyEx litbcod.console_set_default_background(0, my_color)
+	@Lua libtcod.TCODConsole_root:setBackgroundColor( myColor )
+	*/
+	void setDefaultBackground(TCODColor back);
+
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Setting the default foreground color
+	@FuncDesc This function changes the default foreground color for a console. The default foreground color is used by several drawing functions like clear, putChar, ...
+	@Cpp void TCODConsole::setDefaultForeground(TCODColor fore)
+	@C void TCOD_console_set_default_foreground(TCOD_console_t con,TCOD_color_t fore)
+	@Py console_set_default_foreground(con, fore)
+	@C# void TCODConsole::setForegroundColor(TCODColor fore)
+	@Lua Console:setForegroundColor(fore)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param fore the new default foreground color for this console
+	@CppEx TCODConsole::root->setDefaultForeground(myColor)
+	@CEx TCOD_console_set_default_foreground(NULL, my_color)
+	@PyEx litbcod.console_set_default_foreground(0, my_color)
+	@LuaEx libtcod.TCODConsole_root:setForegroundColor( myColor )
+	*/
+	void setDefaultForeground(TCODColor fore);
+
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Clearing a console
+	@FuncDesc This function modifies all cells of a console :
+		* set the cell's background color to the console default background color
+		* set the cell's foreground color to the console default foreground color
+		* set the cell's ASCII code to 32 (space)
+	@Cpp void TCODConsole::clear()
+	@C void TCOD_console_clear(TCOD_console_t con)
+	@Py console_clear(con)
+	@C# void TCODConsole::clear()
+	@Lua Console:clear()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	void clear();
+
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Setting the background color of a cell
+	@FuncDesc This function modifies the background color of a cell, leaving other properties (foreground color and ASCII code) unchanged.
+	@Cpp void TCODConsole::setCharBackground(int x, int y, const TCODColor &col, TCOD_bkgnd_flag_t flag = TCOD_BKGND_SET)
+	@C void TCOD_console_set_char_background(TCOD_console_t con,int x, int y, TCOD_color_t col, TCOD_bkgnd_flag_t flag)
+	@Py console_set_char_background(con, x,  y, col, flag=BKGND_SET)
+	@C#
+		void TCODConsole::setCharBackground(int x, int y, TCODColor col)
+		void TCODConsole::setCharBackground(int x, int y, TCODColor col, TCODBackgroundFlag flag)
+	@Lua
+		Console:setCharBackground(x, y, col)
+		Console:setCharBackground(x, y, col, flag)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param col the background color to use. You can use color constants
+	@Param flag this flag defines how the cell's background color is modified. See <a href="console_bkgnd_flag_t.html">TCOD_bkgnd_flag_t</a>
+	*/
+	void setCharBackground(int x, int y, const TCODColor &col, TCOD_bkgnd_flag_t flag = TCOD_BKGND_SET);
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Setting the foreground color of a cell
+	@FuncDesc This function modifies the foreground color of a cell, leaving other properties (background color and ASCII code) unchanged.
+	@Cpp void TCODConsole::setCharForeground(int x, int y, const TCODColor &col)
+	@C void TCOD_console_set_char_foreground(TCOD_console_t con,int x, int y, TCOD_color_t col)
+	@Py console_set_char_foreground(con, x, y, col)
+	@C# void TCODConsole::setCharForeground(int x, int y, TCODColor col)
+	@Lua Console:setCharForeground(x, y, col)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param col the foreground color to use. You can use color constants
+	*/
+	void setCharForeground(int x, int y, const TCODColor &col);
+
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Setting the ASCII code of a cell
+	@FuncDesc This function modifies the ASCII code of a cell, leaving other properties (background and foreground colors) unchanged.
+		Note that since a clear console has both background and foreground colors set to black for every cell, using setchar will produce black characters on black background. Use putchar instead.
+	@Cpp void TCODConsole::setChar(int x, int y, int c)
+	@C void TCOD_console_set_char(TCOD_console_t con,int x, int y, int c)
+	@Py console_set_char(con, x,  y, c)
+	@C# void TCODConsole::setChar(int x, int y, int c)
+	@Lua Console:setChar(x, y, c)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param c the new ASCII code for the cell. You can use ASCII constants
+	*/
+	void setChar(int x, int y, int c);
+
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Setting every property of a cell using default colors
+	@FuncDesc This function modifies every property of a cell :
+		* update the cell's background color according to the console default background color (see TCOD_bkgnd_flag_t).
+		* set the cell's foreground color to the console default foreground color
+		* set the cell's ASCII code to c
+	@Cpp void TCODConsole::putChar(int x, int y, int c, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
+	@C void TCOD_console_put_char(TCOD_console_t con,int x, int y, int c, TCOD_bkgnd_flag_t flag)
+	@Py console_put_char( con, x,  y, c, flag=BKGND_DEFAULT)
+	@C#
+		void TCODConsole::putChar(int x, int y, int c)
+		void TCODConsole::putChar(int x, int y, int c, TCODBackgroundFlag flag)
+	@Lua
+		Console:putChar(x, y, c)
+		Console:putChar(x, y, c, flag)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param c the new ASCII code for the cell. You can use ASCII constants
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	*/
+	void putChar(int x, int y, int c, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
+
+	/**
+	@PageName console_draw_basic
+	@FuncTitle Setting every property of a cell using specific colors
+	@FuncDesc This function modifies every property of a cell :
+		* set the cell's background color to back.
+		* set the cell's foreground color to fore.
+		* set the cell's ASCII code to c.
+	@Cpp void TCODConsole::putCharEx(int x, int y, int c, const TCODColor & fore, const TCODColor & back)
+	@C void TCOD_console_put_char_ex(TCOD_console_t con,int x, int y, int c, TCOD_color_t fore, TCOD_color_t back)
+	@Py console_put_char_ex( con, x,  y, c, fore, back)
+	@C# void TCODConsole::putCharEx(int x, int y, int c, TCODColor fore, TCODColor back)
+	@Lua Console:putCharEx(x, y, c, fore, back)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param c the new ASCII code for the cell. You can use ASCII constants
+	@Param fore,back new foreground and background colors for this cell
+	*/
+	void putCharEx(int x, int y, int c, const TCODColor &fore, const TCODColor &back);
+
+	/**
+	@PageName console_bkgnd_flag_t
+	@PageTitle Background effect flags
+	@PageFather console_draw
+	@PageDesc This flag is used by most functions that modify a cell background color. It defines how the console's current background color is used to modify the cell's existing background color :
+		TCOD_BKGND_NONE : the cell's background color is not modified.
+		TCOD_BKGND_SET : the cell's background color is replaced by the console's default background color : newbk = curbk.
+		TCOD_BKGND_MULTIPLY : the cell's background color is multiplied by the console's default background color : newbk = oldbk * curbk
+		TCOD_BKGND_LIGHTEN : newbk = MAX(oldbk,curbk)
+		TCOD_BKGND_DARKEN : newbk = MIN(oldbk,curbk)
+		TCOD_BKGND_SCREEN : newbk = white - (white - oldbk) * (white - curbk) // inverse of multiply : (1-newbk) = (1-oldbk)*(1-curbk)
+		TCOD_BKGND_COLOR_DODGE : newbk = curbk / (white - oldbk)
+		TCOD_BKGND_COLOR_BURN : newbk = white - (white - oldbk) / curbk
+		TCOD_BKGND_ADD : newbk = oldbk + curbk
+		TCOD_BKGND_ADDALPHA(alpha) : newbk = oldbk + alpha*curbk
+		TCOD_BKGND_BURN : newbk = oldbk + curbk - white
+		TCOD_BKGND_OVERLAY : newbk = curbk.x <= 0.5 ? 2*curbk*oldbk : white - 2*(white-curbk)*(white-oldbk)
+		TCOD_BKGND_ALPHA(alpha) : newbk = (1.0f-alpha)*oldbk + alpha*(curbk-oldbk)
+		TCOD_BKGND_DEFAULT : use the console's default background flag
+		Note that TCOD_BKGND_ALPHA and TCOD_BKGND_ADDALPHA are MACROS that needs a float parameter between (0.0 and 1.0). TCOD_BKGND_ALPH and TCOD_BKGND_ADDA should not be used directly (else they will have the same effect as TCOD_BKGND_NONE).
+		For python, remove TCOD_ : libtcod.BKGND_NONE
+		For C# : None, Set, Multiply, Lighten, Darken, Screen, ColodDodge, ColorBurn, Add, Burn Overlay, Default
+		With lua, use tcod.None, ..., tcod.Default, BUT tcod.console.Alpha(value) and tcod.console.AddAlpha(value)
+	*/
+
+	/**
+	@PageName console_print
+	@PageTitle String drawing functions
+	@PageFather console_draw
+	@FuncTitle Setting the default background flag
+	@FuncDesc This function defines the background mode (see TCOD_bkgnd_flag_t) for the console.
+		This default mode is used by several functions (print, printRect, ...)
+	@Cpp void TCODConsole::setBackgroundFlag(TCOD_bkgnd_flag_t flag)
+	@C void TCOD_console_set_background_flag(TCOD_console_t con,TCOD_bkgnd_flag_t flag)
+	@Py console_set_background_flag(con, flag)
+	@C# void TCODConsole::setBackgroundFlag(TCODBackgroundFlag flag)
+	@Lua Console:setBackgroundFlag(flag)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	*/
+	void setBackgroundFlag(TCOD_bkgnd_flag_t flag);
+
+	/**
+	@PageName console_print
+	@FuncTitle Getting the default background flag
+	@FuncDesc This function returns the background mode (see TCOD_bkgnd_flag_t) for the console.
+		This default mode is used by several functions (print, printRect, ...)
+	@Cpp TCOD_bkgnd_flag_t TCODConsole::getBackgroundFlag() const
+	@C TCOD_bkgnd_flag_t TCOD_console_get_background_flag(TCOD_console_t con)
+	@Py console_get_background_flag(con)
+	@C# TCODBackgroundFlag TCODConsole::getBackgroundFlag()
+	@Lua Console:getBackgroundFlag()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	TCOD_bkgnd_flag_t getBackgroundFlag() const;
+
+	/**
+	@PageName console_print
+	@FuncTitle Setting the default alignment
+	@FuncDesc This function defines the default alignment (see TCOD_alignment_t) for the console.
+		This default alignment is used by several functions (print, printRect, ...).
+		Values for alignment : TCOD_LEFT, TCOD_CENTER, TCOD_RIGHT (in python, remove TCOD_ : libtcod.LEFT).
+		For C# and Lua : LeftAlignment, RightAlignment, CenterAlignment
+	@Cpp void TCODConsole::setAlignment(TCOD_alignment_t alignment)
+	@C void TCOD_console_set_alignment(TCOD_console_t con,TCOD_bkgnd_flag_t alignment)
+	@Py console_set_alignment(con, alignment)
+	@C# void TCODConsole::setAlignment(TCODAlignment alignment)
+	@Lua Console:setAlignment(alignment)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param alignment defines how the strings are printed on screen.
+	*/
+	void setAlignment(TCOD_alignment_t alignment);
+
+	/**
+	@PageName console_print
+	@FuncTitle Getting the default alignment
+	@FuncDesc This function returns the default alignment (see TCOD_alignment_t) for the console.
+		This default mode is used by several functions (print, printRect, ...).
+		Values for alignment : TCOD_LEFT, TCOD_CENTER, TCOD_RIGHT (in python, remove TCOD_ : libtcod.LEFT).
+		For C# and Lua : LeftAlignment, RightAlignment, CenterAlignment
+	@Cpp TCOD_alignment_t TCODConsole::getAlignment() const
+	@C TCOD_alignment_t TCOD_console_get_alignment(TCOD_console_t con)
+	@Py console_get_alignment(con)
+	@C# TCODAlignment TCODConsole::getAlignment()
+	@Lua Console:getAlignment()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	TCOD_alignment_t getAlignment() const;
+
+	/**
+	@PageName console_print
+	@FuncTitle Printing a string with default parameters
+	@FuncDesc This function print a string at a specific position using current default alignment, background flag, foreground and background colors.
+	@Cpp void TCODConsole::print(int x, int y, const char *fmt, ...)
+	@C void TCOD_console_print(TCOD_console_t con,int x, int y, const char *fmt, ...)
+	@Py console_print(con, x, y, fmt)
+	@C# void TCODConsole::print(int x, int y, string fmt)
+	@Lua Console:print(x, y, fmt)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinate of the character in the console, depending on the default alignment for this console :
+		* TCOD_LEFT : leftmost character of the string
+		* TCOD_CENTER : center character of the string
+		* TCOD_RIGHT : rightmost character of the string
+	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
+	*/
+	void print(int x, int y, const char *fmt, ...);
+
+	/**
+	@PageName console_print
+	@FuncTitle Printing a string with specific alignment and background mode
+	@FuncDesc This function print a string at a specific position using specific alignment and background flag, but default foreground and background colors.
+	@Cpp void TCODConsole::printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
+	@C void TCOD_console_print_ex(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
+	@Py console_print_ex(con, x, y, flag, alignment, fmt)
+	@C# void TCODConsole::printEx(int x, int y, TCODBackgroundFlag flag, TCODAlignment alignment, string fmt)
+	@Lua Console::printEx(x, y, flag, alignment, fmt)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinate of the character in the console, depending on the alignment :
+		* TCOD_LEFT : leftmost character of the string
+		* TCOD_CENTER : center character of the string
+		* TCOD_RIGHT : rightmost character of the string
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	@Param alignment defines how the strings are printed on screen.
+	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
+	*/
+	void printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
+
+	/**
+	@PageName console_print
+	@FuncTitle Printing a string with default parameters and autowrap
+	@FuncDesc This function draws a string in a rectangle inside the console, using default colors, alignment and background mode.
+		If the string reaches the borders of the rectangle, carriage returns are inserted.
+		If h > 0 and the bottom of the rectangle is reached, the string is truncated. If h = 0, the string is only truncated if it reaches the bottom of the console.
+		The function returns the height (number of console lines) of the printed string.
+	@Cpp int TCODConsole::printRect(int x, int y, int w, int h, const char *fmt, ...)
+	@C int TCOD_console_print_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...)
+	@Py console_print_rect(con, x, y, w, h, fmt)
+	@C# int TCODConsole::printRect(int x, int y, int w, int h, string fmt)
+	@Lua Console:printRect(x, y, w, h, fmt)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinate of the character in the console, depending on the alignment :
+		* TCOD_LEFT : leftmost character of the string
+		* TCOD_CENTER : center character of the string
+		* TCOD_RIGHT : rightmost character of the string
+	@Param w,h size of the rectangle
+		x <= x+w < console width
+		y <= y+h < console height
+	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
+	*/
+   	int printRect(int x, int y, int w, int h, const char *fmt, ...);
+
+	/**
+	@PageName console_print
+	@FuncTitle Printing a string with specific alignment and background mode and autowrap
+	@FuncDesc This function draws a string in a rectangle inside the console, using default colors, but specific alignment and background mode.
+		If the string reaches the borders of the rectangle, carriage returns are inserted.
+		If h > 0 and the bottom of the rectangle is reached, the string is truncated. If h = 0, the string is only truncated if it reaches the bottom of the console.
+		The function returns the height (number of console lines) of the printed string.
+	@Cpp int TCODConsole::printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
+	@C int TCOD_console_print_rect_ex(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...)
+	@Py console_print_rect_ex(con, x, y, w, h, flag, alignment, fmt)
+	@C# int TCODConsole::printRectEx(int x, int y, int w, int h, TCODBackgroundFlag flag, TCODAlignment alignment, string fmt)
+	@Lua Console:printRectEx(x, y, w, h, flag, alignment, fmt)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinate of the character in the console, depending on the alignment :
+		* TCOD_LEFT : leftmost character of the string
+		* TCOD_CENTER : center character of the string
+		* TCOD_RIGHT : rightmost character of the string
+	@Param w,h size of the rectangle
+		x <= x+w < console width
+		y <= y+h < console height
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	@Param alignment defines how the strings are printed on screen.
+	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
+	*/
+	int printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const char *fmt, ...);
+
+	/**
+	@PageName console_print
+	@FuncTitle Compute the height of an autowrapped string
+	@FuncDesc This function returns the expected height of an autowrapped string without actually printing the string with printRect or printRectEx
+	@Cpp int TCODConsole::getHeightRect(int x, int y, int w, int h, const char *fmt, ...)
+
+	@C int TCOD_console_get_height_rect(TCOD_console_t con,int x, int y, int w, int h, const char *fmt, ...)
+	@Py console_get_height_rect(con, x, y, w, h, fmt)
+	@C# int TCODConsole::getHeightRect(int x, int y, int w, int h, string fmt)
+	@Lua Console:getHeightRect(x, y, w, h, fmt)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinate of the rectangle upper-left corner in the console
+	@Param w,h size of the rectangle
+		x <= x+w < console width
+		y <= y+h < console height
+	@Param fmt printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string, except in C#.
+	*/
+	int getHeightRect(int x, int y, int w, int h, const char *fmt, ...);
+
+	/**
+	@PageName console_print
+	@FuncTitle Changing the colors while printing a string
+	@FuncDesc If you want to draw a string using different colors for each word, the basic solution is to call a string printing function several times, changing the default colors between each call.
+		The TCOD library offers a simpler way to do this, allowing you to draw a string using different colors in a single call. For this, you have to insert color control codes in your string.
+		A color control code is associated with a color set (a foreground color and a background color). If you insert this code in your string, the next characters will use the colors associated with the color control code.
+		There are 5 predefined color control codes :
+		For python, remove TCOD_ : libtcod.COLCTRL_1
+			TCOD_COLCTRL_1
+			TCOD_COLCTRL_2
+			TCOD_COLCTRL_3
+			TCOD_COLCTRL_4
+			TCOD_COLCTRL_5
+		To associate a color with a code, use setColorControl.
+		To go back to the console's default colors, insert in your string the color stop control code :
+			TCOD_COLCTRL_STOP
+
+		You can also use any color without assigning it to a control code, using the generic control codes :
+			TCOD_COLCTRL_FORE_RGB
+			TCOD_COLCTRL_BACK_RGB
+
+		Those controls respectively change the foreground and background color used to print the string characters. In the string, you must insert the r,g,b components of the color (between 1 and 255. The value 0 is forbidden because it represents the end of the string in C/C++) immediately after this code.
+	@Cpp static void TCODConsole::setColorControl(TCOD_colctrl_t con, const TCODColor &fore, const TCODColor &back)
+	@C void TCOD_console_set_color_control(TCOD_colctrl_t con, TCOD_color_t fore, TCOD_color_t back)
+	@Py console_set_color_control(con,fore,back)
+	@C# Not supported directly, use getRGBColorControlString and getColorControlString.
+	@Lua Not supported
+	@Param con the color control TCOD_COLCTRL_x, 1<=x<=5
+	@Param fore foreground color when this control is activated
+	@Param back background color when this control is activated
+	@CppEx
+		// A string with a red over black word, using predefined color control codes
+		TCODConsole::setColorControl(TCOD_COLCTRL_1,TCODColor::red,TCODColor::black);
+		TCODConsole::root->print(1,1,"String with a %cred%c word.",TCOD_COLCTRL_1,TCOD_COLCTRL_STOP);
+		// A string with a red over black word, using generic color control codes
+		TCODConsole::root->print(1,1,"String with a %c%c%c%c%c%c%c%cred%c word.",
+	          TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_BACK_RGB,1,1,1,TCOD_COLCTRL_STOP);
+		// A string with a red over black word, using generic color control codes
+		TCODConsole::root->print(1,1,"String with a %c%c%c%c%c%c%c%cred%c word.",
+	          TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_BACK_RGB,1,1,1,TCOD_COLCTRL_STOP);
+	@CEx
+		// A string with a red over black word, using predefined color control codes
+		TCOD_console_set_color_control(TCOD_COLCTRL_1,red,black);
+		TCOD_console_print(NULL,1,1,"String with a %cred%c word.",TCOD_COLCTRL_1,TCOD_COLCTRL_STOP);
+		// A string with a red word (over default background color), using generic color control codes
+		TCOD_console_print(NULL,1,1,"String with a %c%c%c%cred%c word.",
+			TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_STOP);
+		// A string with a red over black word, using generic color control codes
+		TCOD_console_print(NULL,1,1,"String with a %c%c%c%c%c%c%c%cred%c word.",
+			TCOD_COLCTRL_FORE_RGB,255,1,1,TCOD_COLCTRL_BACK_RGB,1,1,1,TCOD_COLCTRL_STOP);
+	@PyEx
+		# A string with a red over black word, using predefined color control codes
+		libtcod.console_set_color_control(libtcod.COLCTRL_1,litbcod.red,litbcod.black)
+		libtcod.console_print(0,1,1,"String with a %cred%c word."%(libtcod.COLCTRL_1,libtcod.COLCTRL_STOP))
+		# A string with a red word (over default background color), using generic color control codes
+		litbcod.console_print(0,1,1,"String with a %c%c%c%cred%c word."%(libtcod.COLCTRL_FORE_RGB,255,1,1,libtcod.COLCTRL_STOP))
+		# A string with a red over black word, using generic color control codes
+		libtcod.console_print(0,1,1,"String with a %c%c%c%c%c%c%c%cred%c word."%
+		        (libtcod.COLCTRL_FORE_RGB,255,1,1,libtcod.COLCTRL_BACK_RGB,1,1,1,libtcod.COLCTRL_STOP))
+
+	@C#Ex
+		TCODConsole.root.print(1,1,String.Format("String with a {0}red{1} word.",
+			TCODConsole.getRGBColorControlString(ColorControlForeground,TCODColor.red),
+			TCODConsole.getColorControlString(ColorControlStop));
+	*/
+	static void setColorControl(TCOD_colctrl_t con, const TCODColor &fore, const TCODColor &back);
+
+#ifndef NO_UNICODE
+	/**
+	@PageName console_print
+	@FuncTitle Unicode functions
+	@FuncDesc those functions are similar to their ASCII equivalent, but work with unicode strings (wchar_t in C/C++).
+		Note that unicode is not supported in the python wrapper.
+	@Cpp static void TCODConsole::mapStringToFont(const wchar_t *s, int fontCharX, int fontCharY)
+	@C void TCOD_console_map_string_to_font_utf(const wchar_t *s, int fontCharX, int fontCharY)
+	*/
+	static void mapStringToFont(const wchar_t *s, int fontCharX, int fontCharY);
+	/**
+	@PageName console_print
+	@Cpp void TCODConsole::print(int x, int y, const wchar_t *fmt, ...)
+	@C void TCOD_console_print_utf(TCOD_console_t con,int x, int y, const wchar_t *fmt, ...)
+	*/
+	void print(int x, int y, const wchar_t *fmt, ...);
+	/**
+	@PageName console_print
+	@Cpp void TCODConsole::printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
+	@C void TCOD_console_print_ex_utf(TCOD_console_t con,int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
+	*/
+	void printEx(int x, int y, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
+	/**
+	@PageName console_print
+	@Cpp int TCODConsole::printRect(int x, int y, int w, int h, const wchar_t *fmt, ...)
+	@C int TCOD_console_print_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...)
+	*/
+   	int printRect(int x, int y, int w, int h, const wchar_t *fmt, ...);
+
+	/**
+	@PageName console_print
+	@Cpp int TCODConsole::printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
+	@C int TCOD_console_print_rect_ex_utf(TCOD_console_t con,int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...)
+	*/
+	int printRectEx(int x, int y, int w, int h, TCOD_bkgnd_flag_t flag, TCOD_alignment_t alignment, const wchar_t *fmt, ...);
+
+	/**
+	@PageName console_print
+	@Cpp int TCODConsole::getHeightRect(int x, int y, int w, int h, const wchar_t *fmt, ...)
+	@C int TCOD_console_get_height_rect_utf(TCOD_console_t con,int x, int y, int w, int h, const wchar_t *fmt, ...)
+	*/
+	int getHeightRect(int x, int y, int w, int h, const wchar_t *fmt, ...);
+#endif
+
+	/**
+	@PageName console_advanced
+	@PageFather console_draw
+	@PageTitle Advanced printing functions
+	@FuncTitle Filling a rectangle with the background color
+	@FuncDesc Fill a rectangle inside a console. For each cell in the rectangle :
+		* set the cell's background color to the console default background color
+		* if clear is true, set the cell's ASCII code to 32 (space)
+	@Cpp void TCODConsole::rect(int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
+	@C void TCOD_console_rect(TCOD_console_t con,int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag)
+	@Py console_rect(con,x,  y,  w, h, clear, flag=BKGND_DEFAULT)
+	@C#
+		void TCODConsole::rect(int x, int y, int w, int h, bool clear)
+		void TCODConsole::rect(int x, int y, int w, int h, bool clear, TCODBackgroundFlag flag)
+	@Lua
+		Console:rect(x, y, w, h, clear)
+		Console:rect(x, y, w, h, clear, flag)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of rectangle upper-left corner in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param w,h size of the rectangle in the console.
+		x <= x+w < console width
+		y <= y+h < console height
+	@Param clear if true, all characters inside the rectangle are set to ASCII code 32 (space).
+		If false, only the background color is modified
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	*/
+	void rect(int x, int y, int w, int h, bool clear, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
+
+	/**
+	@PageName console_advanced
+	@FuncTitle Drawing an horizontal line
+	@FuncDesc Draws an horizontal line in the console, using ASCII code TCOD_CHAR_HLINE (196), and the console's default background/foreground colors.
+	@Cpp void TCODConsole::hline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
+	@C void TCOD_console_hline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag)
+	@Py console_hline(con,x,y,l,flag=BKGND_DEFAULT)
+	@C#
+		void TCODConsole::hline(int x,int y, int l)
+		void TCODConsole::hline(int x,int y, int l, TCODBackgroundFlag flag)
+	@Lua
+		Console:hline(x,y, l)
+		Console:hline(x,y, l, flag)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y Coordinates of the line's left end in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param l The length of the line in cells 1 <= l <= console width - x
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	*/
+	void hline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
+
+	/**
+	@PageName console_advanced
+	@FuncTitle Drawing an vertical line
+	@FuncDesc Draws an vertical line in the console, using ASCII code TCOD_CHAR_VLINE (179), and the console's default background/foreground colors.
+	@Cpp void TCODConsole::vline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT)
+	@C void TCOD_console_vline(TCOD_console_t con,int x,int y, int l, TCOD_bkgnd_flag_t flag)
+	@Py console_vline(con,x,y,l,flag=BKGND_DEFAULT)
+	@C#
+		void TCODConsole::vline(int x,int y, int l)
+		void TCODConsole::vline(int x,int y, int l, TCODBackgroundFlag flag)
+	@Lua
+		Console:vline(x,y, l)
+		Console:vline(x,y, l, flag)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y Coordinates of the line's upper end in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param l The length of the line in cells 1 <= l <= console height - y
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	*/
+	void vline(int x,int y, int l, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT);
+
+	/**
+	@PageName console_advanced
+	@FuncTitle Drawing a window frame
+	@FuncDesc This function calls the rect function using the supplied background mode flag, then draws a rectangle with the console's default foreground color. If fmt is not NULL, it is printed on the top of the rectangle, using inverted colors.
+	@Cpp void TCODConsole::printFrame(int x,int y,int w,int h, bool clear=true, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT, const char *fmt=NULL, ...)
+	@C void TCOD_console_print_frame(TCOD_console_t con,int x,int y,int w,int h, bool clear, TCOD_bkgnd_flag_t flag, const char *fmt, ...)
+	@Py console_print_frame(con,x, y, w, h, clear=True, flag=BKGND_DEFAULT, fmt=0)
+	@C#
+		void TCODConsole::printFrame(int x,int y, int w,int h)
+		void TCODConsole::printFrame(int x,int y, int w,int h, bool clear)
+		void TCODConsole::printFrame(int x,int y, int w,int h, bool clear, TCODBackgroundFlag flag)
+		void TCODConsole::printFrame(int x,int y, int w,int h, bool clear, TCODBackgroundFlag flag, string fmt)
+	@Lua
+		Console:printFrame(x,y, w,h)
+		Console:printFrame(x,y, w,h, clear)
+		Console:printFrame(x,y, w,h, clear, flag)
+		Console:printFrame(x,y, w,h, clear, flag, fmt)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y Coordinates of the rectangle's upper-left corner in the console.
+		0 <= x < console width
+		0 <= y < console height
+	@Param w,h size of the rectangle in the console.
+		x <= x+w < console width
+		y <= y+h < console height
+	@Param clear if true, all characters inside the rectangle are set to ASCII code 32 (space).
+		If false, only the background color is modified
+	@Param flag this flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t
+	@Param fmt if NULL, the funtion only draws a rectangle.
+		Else, printf-like format string, eventually followed by parameters. You can use control codes to change the colors inside the string.
+	*/
+	void printFrame(int x,int y,int w,int h, bool clear=true, TCOD_bkgnd_flag_t flag = TCOD_BKGND_DEFAULT, const char *fmt=NULL, ...);
+
+	/**
+	@PageName console_read
+	@PageTitle Reading the content of the console
+	@PageFather console_draw
+	@FuncTitle Get the console's width
+	@FuncDesc This function returns the width of a console (either the root console or an offscreen console)
+	@Cpp int TCODConsole::getWidth() const
+	@C int TCOD_console_get_width(TCOD_console_t con)
+	@Py console_get_width(con)
+	@C# int TCODConsole::getWidth()
+	@Lua Console:getWidth()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	int getWidth() const;
+
+	/**
+	@PageName console_read
+	@FuncTitle Get the console's height
+	@FuncDesc This function returns the height of a console (either the root console or an offscreen console)
+	@Cpp int TCODConsole::getHeight() const
+	@C int TCOD_console_get_height(TCOD_console_t con)
+	@Py console_get_height(con)
+	@C# int TCODConsole::getHeight()
+	@Lua Console:getHeight()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	int getHeight() const;
+
+	/**
+	@PageName console_read
+	@FuncTitle Reading the default background color
+	@FuncDesc This function returns the default background color of a console.
+	@Cpp TCODColor TCODConsole::getDefaultBackground() const
+	@C TCOD_color_t TCOD_console_get_default_background(TCOD_console_t con)
+	@Py console_get_default_background(con)
+	@C# TCODColor TCODConsole::getBackgroundColor()
+	@Lua Console:getBackgroundColor()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	TCODColor getDefaultBackground() const;
+
+	/**
+	@PageName console_read
+	@FuncTitle Reading the default foreground color
+	@FuncDesc This function returns the default foreground color of a console.
+	@Cpp TCODColor TCODConsole::getDefaultForeground() const
+	@C TCOD_color_t TCOD_console_get_default_foreground(TCOD_console_t con)
+	@Py console_get_default_foreground(con)
+	@C# TCODColor TCODConsole::getForegroundColor()
+	@Lua Console:getForegroundColor()
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	*/
+	TCODColor getDefaultForeground() const;
+
+	/**
+	@PageName console_read
+	@FuncTitle Reading the background color of a cell
+	@FuncDesc This function returns the background color of a cell.
+	@Cpp TCODColor TCODConsole::getCharBackground(int x, int y) const
+	@C TCOD_color_t TCOD_console_get_char_background(TCOD_console_t con,int x, int y)
+	@Py console_get_char_background(con,x,y)
+	@C# TCODColor TCODConsole::getCharBackground(int x, int y)
+	@Lua Console::getCharBackground(x, y)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	*/
+	TCODColor getCharBackground(int x, int y) const;
+
+	/**
+	@PageName console_read
+	@FuncTitle Reading the foreground color of a cell
+	@FuncDesc This function returns the foreground color of a cell.
+	@Cpp TCODColor TCODConsole::getCharForeground(int x, int y) const
+	@C TCOD_color_t TCOD_console_get_char_foreground(TCOD_console_t con,int x, int y)
+	@Py console_get_char_foreground(con,x,y)
+	@C# TCODColor TCODConsole::getCharForeground(int x, int y)
+	@Lua Console::getCharForeground(x, y)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	*/
+	TCODColor getCharForeground(int x, int y) const;
+
+	/**
+	@PageName console_read
+	@FuncTitle Reading the ASCII code of a cell
+	@FuncDesc This function returns the ASCII code of a cell.
+	@Cpp int TCODConsole::getChar(int x, int y) const
+	@C int TCOD_console_get_char(TCOD_console_t con,int x, int y)
+	@Py console_get_char(con,x,y)
+	@C# int TCODConsole::getChar(int x, int y)
+	@Lua Console::getChar(x, y)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param x,y coordinates of the cell in the console.
+		0 <= x < console width
+		0 <= y < console height
+	*/
+	int getChar(int x, int y) const;
+
+	/**
+	@PageName console_fading
+	@PageTitle Screen fading functions
+	@PageFather console_draw
+	@PageDesc Use these functions to easily fade to/from a color
+	@FuncTitle Changing the fading parameters
+	@FuncDesc This function defines the fading parameters, allowing to easily fade the game screen to/from a color. Once they are defined, the fading parameters are valid for ever. You don't have to call setFade for each rendered frame (unless you change the fading parameters).
+	@Cpp static void TCODConsole::setFade(uint8 fade, const TCODColor &fadingColor)
+	@C void TCOD_console_set_fade(uint8 fade, TCOD_color_t fadingColor)
+	@Py console_set_fade(fade, fadingColor)
+	@C# static void TCODConsole::setFade(byte fade, TCODColor fadingColor)
+	@Lua tcod.console.setFade(fade, fadingColor)
+	@Param fade the fading amount. 0 => the screen is filled with the fading color. 255 => no fading effect
+	@Param fadingColor the color to use during the console flushing operation
+	@CppEx
+		for (int fade=255; fade >= 0; fade --) {
+			TCODConsole::setFade(fade,TCODColor::black);
+			TCODConsole::flush();
+		}
+	@CEx
+		int fade;
+		for (fade=255; fade >= 0; fade --) {
+			TCOD_console_setFade(fade,TCOD_black);
+			TCOD_console_flush();
+		}
+	@PyEx
+		for fade in range(255,0) :
+			libtcod.console_setFade(fade,libtcod.black)
+			libtcod.console_flush()
+	@LuaEx
+		for fade=255,0,-1 do
+			tcod.console.setFade(fade,tcod.color.black)
+			tcod.console.flush()
+		end
+	*/
+	static void setFade(uint8 fade, const TCODColor &fadingColor);
+
+	/**
+	@PageName console_fading
+	@FuncTitle Reading the fade amount
+	@FuncDesc This function returns the current fade amount, previously defined by setFade.
+	@Cpp static uint8 TCODConsole::getFade()
+	@C uint8 TCOD_console_get_fade()
+	@Py console_get_fade()
+	@C# static byte TCODConsole::getFade()
+	@Lua tcod.console.getFade()
+	*/
+	static uint8 getFade();
+
+	/**
+	@PageName console_fading
+	@FuncTitle Reading the fading color
+	@FuncDesc This function returns the current fading color, previously defined by setFade.
+	@Cpp static TCODColor TCODConsole::getFadingColor()
+	@C TCOD_color_t TCOD_console_get_fading_color()
+	@Py console_get_fading_color()
+	@C# static TCODColor TCODConsole::getFadingColor()
+	@Lua tcod.console.getFadingColor()
+	*/
+	static TCODColor getFadingColor();
+
+	/**
+	@PageName console_flush
+	@PageFather console
+	@PageTitle Flushing the root console
+	@FuncDesc Once the root console is initialized, you can use one of the printing functions to change the background colors, the foreground colors or the ASCII characters on the console.
+		Once you've finished rendering the root console, you have to actually apply the updates to the screen with this function.
+	@Cpp static void TCODConsole::flush()
+	@C void TCOD_console_flush()
+	@Py console_flush()
+	@C# static void TCODConsole::flush()
+	@Lua tcod.console.flush()
+	*/
+	static void flush();
+
+	/**
+	@PageName console_ascii
+	@PageTitle ASCII constants
+	@PageFather console_draw
+	@FuncDesc Some useful graphic characters in the terminal.bmp font. For the python version, remove TCOD_ from the constants. C# and Lua is in parenthesis :
+		Single line walls:
+		TCOD_CHAR_HLINE=196 (HorzLine)
+		TCOD_CHAR_VLINE=179 (VertLine)
+		TCOD_CHAR_NE=191 (NE)
+		TCOD_CHAR_NW=218 (NW)
+		TCOD_CHAR_SE=217 (SE)
+		TCOD_CHAR_SW=192 (SW)
+
+		Double lines walls:
+		TCOD_CHAR_DHLINE=205 (DoubleHorzLine)
+		TCOD_CHAR_DVLINE=186 (DoubleVertLine)
+		TCOD_CHAR_DNE=187 (DoubleNE)
+		TCOD_CHAR_DNW=201 (DoubleNW)
+		TCOD_CHAR_DSE=188 (DoubleSE)
+		TCOD_CHAR_DSW=200 (DoubleSW)
+
+		Single line vertical/horizontal junctions (T junctions):
+		TCOD_CHAR_TEEW=180 (TeeWest)
+		TCOD_CHAR_TEEE=195 (TeeEast)
+		TCOD_CHAR_TEEN=193 (TeeNorth)
+		TCOD_CHAR_TEES=194 (TeeSouth)
+
+		Double line vertical/horizontal junctions (T junctions):
+		TCOD_CHAR_DTEEW=185 (DoubleTeeWest)
+		TCOD_CHAR_DTEEE=204 (DoubleTeeEast)
+		TCOD_CHAR_DTEEN=202 (DoubleTeeNorth)
+		TCOD_CHAR_DTEES=203 (DoubleTeeSouth)
+
+		Block characters:
+		TCOD_CHAR_BLOCK1=176 (Block1)
+		TCOD_CHAR_BLOCK2=177 (Block2)
+		TCOD_CHAR_BLOCK3=178 (Block3)
+
+		Cross-junction between two single line walls:
+		TCOD_CHAR_CROSS=197 (Cross)
+
+		Arrows:
+		TCOD_CHAR_ARROW_N=24 (ArrowNorth)
+		TCOD_CHAR_ARROW_S=25 (ArrowSouth)
+		TCOD_CHAR_ARROW_E=26 (ArrowEast)
+		TCOD_CHAR_ARROW_W=27 (ArrowWest)
+
+		Arrows without tail:
+		TCOD_CHAR_ARROW2_N=30 (ArrowNorthNoTail)
+		TCOD_CHAR_ARROW2_S=31 (ArrowSouthNoTail)
+		TCOD_CHAR_ARROW2_E=16 (ArrowEastNoTail)
+		TCOD_CHAR_ARROW2_W=17 (ArrowWestNoTail)
+
+		Double arrows:
+		TCOD_CHAR_DARROW_H=29 (DoubleArrowHorz)
+		TCOD_CHAR_ARROW_V=18 (DoubleArrowVert)
+
+		GUI stuff:
+		TCOD_CHAR_CHECKBOX_UNSET=224
+		TCOD_CHAR_CHECKBOX_SET=225
+		TCOD_CHAR_RADIO_UNSET=9
+		TCOD_CHAR_RADIO_SET=10
+
+		Sub-pixel resolution kit:
+		TCOD_CHAR_SUBP_NW=226 (SubpixelNorthWest)
+		TCOD_CHAR_SUBP_NE=227 (SubpixelNorthEast)
+		TCOD_CHAR_SUBP_N=228 (SubpixelNorth)
+		TCOD_CHAR_SUBP_SE=229 (SubpixelSouthEast)
+		TCOD_CHAR_SUBP_DIAG=230 (SubpixelDiagonal)
+		TCOD_CHAR_SUBP_E=231 (SubpixelEast)
+		TCOD_CHAR_SUBP_SW=232 (SubpixelSouthWest)
+
+		Miscellaneous characters:
+		TCOD_CHAR_SMILY = 1 (Smilie)
+		TCOD_CHAR_SMILY_INV = 2 (SmilieInv)
+		TCOD_CHAR_HEART = 3 (Heart)
+		TCOD_CHAR_DIAMOND = 4 (Diamond)
+		TCOD_CHAR_CLUB = 5 (Club)
+		TCOD_CHAR_SPADE = 6 (Spade)
+		TCOD_CHAR_BULLET = 7 (Bullet)
+		TCOD_CHAR_BULLET_INV = 8 (BulletInv)
+		TCOD_CHAR_MALE = 11 (Male)
+		TCOD_CHAR_FEMALE = 12 (Female)
+		TCOD_CHAR_NOTE = 13 (Note)
+		TCOD_CHAR_NOTE_DOUBLE = 14 (NoteDouble)
+		TCOD_CHAR_LIGHT = 15 (Light)
+		TCOD_CHAR_EXCLAM_DOUBLE = 19 (ExclamationDouble)
+		TCOD_CHAR_PILCROW = 20 (Pilcrow)
+		TCOD_CHAR_SECTION = 21 (Section)
+		TCOD_CHAR_POUND = 156 (Pound)
+		TCOD_CHAR_MULTIPLICATION = 158 (Multiplication)
+		TCOD_CHAR_FUNCTION = 159 (Function)
+		TCOD_CHAR_RESERVED = 169 (Reserved)
+		TCOD_CHAR_HALF = 171 (Half)
+		TCOD_CHAR_ONE_QUARTER = 172 (OneQuarter)
+		TCOD_CHAR_COPYRIGHT = 184 (Copyright)
+		TCOD_CHAR_CENT = 189 (Cent)
+		TCOD_CHAR_YEN = 190 (Yen)
+		TCOD_CHAR_CURRENCY = 207 (Currency)
+		TCOD_CHAR_THREE_QUARTERS = 243 (ThreeQuarters)
+		TCOD_CHAR_DIVISION = 246 (Division)
+		TCOD_CHAR_GRADE = 248 (Grade)
+		TCOD_CHAR_UMLAUT = 249 (Umlaut)
+		TCOD_CHAR_POW1 = 251 (Pow1)
+		TCOD_CHAR_POW3 = 252 (Pow2)
+		TCOD_CHAR_POW2 = 253 (Pow3)
+		TCOD_CHAR_BULLET_SQUARE = 254 (BulletSquare)
+	*/
+
+	/**
+	@PageName console_input
+	@PageTitle Handling keyboard input
+	@PageDesc The keyboard handling functions allow you to get keyboard input from the user, either for turn by turn games (the function wait until the user press a key), or real time games (non blocking function).
+	<b>WARNING : for proper redraw event handling, the keyboard functions should always be called just after TCODConsole::flush !</b>
+	@PageFather console
+	*/
+
+/**
+	@PageName console_blocking_input
+	@PageTitle Blocking keyboard input
+	@PageFather console_input
+	@FuncDesc This function waits for the user to press a key. It returns the code of the key pressed as well as the corresponding character. See TCOD_key_t.
+		If the flush parameter is true, every pending keypress event is discarded, then the function wait for a new keypress.
+		If flush is false, the function waits only if there are no pending keypress events, else it returns the first event in the keyboard buffer.
+	@Cpp static TCOD_key_t TCODConsole::waitForKeypress(bool flush)
+	@C TCOD_key_t TCOD_console_wait_for_keypress(bool flush)
+	@Py console_wait_for_keypress(flush)
+	@C# static TCOD_key_t TCODConsole::waitForKeypress(bool flush)
+	@Lua tcod.console.waitForKeypress(flush)
+	@Param flush if true, all pending keypress events are flushed from the keyboard buffer. Else, return the first available event
+	@CppEx
+		TCOD_key_t key = TCODConsole::waitForKeypress(true);
+		if ( key.c == 'i' ) { ... open inventory ... }
+	@CEx
+		TCOD_key_t key = TCOD_console_wait_for_keypress(true);
+		if ( key.c == 'i' ) { ... open inventory ... }
+	@PyEx
+		key = libtcod.console_wait_for_keypress(True)
+		if key.c == ord('i') : # ... open inventory ...
+	@LuaEx
+		key = tcod.console.waitForKeypress(true)
+		if key.Character == 'i' then ... open inventory ... end
+	*/
+	static TCOD_key_t waitForKeypress(bool flush);
+	/**
+	@PageName console_non_blocking_input
+	@PageTitle Non blocking keyboard input
+	@PageFather console_input
+	@FuncDesc This function checks if the user has pressed a key. It returns the code of the key pressed as well as the corresponding character. See TCOD_key_t. If the user didn't press a key, this function returns the key code TCODK_NONE (NoKey for C# and Lua).
+		<b>Note that key repeat only results in TCOD_KEY_PRESSED events.</b>
+	@Cpp static TCOD_key_t TCODConsole::checkForKeypress(int flags=TCOD_KEY_RELEASED)
+	@C TCOD_key_t TCOD_console_check_for_keypress(int flags)
+	@Py console_check_for_keypress(flags=KEY_RELEASED)
+	@C# static TCODKey TCODConsole::checkForKeypress(int flags) // Use TCODKeyStatus
+	@Lua tcod.console.checkForKeypress(flags)
+	@Param flags A filter for key events (C# and Lua in parenthesis):
+		TCOD_KEY_PRESSED (KeyPressed) : only keypress events are returned
+		TCOD_KEY_RELEASED (KeyReleased): only key release events are returnes
+		TCOD_KEY_PRESSED|TCOD_KEY_RELEASED (KeyPressed+KeyReleased): events of both types are returned.
+	@CppEx
+		TCOD_key_t key = TCODConsole::checkForKeypress();
+		if ( key.vk == TCODK_NONE ) return; // no key pressed
+		if ( key.c == 'i' ) { ... open inventory ... }
+	@C
+		TCOD_key_t key = TCOD_console_check_for_keypress(TCOD_KEY_PRESSED);
+		if ( key.vk == TCODK_NONE ) return; // no key pressed
+		if ( key.c == 'i' ) { ... open inventory ... }
+	@Py
+		key = libtcod.console_check_for_keypress()
+		if key.vk == libtcod.KEY_NONE return # no key pressed
+		if key.c == ord('i') : # ... open inventory ...
+	@LuaEx
+		key = tcod.console.checkForKeypress()
+		if key.KeyCode == tcod.NoKey then return end -- no key pressed
+		if key.Character == 'i' then ... open inventory ... end
+	*/
+	static TCOD_key_t checkForKeypress(int flags=TCOD_KEY_RELEASED);
+	
+	/**
+	@PageName console_non_blocking_input
+	@PageTitle Non blocking keyboard input
+	@PageFather console_input
+	@FuncDesc You can also get the status of any special key at any time with :
+	@Cpp static bool TCODConsole::isKeyPressed(TCOD_keycode_t key)
+	@C bool TCOD_console_is_key_pressed(TCOD_keycode_t key)
+	@Py console_is_key_pressed(key)
+	@C# static bool TCODConsole::isKeyPressed(TCODKeyCode key)
+	@Lua tcod.console.isKeyPressed(key)
+	@Param key Any key code defined in keycode_t except TCODK_CHAR (Char) and TCODK_NONE (NoKey)
+	*/
+	static bool isKeyPressed(TCOD_keycode_t key);
+	/**
+	@PageName console_keyboard_repeat
+	@PageTitle Changing keyboard repeat delay
+	@PageFather console_input
+	@FuncDesc This function changes the keyboard repeat times.
+	@Cpp static void TCODConsole::setKeyboardRepeat(int initialDelay, int interval)
+	@C void TCOD_console_set_keyboard_repeat(int initial_delay, int interval)
+	@Py console_set_keyboard_repeat(initial_delay, interval)
+	@C# static void TCODConsole::setKeyboardRepeat(int initialDelay, int interval)
+	@Lua tcod.console.setKeyboardRepeat(initialDelay, interval)
+	@Param initialDelay delay in millisecond between the time when a key is pressed, and keyboard repeat begins. If 0, keyboard repeat is disabled
+	@Param interval interval in millisecond between keyboard repeat events
+	*/
+	static void setKeyboardRepeat(int initialDelay,int interval);
+	/**
+	@PageName console_keyboard_repeat
+	@FuncDesc You can also disable the keyboard repeat feature with this function (it's equivalent to setKeyboardRepeat(0,0) ).
+	@Cpp static void TCODConsole::disableKeyboardRepeat()
+	@C void TCOD_console_disable_keyboard_repeat()
+	@Py console_disable_keyboard_repeat()
+	@C# static void TCODConsole::disableKeyboardRepeat()
+	@Lua tcod.console.disableKeyboardRepeat()
+	*/
+	static void disableKeyboardRepeat();
+
+	/**
+	@PageName console_key_t
+	@PageTitle 	Keyboard event structure
+	@PageFather console_input
+	@PageDesc This structure contains information about a key pressed/released by the user.
+	@C
+		typedef struct {
+			TCOD_keycode_t vk;
+			char c;
+			bool pressed;
+			bool lalt;
+			bool lctrl;
+			bool ralt;
+			bool rctrl;
+			bool shift;
+		} TCOD_key_t;
+	@Lua
+		key.KeyCode
+		key.Character
+		key.Pressed
+		key.LeftAlt
+		key.LeftControl
+		key.RightAlt
+		key.RightControl
+		key.Shift
+	@Param vk An arbitrary value representing the physical key on the keyboard. Possible values are stored in the TCOD_keycode_t enum. If no key was pressed, the value is TCODK_NONE
+	@Param c If the key correspond to a printable character, the character is stored in this field. Else, this field contains 0.
+	@Param pressed true if the event is a key pressed, or false for a key released.
+	@Param lalt This field represents the status of the left Alt key : true => pressed, false => released.
+	@Param lctrl This field represents the status of the left Control key : true => pressed, false => released.
+	@Param ralt This field represents the status of the right Alt key : true => pressed, false => released.
+	@Param rctrl This field represents the status of the right Control key : true => pressed, false => released.
+	@Param shift This field represents the status of the shift key : true => pressed, false => released.
+	*/
+
+	/**
+	@PageName console_keycode_t
+	@PageTitle 	Key codes
+	@PageFather console_input
+	@PageDesc TCOD_keycode_t is a libtcod specific code representing a key on the keyboard.
+		For python, replace TCODK by KEY: libtcod.KEY_NONE. C# and Lua, the value is in parenthesis. Possible values are :
+		When no key was pressed (see checkForKeypress) : TCOD_NONE (NoKey)
+		Special keys :
+		TCODK_ESCAPE (Escape)
+		TCODK_BACKSPACE (Backspace)
+		TCODK_TAB (Tab)
+		TCODK_ENTER (Enter)
+		TCODK_SHIFT (Shift)
+		TCODK_CONTROL (Control)
+		TCODK_ALT (Alt)
+		TCODK_PAUSE (Pause)
+		TCODK_CAPSLOCK (CapsLock)
+		TCODK_PAGEUP (PageUp)
+		TCODK_PAGEDOWN (PageDown)
+		TCODK_END (End)
+		TCODK_HOME (Home)
+		TCODK_UP (Up)
+		TCODK_LEFT (Left)
+		TCODK_RIGHT (Right)
+		TCODK_DOWN (Down)
+		TCODK_PRINTSCREEN (Printscreen)
+		TCODK_INSERT (Insert)
+		TCODK_DELETE (Delete)
+		TCODK_LWIN (Lwin)
+		TCODK_RWIN (Rwin)
+		TCODK_APPS (Apps)
+		TCODK_KPADD (KeypadAdd)
+		TCODK_KPSUB (KeypadSubtract)
+		TCODK_KPDIV (KeypadDivide)
+		TCODK_KPMUL (KeypadMultiply)
+		TCODK_KPDEC (KeypadDecimal)
+		TCODK_KPENTER (KeypadEnter)
+		TCODK_F1 (F1)
+		TCODK_F2 (F2)
+		TCODK_F3 (F3)
+		TCODK_F4 (F4)
+		TCODK_F5 (F5)
+		TCODK_F6 (F6)
+		TCODK_F7 (F7)
+		TCODK_F8 (F8)
+		TCODK_F9 (F9)
+		TCODK_F10 (F10)
+		TCODK_F11 (F11)
+		TCODK_F12 (F12)
+		TCODK_NUMLOCK (Numlock)
+		TCODK_SCROLLLOCK (Scrolllock)
+		TCODK_SPACE (Space)
+
+		numeric keys :
+
+		TCODK_0 (Zero)
+		TCODK_1 (One)
+		TCODK_2 (Two)
+		TCODK_3 (Three)
+		TCODK_4 (Four)
+		TCODK_5 (Five)
+		TCODK_6 (Six)
+		TCODK_7 (Seven)
+		TCODK_8 (Eight)
+		TCODK_9 (Nine)
+		TCODK_KP0 (KeypadZero)
+		TCODK_KP1 (KeypadOne)
+		TCODK_KP2 (KeypadTwo)
+		TCODK_KP3 (KeypadThree)
+		TCODK_KP4 (KeypadFour)
+		TCODK_KP5 (KeypadFive)
+		TCODK_KP6 (KeypadSix)
+		TCODK_KP7 (KeypadSeven)
+		TCODK_KP8 (KeypadEight)
+		TCODK_KP9 (KeypadNine)
+
+		Any other (printable) key :
+
+		TCODK_CHAR (Char)
+
+		Codes starting with TCODK_KP represents keys on the numeric keypad (if available).
+	*/
+
+	/**
+	@PageName console_offscreen
+	@PageFather console
+	@PageTitle Using off-screen consoles
+	@PageDesc The offscreen consoles allow you to draw on secondary consoles as you would do with the root console. You can then blit those secondary consoles on the root console. This allows you to use local coordinate space while rendering a portion of the final screen, and easily move components of the screen without modifying the rendering functions.
+	@FuncTitle Creating an offscreen console
+	@FuncDesc You can create as many off-screen consoles as you want by using this function. You can draw on them as you would do with the root console, but you cannot flush them to the screen. Else, you can blit them on other consoles, including the root console. See blit. The C version of this function returns a console handler that you can use in most console drawing functions.
+	@Cpp TCODConsole::TCODConsole(int w, int h)
+	@C TCOD_console_t TCOD_console_new(int w, int h)
+	@Py console_new(w,h)
+	@C# TCODConsole::TCODConsole(int w, int h)
+	@Lua tcod.Console(w,h)
+	@Param w,h the console size.
+		0 < w
+		0 < h
+	@CppEx
+		// Creating a 40x20 offscreen console, filling it with red and blitting it on the root console at position 5,5
+		TCODConsole *offscreenConsole = new TCODConsole(40,20);
+		offscreenConsole->setDefaultBackground(TCODColor::red);
+		offscreenConsole->clear();
+		TCODConsole::blit(offscreenConsole,0,0,40,20,TCODConsole::root,5,5,255);
+	@CEx
+		TCOD_console_t offscreen_console = TCOD_console_new(40,20);
+		TCOD_console_set_default_background(offscreen_console,TCOD_red);
+		TCOD_console_clear(offscreen_console);
+		TCOD_console_blit(offscreen_console,0,0,40,20,NULL,5,5,255);
+	@PyEx
+		offscreen_console = libtcod.console_new(40,20)
+		libtcod.console_set_background_color(offscreen_console,libtcod.red)
+		libtcod.console_clear(offscreen_console)
+		libtcod.console_blit(offscreen_console,0,0,40,20,0,5,5,255)
+	@LuaEx
+		-- Creating a 40x20 offscreen console, filling it with red and blitting it on the root console at position 5,5
+		offscreenConsole = tcod.Console(40,20)
+		offscreenConsole:setBackgroundColor(tcod.color.red)
+		offscreenConsole:clear()
+		tcod.console.blit(offscreenConsole,0,0,40,20,libtcod.TCODConsole_root,5,5,255)
+	*/
+	TCODConsole(int w, int h);
+	
+	/**
+	@PageName console_offscreen
+	@FuncTitle Creating an offscreen console from a .asc or .apf file
+	@FuncDesc You can create an offscreen console from a file created with Ascii Paint with this constructor
+	@Cpp TCODConsole::TCODConsole(const char *filename)
+	@C TCOD_console_t TCOD_console_from_file(const char *filename)
+	@Param filename path to the .asc or .apf file created with Ascii Paint
+	@CppEx
+		// Creating an offscreen console, filling it with data from the .asc file
+		TCODConsole *offscreenConsole = new TCODConsole("myfile.asc");
+	@CEx
+		TCOD_console_t offscreen_console = TCOD_console_from_file("myfile.apf");
+	*/
+	TCODConsole(const char *filename);
+
+	/**
+	@PageName console_offscreen
+	@FuncTitle Loading an offscreen console from a .asc file
+	@FuncDesc You can load data from a file created with Ascii Paint with this function. When needed, the console will be resized to fit the file size. The function returns false if it couldn't read the file.
+	@Cpp bool TCODConsole::loadAsc(const char *filename)
+	@C bool TCOD_console_load_asc(TCOD_console_t con, const char *filename)
+	@Param con in the C and Python versions, the offscreen console handler
+	@Param filename path to the .asc file created with Ascii Paint
+	@CppEx
+		// Creating a 40x20 offscreen console
+		TCODConsole *offscreenConsole = new TCODConsole(40,20);
+		// possibly resizing it and filling it with data from the .asc file
+		offscreenConsole->loadAsc("myfile.asc");
+	@CEx
+		TCOD_console_t offscreen_console = TCOD_console_new(40,20);
+		TCOD_console_load_asc(offscreen_console,"myfile.asc");
+	*/
+	bool loadAsc(const char *filename);
+	/**
+	@PageName console_offscreen
+	@FuncTitle Loading an offscreen console from a .apf file
+	@FuncDesc You can load data from a file created with Ascii Paint with this function. When needed, the console will be resized to fit the file size. The function returns false if it couldn't read the file.
+	@Cpp bool TCODConsole::loadApf(const char *filename)
+	@C bool TCOD_console_load_apf(TCOD_console_t con, const char *filename)
+	@Param con in the C and Python versions, the offscreen console handler
+
+	@Param filename path to the .apf file created with Ascii Paint
+
+	@CppEx
+		// Creating a 40x20 offscreen console
+		TCODConsole *offscreenConsole = new TCODConsole(40,20);
+		// possibly resizing it and filling it with data from the .apf file
+		offscreenConsole->loadApf("myfile.apf");
+	@CEx
+		TCOD_console_t offscreen_console = TCOD_console_new(40,20);
+		TCOD_console_load_apf(offscreen_console,"myfile.asc");
+	*/
+	bool loadApf(const char *filename);
+
+    /**
+	@PageName console_offscreen
+	@FuncTitle Saving a console to a .asc file
+	@FuncDesc You can save data from a console to Ascii Paint format with this function. The function returns false if it couldn't write the file. This is the only ASC function that works also with the root console !
+	@Cpp bool TCODConsole::saveAsc(const char *filename) const
+	@C bool TCOD_console_save_asc(TCOD_console_t con, const char *filename)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param filename path to the .asc file to be created
+	@CppEx
+		console->saveAsc("myfile.asc");
+	@CEx
+		TCOD_console_save_asc(console,"myfile.asc");
+	*/
+	bool saveAsc(const char *filename) const;
+
+    /**
+	@PageName console_offscreen
+	@FuncTitle Saving a console to a .apf file
+	@FuncDesc You can save data from a console to Ascii Paint format with this function. The function returns false if it couldn't write the file. This is the only ASC function that works also with the root console !
+	@Cpp bool TCODConsole::saveApf(const char *filename) const
+	@C bool TCOD_console_save_apf(TCOD_console_t con, const char *filename)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param filename path to the .apf file to be created
+	@CppEx
+		console->saveApf("myfile.apf");
+	@CEx
+		TCOD_console_save_apf(console,"myfile.apf");
+	*/
+	bool saveApf(const char *filename) const;
+	
+	/**
+	@PageName console_offscreen
+	@FuncTitle Blitting a console on another one
+	@FuncDesc This function allows you to blit a rectangular area of the source console at a specific position on a destination console. It can also simulate alpha transparency with the fade parameter.
+	@Cpp static void blit(const TCODConsole *src,int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole *dst, int xDst, int yDst, float foregroundAlpha=1.0f, float backgroundAlpha=1.0f)
+	@C void TCOD_console_blit(TCOD_console_t src,int xSrc, int ySrc, int wSrc, int hSrc, TCOD_console_t dst, int xDst, int yDst, float foreground_alpha, float background_alpha)
+	@Py console_blit(src,xSrc,ySrc,xSrc,hSrc,dst,xDst,yDst,foregroundAlpha=1.0,backgroundAlpha=1.0)
+	@C#
+		static void TCODConsole::blit(TCODConsole src, int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole dst, int xDst, int yDst)
+		static void TCODConsole::blit(TCODConsole src, int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole dst, int xDst, int yDst, float foreground_alpha)
+		static void TCODConsole::blit(TCODConsole src, int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole dst, int xDst, int yDst, float foreground_alpha, float background_alpha)
+	@Lua
+		tcod.console.blit(src, xSrc, ySrc, wSrc, hSrc, dst, xDst, yDst)
+		tcod.console.blit(src, xSrc, ySrc, wSrc, hSrc, dst, xDst, yDst, foreground_alpha)
+		tcod.console.blit(src, xSrc, ySrc, wSrc, hSrc, dst, xDst, yDst, foreground_alpha, background_alpha)
+	@Param src The source console that must be blitted on another one.
+	@Param xSrc,ySrc,wSrc,hSrc The rectangular area of the source console that will be blitted. If wSrc and/or hSrc == 0, the source console width/height are used
+	@Param dst The destination console.
+	@Param xDst,yDst Where to blit the upper-left corner of the source area in the destination console.
+	@Param foregroundAlpha,backgroundAlpha Alpha transparency of the blitted console.
+		0.0 => The source console is completely transparent. This function does nothing.
+		1.0 => The source console is opaque. Its cells replace the destination cells.
+		0 < fade < 1.0 => The source console is partially blitted, simulating real transparency.
+	@CppEx
+		// Cross-fading between two offscreen consoles. We use two offscreen consoles with the same size as the root console. We render a different screen on each offscreen console. When the user hits a key, we do a cross-fading from the first screen to the second screen.
+		TCODConsole *off1 = new TCODConsole(80,50);
+		TCODConsole *off2 = new TCODConsole(80,50);
+		... print screen1 on off1
+		... print screen2 of off2
+		// render screen1 in the game window
+		TCODConsole::blit(off1,0,0,80,50,TCODConsole::root,0,0);
+		TCODConsole::flush();
+		// wait or a keypress
+		TCODConsole::waitForKeypress(true);
+		// do a cross-fading from off1 to off2
+		for (int i=1; i <= 255; i++) {
+			TCODConsole::blit(off1,0,0,80,50,TCODConsole::root,0,0); // renders the first screen (opaque)
+			TCODConsole::blit(off2,0,0,80,50,TCODConsole::root,0,0,i/255.0,i/255.0); // renders the second screen (transparent)
+			TCODConsole::flush();
+		}
+	@CEx
+		TCOD_console_t off1 = TCOD_console_new(80,50);
+		TCOD_console_t off2 = TCOD_console_new(80,50);
+		int i;
+		... print screen1 on off1
+		... print screen2 of off2
+		// render screen1 in the game window
+		TCOD_console_blit(off1,0,0,80,50,NULL,0,0,1.0,1.0);
+		TCOD_console_flush();
+		// wait or a keypress
+		TCOD_console_wait_for_keypress(true);
+		// do a cross-fading from off1 to off2
+		for (i=1; i <= 255; i++) {
+			TCOD_console_blit(off1,0,0,80,50,NULL,0,0,1.0,1.0); // renders the first screen (opaque)
+			TCOD_console_blit(off2,0,0,80,50,NULL,0,0,i/255.0,i/255.0); // renders the second screen (transparent)
+			TCOD_console_flush();
+		}
+	@PyEx
+		off1 = libtcod.console_new(80,50)
+		off2 = libtcod.console_new(80,50)
+		... print screen1 on off1
+		... print screen2 of off2
+		# render screen1 in the game window
+		libtcod.console_blit(off1,0,0,80,50,0,0,0)
+		libtcod.console_flush()
+		# wait or a keypress
+		libtcod.console_wait_for_keypress(True)
+		# do a cross-fading from off1 to off2
+		for i in range(1,256) :
+			litbcod.console_blit(off1,0,0,80,50,0,0,0) # renders the first screen (opaque)
+			litbcod.console_blit(off2,0,0,80,50,0,0,0,i/255.0,i/255.0) # renders the second screen (transparent)
+			litbcod.console_flush()
+	@LuaEx
+		-- Cross-fading between two offscreen consoles. We use two offscreen consoles with the same size as the root console. We render a different screen on each offscreen console. When the user hits a key, we do a cross-fading from the first screen to the second screen.
+		off1 = tcod.Console(80,50)
+		off2 = tcod.Console(80,50)
+		... print screen1 on off1
+		... print screen2 of off2
+		-- render screen1 in the game window
+		root=libtcod.TCODConsole_root
+		tcod.console.blit(off1,0,0,80,50,root,0,0)
+		tcod.console.flush()
+		-- wait or a keypress
+		tcod.console.waitForKeypress(true)
+		-- do a cross-fading from off1 to off2
+		for i=1,255,1 do
+			tcod.console.blit(off1,0,0,80,50,root,0,0) -- renders the first screen (opaque)
+			tcod.console.blit(off2,0,0,80,50,root,0,0,i/255,i/255) -- renders the second screen (transparent)
+			tcod.console.flush()
+		end
+	*/
+	static void blit(const TCODConsole *src,int xSrc, int ySrc, int wSrc, int hSrc, TCODConsole *dst, int xDst, int yDst, float foreground_alpha=1.0f, float background_alpha=1.0f);
+	/**
+	@PageName console_offscreen
+	@FuncTitle Define a blit-transparent color
+	@FuncDesc This function defines a transparent background color for an offscreen console. All cells with this background color are ignored by the blit operation. You can use it to blit only some parts of the console.
+	@Cpp void TCODConsole::setKeyColor(const TCODColor &col)
+	@C void TCOD_console_set_key_color(TCOD_console_t con,TCOD_color_t col)
+	@Py console_set_key_color(con,col)
+	@C# void TCODConsole::setKeyColor(TCODColor col)
+	@Lua Console:setKeyColor(col)
+	@Param con in the C and Python versions, the offscreen console handler or NULL for the root console
+	@Param col the transparent background color
+	*/
+	void setKeyColor(const TCODColor &col);
+	/**
+	@PageName console_offscreen
+	@FuncTitle Destroying an offscreen console
+	@FuncDesc Use this function to destroy an offscreen console and release any resources allocated. Don't use it on the root console.
+	@Cpp TCODConsole::~TCODConsole()
+	@C void TCOD_console_delete(TCOD_console_t con)
+	@Py console_delete(con)
+	@C# void TCODConsole::Dispose()
+	@Lua through garbage collector
+	@Param con in the C and Python versions, the offscreen console handler
+	@CppEx
+		TCODConsole *off1 = new TCODConsole(80,50);
+		... use off1
+		delete off1; // destroy the offscreen console
+	@CEx
+		TCOD_console_t off1 = TCOD_console_new(80,50);
+		... use off1
+		TCOD_console_delete(off1); // destroy the offscreen console
+	@PyEx
+		off1 = libtcod.console_new(80,50)
+		... use off1
+		libtcod.console_delete(off1) # destroy the offscreen console
+	@LuaEx
+		off1 = tcod.Console(80,50)
+		... use off1
+		off1=nil -- release the reference
+	*/
+	virtual ~TCODConsole();
+
+	void setDirty(int x, int y, int w, int h);
+
+
+	TCODConsole(TCOD_console_t con) : data(con) {}
+
+    // ctrl = TCOD_COLCTRL_1...TCOD_COLCTRL_5 or TCOD_COLCTRL_STOP
+	static const char *getColorControlString( TCOD_colctrl_t ctrl );
+	// ctrl = TCOD_COLCTRL_FORE_RGB or TCOD_COLCTRL_BACK_RGB
+	static const char *getRGBColorControlString( TCOD_colctrl_t ctrl, const TCODColor & col );
+
+protected :
+	friend class TCODLIB_API TCODImage;
+	friend class TCODLIB_API TCODZip;
+	friend class TCODLIB_API TCODText;
+	TCODConsole();
+	TCOD_console_t data;
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/fov.hpp
@@ -0,0 +1,257 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_FOV_HPP
+#define _TCOD_FOV_HPP
+
+#include "fov_types.h"
+
+class TCODPath;
+
+/**
+ @PageName fov
+ @PageCategory Roguelike toolkits
+ @PageTitle Field of view
+ @PageDesc This toolkit allows to easily calculate the potential visible set of map cells from the player position.
+A cell is potentially visible if the line of sight from the player to the cell in unobstructed.
+ */
+
+class TCODLIB_API TCODMap {
+	public :
+		/**
+		@PageName fov_init
+		@PageFather fov
+		@PageTitle Building the map
+		@FuncTitle Creating the map object
+		@FuncDesc First, you have to allocate a map of the same size as your dungeon.
+		@Cpp TCODMap::TCODMap (int width, int height)
+		@C TCOD_map_t TCOD_map_new (int width, int height)
+		@Py map_new (width, height)
+		@C# TCODMap::TCODMap(int width, int height)
+		@Param width, height	The size of the map (in map cells).
+		*/		
+		TCODMap(int width, int height);
+		
+		/**
+		@PageName fov_init
+		@PageFather fov
+		@FuncTitle Defining the cell properties
+		@FuncDesc Then, build your dungeon by defining which cells let the light pass (by default, all cells block the light) and which cells are walkable (by default, all cells are not-walkable).
+		@Cpp void TCODMap::setProperties (int x, int y, bool isTransparent, bool isWalkable)
+		@C void TCOD_map_set_properties (TCOD_map_t map, int x, int y, bool is_transparent, bool is_walkable)
+		@Py map_set_properties (map, x, y, is_transparent, is_walkable)
+		@C# void TCODMap::setProperties (int x, int y, bool isTransparent, bool isWalkable)
+		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
+		@Param x, y	Coordinate of the cell that we want to update.
+		@Param isTransparent	If true, this cell will let the light pass else it will block the light.
+		@Param isWalkable	If true, creatures can walk true this cell (it is not a wall).
+		*/		
+		void setProperties(int x,int y, bool isTransparent, bool isWalkable);
+		
+		/**
+		@PageName fov_init
+		@PageFather fov
+		@FuncTitle Clearing the map
+		@FuncDesc You can clear an existing map (setting all cells to the chosen walkable/transparent values) with:
+		@Cpp void TCODMap::clear (bool transparent = false, bool walkable = false)
+		@C void TCOD_map_clear (TCOD_map_t map, bool transparent, bool walkable)
+		@Py map_clear (map, transparent = False, walkable = False)
+		@C#
+			void TCODMap::clear()
+			void TCODMap::clear(bool transparent)
+			void TCODMap::clear(bool transparent, bool walkable)
+		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
+		@Param walkable	Whether the cells should be walkable.
+		@Param transparent	Whether the cells should be transparent.
+		*/		
+		void clear(bool transparent=false, bool walkable=false);
+		
+		/**
+		@PageName fov_init
+		@PageFather fov
+		@FuncTitle Copying a map
+		@FuncDesc You can copy an existing map into another. You have to allocate the destination map first.
+		@Cpp void TCODMap::copy (const TCODMap * source)
+		@C void TCOD_map_copy (TCOD_map_t source, TCOD_map_t dest)
+		@Py map_copy (source, dest)
+		@C# void TCODMap::copy (TCODMap source)
+		@Param source	The map containing the source data.
+		@Param dest	In C and python version, the map where data is copied.
+		@CppEx 
+			TCODMap * map = new TCODMap(50,50); // allocate the map
+			map->setProperties(10,10,true,true); // set a cell as 'empty'
+			TCODMap * map2 = new TCODMap(10,10); // allocate another map
+			map2->copy(map); // copy map data into map2, reallocating it to 50x50
+		@CEx 
+			TCOD_map_t map = TCOD_map_new(50,50);
+			TCOD_map_t map2 = TCOD_map_new(10,10);
+			TCOD_map_set_properties(map,10,10,true,true);
+			TCOD_map_copy(map,map2);
+		@PyEx 
+			map = libtcod.map_new(50,50)
+			map2 = libtcod.map_new(10,10)
+			libtcod.map_set_properties(map,10,10,True,True)
+			libtcod.map_copy(map,map2)
+		*/		
+		void copy (const TCODMap *source);
+
+		/**
+		@PageName fov_compute
+		@PageTitle Computing the field of view
+		@PageFather fov
+		@FuncDesc Once your map is allocated and empty cells have been defined, you can calculate the field of view with :
+			<div class="code"><pre>typedef enum { FOV_BASIC, 
+               FOV_DIAMOND, 
+               FOV_SHADOW, 
+               FOV_PERMISSIVE_0,FOV_PERMISSIVE_1,FOV_PERMISSIVE_2,FOV_PERMISSIVE_3,
+               FOV_PERMISSIVE_4,FOV_PERMISSIVE_5,FOV_PERMISSIVE_6,FOV_PERMISSIVE_7,FOV_PERMISSIVE_8, 
+               FOV_RESTRICTIVE,
+               NB_FOV_ALGORITHMS } TCOD_fov_algorithm_t;
+            </pre></div>
+			* FOV_BASIC : classic libtcod fov algorithm (ray casted from the player to all the cells on the submap perimeter)
+			* FOV_DIAMOND : based on <a href="http://www.geocities.com/temerra/los_rays.html">this</a> algorithm
+			* FOV_SHADOW : based on <a href="http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting">this</a> algorithm
+			* FOV_PERMISSIVE_x : based on <a href="http://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View">this</a> algorithm
+			Permissive has a variable permissiveness parameter. You can either use the constants FOV_PERMISSIVE_x, x between 0 (the less permissive) and 8 (the more permissive), or using the macro FOV_PERMISSIVE(x). 
+			* FOV_RESTRICTIVE : Mingos' Restrictive Precise Angle Shadowcasting (MRPAS). Original implementation <a href="http://umbrarumregnum.110mb.com/download/mrpas">here</a>. Comparison of the algorithms :
+			Check <a href="http://roguecentral.org/libtcod/fov/fov.pdf">this</a>.
+		@Cpp void TCODMap::computeFov(int playerX,int playerY, int maxRadius=0,bool light_walls = true, TCOD_fov_algorithm_t algo = FOV_BASIC)
+		@C void TCOD_map_compute_fov(TCOD_map_t map, int player_x, int player_y, int max_radius, bool light_walls, TCOD_fov_algorithm_t algo)
+		@Py map_compute_fov(map, player_x, player_y, max_radius=0, light_walls=True, algo=FOV_BASIC )
+		@C# 
+			void TCODMap::computeFov(int playerX, int playerY)
+			void TCODMap::computeFov(int playerX, int playerY, int maxRadius)
+			void TCODMap::computeFov(int playerX, int playerY, int maxRadius,bool light_walls)
+			void TCODMap::computeFov(int playerX, int playerY, int maxRadius,bool light_walls, TCODFOVTypes algo)
+		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
+		@Param player_x,player_y	Position of the player in the map.
+			0 <= player_x < map width.
+			0 <= player_y < map height.
+		@Param maxRadius	If > 0, the fov is only computed up to maxRadius cells away from the player. Else, the range is unlimited.
+		@Param light_walls	Wether the wall cells near ground cells in fov must be in fov too.
+		@Param algo	FOV algorithm to use.
+		@CppEx 
+			TCODMap *map = new TCODMap(50,50); // allocate the map
+			map->setProperties(10,10,true,true); // set a cell as 'empty'
+			map->computeFov(10,10); // calculate fov from the cell 10x10 (basic raycasting, unlimited range, walls lighting on)
+		@CEx 
+			TCOD_map_t map = TCOD_map_new(50,50);
+			TCOD_map_set_properties(map,10,10,true,true);
+			TCOD_map_compute_fov(map,10,10,0,true,FOV_SHADOW); // using shadow casting
+		@PyEx 
+			map = libtcod.map_new(50,50)
+			libtcod.map_set_properties(map,10,10,True,True)
+			libtcod.map_compute_fov(map,10,10,0,True,libtcod.FOV_PERMISSIVE(2)) 
+		*/
+		void computeFov(int playerX,int playerY, int maxRadius = 0,bool light_walls = true, TCOD_fov_algorithm_t algo = FOV_BASIC);
+
+		/**
+		@PageName fov_get
+		@PageFather fov
+		@PageTitle Reading fov information
+		@FuncTitle Checking if a cell is in fov
+		@FuncDesc Once your computed the field of view, you can know if a cell is visible with :
+		@Cpp bool TCODMap::isInFov(int x, int y) const
+		@C bool TCOD_map_is_in_fov(TCOD_map_t map, int x, int y)
+		@Py map_is_in_fov(map, x, y)
+		@C# bool TCODMap::isInFov(int x, int y)
+		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
+		@Param x,y	Coordinates of the cell we want to check.
+			0 <= x < map width.
+			0 <= y < map height.
+		@CppEx 
+			TCODMap *map = new TCODMap(50,50); // allocate the map
+			map->setProperties(10,10,true,true); // set a cell as 'empty'
+			map->computeFov(10,10); // calculate fov from the cell 10x10
+			bool visible=map->isInFov(10,10); // is the cell 10x10 visible ?      
+		@CEx 
+			TCOD_map_t map = TCOD_map_new(50,50);
+			TCOD_map_set_properties(map,10,10,true,true);
+			TCOD_map_compute_fov(map,10,10);
+			bool visible = TCOD_map_is_in_fov(map,10,10);
+		@PyEx 
+			map = libtcod.map_new(50,50)
+			libtcod.map_set_properties(map,10,10,True,True)
+			libtcod.map_compute_fov(map,10,10)
+			visible = libtcod.map_is_in_fov(map,10,10)
+		*/		
+   		bool isInFov(int x,int y) const;
+   		/**
+   		@PageName fov_get
+   		@FuncTitle Checking a cell transparency/walkability
+   		@FuncDesc You can also retrieve transparent/walkable informations with :
+		@Cpp 
+			bool TCODMap::isTransparent(int x, int y) const
+			bool TCODMap::isWalkable(int x, int y) const
+		@C 
+			bool TCOD_map_is_transparent(TCOD_map_t map, int x, int y)
+			bool TCOD_map_is_walkable(TCOD_map_t map, int x, int y)
+		@Py 
+			map_is_transparent(map, x, y)
+			map_is_walkable(map, x, y)
+		@C# 
+			bool TCODMap::isTransparent(int x, int y)
+			bool TCODMap::isWalkable(int x, int y)
+		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
+		@Param x,y	Coordinates of the cell we want to check.
+			0 <= x < map width.
+			0 <= y < map height.
+		*/   		
+		bool isTransparent(int x, int y) const;
+		bool isWalkable(int x, int y) const;
+
+   		/**
+   		@PageName fov_get
+   		@FuncTitle Getting the map size
+   		@FuncDesc You can retrieve the map size with :
+		@Cpp 
+			int TCODMap::getWidth() const
+			int TCODMap::getHeight() const
+		@C 
+			int TCOD_map_get_width(TCOD_map_t map)
+			int TCOD_map_get_height(TCOD_map_t map)
+		@Py 
+			map_get_width(map)
+			map_get_height(map)
+		@C#
+			int TCODMap::getWidth()
+			int TCODMap::getHeight()
+		@Param map	In the C version, the map handler returned by the TCOD_map_new function.
+		*/   		
+   		int getWidth() const;
+		int getHeight() const;
+
+		virtual ~TCODMap();
+		void setInFov(int x,int y, bool fov);
+		int getNbCells() const;
+		friend class TCODLIB_API TCODPath;
+		friend class TCODLIB_API TCODDijkstra;
+//	protected :
+		TCOD_map_t data;
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/heightmap.hpp
@@ -0,0 +1,485 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _TCOD_HEIGHTMAP_HPP
+#define _TCOD_HEIGHTMAP_HPP
+
+/**
+ @PageName heightmap
+ @PageCategory Roguelike toolkits
+ @PageTitle Heightmap toolkit
+ @PageDesc This toolkit allows to create a 2D grid of float values using various algorithms.
+
+The code using the heightmap toolkit can be automatically generated with the heightmap tool (hmtool) included in the libtcod package.
+ */
+class TCODLIB_API TCODHeightMap {
+public :
+	int w,h;
+	float *values;
+
+	/**
+	@PageName heightmap_init
+	@PageFather heightmap
+	@PageTitle Creating a heightmap
+	@FuncTitle Creating an empty map
+	@FuncDesc As with other modules, you have to create a heightmap object first :
+		Note that whereas most other modules use opaque structs, the TCOD_heightmap_t fields can be freely accessed. Thus, the TCOD_heightmap_new function returns a TCOD_heightmap_t pointer, not a TCOD_heightmap_t. The w and h fields should not be modified after the heightmap creation. The newly created heightmap is filled with 0.0 values.
+	@Cpp TCODHeightMap::TCODHeightMap(int w, int h)
+	@C
+		typedef struct {
+			int w,h;
+			float *values;
+		} TCOD_heightmap_t;
+		TCOD_heightmap_t *TCOD_heightmap_new(int w,int h)
+	@Py heightmap_new(w,h)
+	@C# TCODHeightMap::TCODHeightMap(int w, int h)
+	@Param w,h	The width and height of the heightmap.
+	@CppEx TCODHeightMap myMap(50,50);
+	@CEx TCOD_heightmap_t *my_map=TCOD_heightmap_new(50,50);
+	@PyEx
+		map=libtcod.heightmap_new(50,50)
+		print map.w, map.h
+	*/
+	TCODHeightMap(int w, int h);
+
+	/**
+	@PageName heightmap_init
+	@FuncTitle Destroying a heightmap
+	@FuncDesc To release the resources used by a heightmap, destroy it with :
+	@Cpp TCODHeightMap::~TCODHeightMap()
+	@C void TCOD_heightmap_delete(TCOD_heightmap_t *hm)
+	@Py heightmap_delete(hm)
+	@C# void TCODHeightMap::Dispose()
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	*/
+	virtual ~TCODHeightMap();
+
+	/**
+	@PageName heightmap_base
+	@PageFather heightmap
+	@PageTitle Basic operations
+	@PageDesc Those are simple operations applied either on a single map cell or on every map cell.
+	@FuncTitle Setting a cell value
+	@FuncDesc Once the heightmap has been created, you can do some basic operations on the values inside it.
+		You can set a single value :
+	@Cpp void TCODHeightMap::setValue(int x, int y, float v)
+	@C void TCOD_heightmap_set_value(TCOD_heightmap_t *hm, int x, int y, float value)
+	@Py heightmap_set_value(hm, x, y, value)
+	@C# void TCODHeightMap::setValue(int x, int y, float v)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the cells to modify inside the map.
+		0 <= x < map width
+		0 <= y < map height
+	@Param value	The new value of the map cell.
+	*/
+	inline void setValue(int x, int y, float v) {
+		values[x+y*w]=v;
+	}
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Adding a float value to all cells
+	@Cpp void TCODHeightMap::add(float value)
+	@C void TCOD_heightmap_add(TCOD_heightmap_t *hm, float value)
+	@Py heightmap_add(hm, value)
+	@C# void TCODHeightMap::add(float value)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param value	Value to add to every cell.
+	*/
+	void add(float f);
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Multiplying all values by a float
+	@Cpp void TCODHeightMap::scale(float value)
+	@C void TCOD_heightmap_scale(TCOD_heightmap_t *hm, float value)
+	@Py heightmap_scale(hm, value)
+	@C# void TCODHeightMap::scale(float value)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param value	Every cell's value is multiplied by this value.
+	*/
+	void scale(float f);
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Resetting all values to 0.0
+	@Cpp void TCODHeightMap::clear()
+	@C void TCOD_heightmap_clear(TCOD_heightmap_t *hm)
+	@Py heightmap_clear(hm)
+	@C# void TCODHeightMap::clear()
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	*/
+	void clear(); // resets all values to 0.0
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Clamping all values
+	@Cpp void TCODHeightMap::clamp(float min, float max)
+	@C void TCOD_heightmap_clamp(TCOD_heightmap_t *hm, float min, float max)
+	@Py heightmap_clamp(hm, mi, ma)
+	@C# void TCODHeightMap::clamp(float min, float max)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param min,max	Every cell value is clamped between min and max.
+		min < max
+	*/
+	void clamp(float min, float max);
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Copying values from another heightmap
+	@Cpp void TCODHeightMap::copy(const TCODHeightMap *source)
+	@C void TCOD_heightmap_copy(const TCOD_heightmap_t *source,TCOD_heightmap_t *dest)
+	@Py heightmap_copy(source,dest)
+	@C# void TCODHeightMap::copy(TCODHeightMap source)
+	@Param source	Each cell value from the source heightmap is copied in the destination (this for C++) heightmap.
+		The source and destination heightmap must have the same width and height.
+	@Param dest	In the C and python versions, the address of the destination heightmap.
+	*/
+	void copy(const TCODHeightMap *source);
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Normalizing values
+	@Cpp void TCODHeightMap::normalize(float min=0.0f, float max=1.0f)
+	@C void TCOD_heightmap_normalize(TCOD_heightmap_t *hm, float min, float max)
+	@Py heightmap_normalize(hm, mi=0.0, ma=1.0)
+	@C#
+		void TCODHeightMap::normalize()
+		void TCODHeightMap::normalize(float min)
+		void TCODHeightMap::normalize(float min, float max)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param min,max	The whole heightmap is translated and scaled so that the lowest cell value becomes min and the highest cell value becomes max
+		min < max
+	*/
+	void normalize(float newMin=0.0f, float newMax=1.0f); // scales the values to the range [newMin;newMax]
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Doing a lerp operation between two heightmaps
+	@Cpp void TCODHeightMap::lerp(const TCODHeightMap *a, const TCODHeightMap *b,float coef)
+	@C void TCOD_heightmap_lerp_hm(const TCOD_heightmap_t *a, const TCOD_heightmap_t *b, TCOD_heightmap_t *res, float coef)
+	@Py heightmap_lerp_hm(a, b, res, coef)
+	@C# void TCODHeightMap::lerp(TCODHeightMap a, TCODHeightMap b, float coef)
+	@Param a	First heightmap in the lerp operation.
+	@Param b	Second heightmap in the lerp operation.
+	@Param coef	lerp coefficient.
+		For each cell in the destination map (this for C++), value = a.value + (b.value - a.value) * coef
+	@Param res	In the C and python versions, the address of the destination heightmap.
+	*/
+	void lerp(const TCODHeightMap *a, const TCODHeightMap *b,float coef);
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Adding two heightmaps
+	@Cpp void TCODHeightMap::add(const TCODHeightMap *a, const TCODHeightMap *b)
+	@C void TCOD_heightmap_add_hm(const TCOD_heightmap_t *a, const TCOD_heightmap_t *b, TCOD_heightmap_t *res)
+	@Py heightmap_add_hm(a, b, res)
+	@C# void TCODHeightMap::add(TCODHeightMap a, TCODHeightMap b)
+	@Param a	First heightmap.
+	@Param b	Second heightmap. For each cell in the destination map (this for C++), value = a.value + b.value
+	@Param res	In the C and python versions, the address of the destination heightmap.
+	*/
+	void add(const TCODHeightMap *a, const TCODHeightMap *b);
+
+	/**
+	@PageName heightmap_base
+	@FuncTitle Multiplying two heightmaps
+	@Cpp void TCODHeightMap::multiply(const TCODHeightMap *a, const TCODHeightMap *b)
+	@C void TCOD_heightmap_multiply_hm(const TCOD_heightmap_t *a, const TCOD_heightmap_t *b, TCOD_heightmap_t *res)
+	@Py heightmap_multiply_hm(a, b, res)
+	@C# void TCODHeightMap::multiply(TCODHeightMap a, TCODHeightMap b)
+	@Param a	First heightmap.
+	@Param b	Second heightmap. For each cell in the destination map (this for C++), value = a.value * b.value
+	@Param res	In the C and python versions, the address of the destination heightmap.
+	*/
+	void multiply(const TCODHeightMap *a, const TCODHeightMap *b);
+
+	/**
+	@PageName heightmap_modify
+	@PageFather heightmap
+	@PageTitle Modifying the heightmap
+	@PageDesc Those are advanced operations involving several or all map cells.
+	@FuncTitle Add hills
+	@FuncDesc This function adds a hill (a half spheroid) at given position.
+	@Cpp void TCODHeightMap::addHill(float x, float y, float radius, float height)
+	@C void TCOD_heightmap_add_hill(TCOD_heightmap_t *hm, float x, float y, float radius, float height)
+	@Py heightmap_add_hill(hm, x, y, radius, height)
+	@C# void TCODHeightMap::addHill(float x, float y, float radius, float height)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the center of the hill.
+		0 <= x < map width
+		0 <= y < map height
+	@Param radius	The hill radius.
+	@Param height	The hill height. If height == radius or -radius, the hill is a half-sphere.
+	*/
+	void addHill(float x, float y, float radius, float height); // adds a hill (half sphere) at given position
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Dig hills
+	@FuncDesc This function takes the highest value (if height > 0) or the lowest (if height < 0) between the map and the hill.
+		It's main goal is to carve things in maps (like rivers) by digging hills along a curve.
+	@Cpp void TCODHeightMap::digHill(float hx, float hy, float hradius, float height)
+	@C void TCOD_heightmap_dig_hill(TCOD_heightmap_t *hm, float x, float y, float radius, float height)
+	@Py heightmap_dig_hill(hm, x, y, radius, height)
+	@C# void TCODHeightMap::digHill(float hx, float hy, float hradius, float height)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the center of the hill.
+		0 <= x < map width
+		0 <= y < map height
+	@Param radius	The hill radius.
+	@Param height	The hill height. Can be < 0 or > 0
+	*/
+	void digHill(float hx, float hy, float hradius, float height);
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Simulate rain erosion
+	@FuncDesc This function simulates the effect of rain drops on the terrain, resulting in erosion patterns.
+	@Cpp void TCODHeightMap::rainErosion(int nbDrops,float erosionCoef,float sedimentationCoef,TCODRandom *rnd)
+	@C void TCOD_heightmap_rain_erosion(TCOD_heightmap_t *hm, int nbDrops,float erosionCoef,float sedimentationCoef,TCOD_random_t rnd)
+	@Py heightmap_rain_erosion(hm, nbDrops,erosionCoef,sedimentationCoef,rnd=0)
+	@C# void TCODHeightMap::rainErosion(int nbDrops, float erosionCoef, float sedimentationCoef, TCODRandom rnd)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param nbDrops	Number of rain drops to simulate. Should be at least width * height.
+	@Param erosionCoef	Amount of ground eroded on the drop's path.
+	@Param sedimentationCoef	Amount of ground deposited when the drops stops to flow
+	@Param rnd	RNG to use, NULL for default generator.
+	*/
+	void rainErosion(int nbDrops,float erosionCoef,float sedimentationCoef,TCODRandom *rnd);
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Do a generic transformation
+	@FuncDesc This function allows you to apply a generic transformation on the map, so that each resulting cell value is the weighted sum of several neighbour cells. This can be used to smooth/sharpen the map. See examples below for a simple horizontal smoothing kernel : replace value(x,y) with 0.33*value(x-1,y) + 0.33*value(x,y) + 0.33*value(x+1,y).To do this, you need a kernel of size 3 (the sum involves 3 surrounding cells). The dx,dy array will contain :
+	dx=-1,dy = 0 for cell x-1,y
+	dx=1,dy=0 for cell x+1,y
+	dx=0,dy=0 for current cell (x,y)
+	The weight array will contain 0.33 for each cell.
+	@Cpp void TCODHeightMap::kernelTransform(int kernelSize, int *dx, int *dy, float *weight, float minLevel,float maxLevel)
+	@C void TCOD_heightmap_kernel_transform(TCOD_heightmap_t *hm, int kernelsize, int *dx, int *dy, float *weight, float minLevel,float maxLevel)
+	@Py heightmap_kernel_transform(hm, kernelsize, dx, dy, weight, minLevel,maxLevel)
+	@C# void TCODHeightMap::kernelTransform(int kernelSize, int[] dx, int[] dy, float[] weight, float minLevel, float maxLevel)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+		kernelSize	Number of neighbour cells involved.
+	@Param dx,dy	Array of kernelSize cells coordinates. The coordinates are relative to the current cell (0,0) is current cell, (-1,0) is west cell, (0,-1) is north cell, (1,0) is east cell, (0,1) is south cell, ...
+	@Param weight	Array of kernelSize cells weight. The value of each neighbour cell is scaled by its corresponding weight
+	@Param minLevel	The transformation is only applied to cells which value is >= minLevel.
+	@Param maxLevel	The transformation is only applied to cells which value is <= maxLevel.
+	@CEx
+		int dx [] = {-1,1,0};
+		int dy[] = {0,0,0};
+		float weight[] = {0.33f,0.33f,0.33f};
+		TCOD_heightMap_kernel_transform(heightmap,3,dx,dy,weight,0.0f,1.0f);
+	@CppEx
+		int dx [] = {-1,1,0};
+		int dy[] = {0,0,0};
+		float weight[] = {0.33f,0.33f,0.33f};
+		heightmap->kernelTransform(heightmap,3,dx,dy,weight,0.0f,1.0f);
+	*/
+	void kernelTransform(int kernelSize, const int *dx, const int *dy, const float *weight, float minLevel,float maxLevel);
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Add a Voronoi diagram
+	@FuncDesc This function adds values from a Voronoi diagram to the map.
+	@Cpp void TCODHeightMap::addVoronoi(int nbPoints, int nbCoef, float *coef,TCODRandom *rnd)
+	@C void TCOD_heightmap_add_voronoi(TCOD_heightmap_t *hm, int nbPoints, int nbCoef, float *coef,TCOD_random_t rnd)
+	@Py heightmap_add_voronoi(hm, nbPoints, nbCoef, coef,rnd=0)
+	@C# void TCODHeightMap::addVoronoi(int nbPoints, int nbCoef, float[] coef, TCODRandom rnd)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param nbPoints	Number of Voronoi sites.
+	@Param nbCoef	The diagram value is calculated from the nbCoef closest sites.
+	@Param coef	The distance to each site is scaled by the corresponding coef.
+		Closest site : coef[0], second closest site : coef[1], ...
+	@Param rnd	RNG to use, NULL for default generator.
+	*/
+	void addVoronoi(int nbPoints, int nbCoef, const float *coef,TCODRandom *rnd);
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Add a fbm
+		This function adds values from a simplex fbm function to the map.
+	@Cpp void TCODHeightMap::addFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
+	@C void TCOD_heightmap_add_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
+	@Py heightmap_add_fbm(hm, noise,mulx, muly, addx, addy, octaves, delta, scale)
+	@C# void TCODHeightMap::addFbm(TCODNoise noise, float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param noise	The 2D noise to use.
+	@Param mulx, muly / addx, addy	The noise coordinate for map cell (x,y) are (x + addx)*mulx / width , (y + addy)*muly / height.
+		Those values allow you to scale and translate the noise function over the heightmap.
+	@Param octaves	Number of octaves in the fbm sum.
+	@Param delta / scale	The value added to the heightmap is delta + noise * scale.
+	@Param noise is between -1.0 and 1.0
+	*/
+	void addFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale);
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Scale with a fbm
+	@FuncDesc This function works exactly as the previous one, but it multiplies the resulting value instead of adding it to the heightmap.
+	@Cpp void TCODHeightMap::scaleFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
+	@C void TCOD_heightmap_scale_fbm(TCOD_heightmap_t *hm, TCOD_noise_t noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
+	@Py heightmap_scale_fbm(hm, noise,mulx, muly, addx, addy, octaves, delta, scale)
+	@C# void TCODHeightMap::scaleFbm(TCODNoise noise, float mulx, float muly, float addx, float addy, float octaves, float delta, float scale)
+	*/
+	void scaleFbm(TCODNoise *noise,float mulx, float muly, float addx, float addy, float octaves, float delta, float scale);
+
+	/**
+	@PageName heightmap_modify
+	@FuncTitle Dig along a Bezier curve
+	@FuncDesc This function carve a path along a cubic Bezier curve using the digHill function.
+		Could be used for roads/rivers/...
+		Both radius and depth can vary linearly along the path.
+	@Cpp void TCODHeightMap::digBezier(int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth)
+	@C void TCOD_heightmap_dig_bezier(TCOD_heightmap_t *hm, int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth)
+	@Py heightmap_dig_bezier(hm, px, py,  startRadius,  startDepth, endRadius, endDepth)
+	@C# void TCODHeightMap::digBezier(int[] px, int[] py, float startRadius, float startDepth, float endRadius, float endDepth)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param px,py	The coordinates of the 4 Bezier control points.
+	@Param startRadius	The path radius in map cells at point P0. Might be < 1.0
+	@Param startDepth	The path depth at point P0.
+	@Param endRadius	The path radius in map cells at point P3. Might be < 1.0
+	@Param endDepth	The path depth at point P3.
+	*/
+	void digBezier(int px[4], int py[4], float startRadius, float startDepth, float endRadius, float endDepth);
+
+	/**
+	@PageName heightmap_read
+	@PageFather heightmap
+	@PageTitle Reading data from the heightmap
+	@PageDesc Those functions return raw or computed information about the heightmap.
+	@FuncTitle Get the value of a cell
+	@FuncDesc This function returns the height value of a map cell.
+	@Cpp float TCODHeightMap::getValue(int x, int y) const
+	@C float TCOD_heightmap_get_value(const TCOD_heightmap_t *hm, int x, int y)
+	@Py heightmap_get_value(hm,  x, y)
+	@C# float TCODHeightMap::getValue(int x, int y)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the map cell.
+		0 <= x < map width
+		0 <= y < map height
+	*/
+	inline float getValue(int x, int y) const {
+		return values[x+y*w];
+	}
+
+	/**
+	@PageName heightmap_read
+	@FuncTitle  Interpolate the height
+	@FuncDesc This function returns the interpolated height at non integer coordinates.
+	@Cpp float TCODHeightMap::getInterpolatedValue(float x, float y) const
+	@C float TCOD_heightmap_get_interpolated_value(const TCOD_heightmap_t *hm, float x, float y)
+	@Py heightmap_get_interpolated_value(hm, x, y)
+	@C# float TCODHeightMap::getInterpolatedValue(float x, float y)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the map cell.
+		0 <= x < map width
+		0 <= y < map height
+	*/
+	float getInterpolatedValue(float x, float y) const;
+
+	/**
+	@PageName heightmap_read
+	@FuncTitle Get the map slope
+	@FuncDesc This function returns the slope between 0 and PI/2 at given coordinates.
+	@Cpp float TCODHeightMap::getSlope(int x, int y) const
+	@C float TCOD_heightmap_get_slope(const TCOD_heightmap_t *hm, int x, int y)
+	@Py heightmap_get_slope(hm, x, y)
+	@C# float TCODHeightMap::getSlope(int x, int y)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the map cell.
+		0 <= x < map width
+		0 <= y < map height
+	*/
+	float getSlope(int x, int y) const; // returns the slope in radian between 0 and PI/2
+
+	/**
+	@PageName heightmap_read
+	@FuncTitle Get the map normal
+	@FuncDesc This function returns the map normal at given coordinates.
+	@Cpp void TCODHeightMap::getNormal(float x, float y,float n[3], float waterLevel=0.0f) const
+	@C void TCOD_heightmap_get_normal(const TCOD_heightmap_t *hm, float x, float y, float n[3], float waterLevel)
+	@Py heightmap_get_normal(hm, x, y, waterLevel) # returns nx,ny,nz
+	@C# void TCODHeightMap::getNormal(float x, float y, float[] n, float waterLevel)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param x,y	Coordinates of the map cell.
+		0 <= x < map width
+		0 <= y < map height
+	@Param n	The function stores the normalized normal vector in this array.
+	@Param waterLevel	The map height is clamped at waterLevel so that the sea is flat.
+	*/
+	void getNormal(float x, float y,float n[3], float waterLevel=0.0f) const; // returns the surface normal or (0,0,1) if beyond water level.
+
+	/**
+	@PageName heightmap_read
+	@FuncTitle Count the map cells inside a height range
+	@FuncDesc This function returns the number of map cells which value is between min and max.
+	@Cpp int TCODHeightMap::countCells(float min,float max) const
+	@C int TCOD_heightmap_count_cells(const TCOD_heightmap_t *hm, float min, float max)
+	@Py heightmap_count_cells(hm, min, max)
+	@C# int TCODHeightMap::countCells(float min, float max)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param min,max	Only cells which value is >=min and <= max are counted.
+	*/
+	int countCells(float min,float max) const;
+
+	/**
+	@PageName heightmap_read
+	@FuncTitle Check if the map is an island
+	@FuncDesc This function checks if the cells on the map border are below a certain height.
+	@Cpp bool TCODHeightMap::hasLandOnBorder(float waterLevel) const
+	@C bool TCOD_heightmap_has_land_on_border(const TCOD_heightmap_t *hm, float waterLevel)
+	@Py heightmap_has_land_on_border(hm, waterLevel)
+	@C# bool TCODHeightMap::hasLandOnBorder(float waterLevel)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param waterLevel	Return true only if no border cell is > waterLevel.
+	*/
+	bool hasLandOnBorder(float waterLevel) const;
+
+	/**
+	@PageName heightmap_read
+	@FuncTitle Get the map min and max values
+	@FuncDesc This function calculates the min and max of all values inside the map.
+	@Cpp void TCODHeightMap::getMinMax(float *min, float *max) const
+	@C void TCOD_heightmap_get_minmax(const TCOD_heightmap_t *hm, float *min, float *max)
+	@Py heightmap_get_minmax(hm) # returns min,max
+	@C# void TCODHeightMap::getMinMax(out float min, out float max)
+	@Param hm	In the C version, the address of the heightmap struct returned by the creation function.
+	@Param min, max	The min and max values are returned in these variables.
+	*/
+	void getMinMax(float *min, float *max) const;
+
+//	void heatErosion(int nbPass,float minSlope,float erosionCoef,float sedimentationCoef,TCODRandom *rnd);
+//	void midPointDeplacement(TCODRandom *rnd);
+	void islandify(float seaLevel,TCODRandom *rnd); // lowers the terrain near the heightmap borders
+	// TODO : checks island connectivity with floodfill
+private :
+//	void setMPDHeight(TCODRandom *rnd,int x,int y, float z, float offset);
+//	void setMDPHeightSquare(TCODRandom *rnd,int x, int y, int initsz, int sz,float offset);
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/image.hpp
@@ -0,0 +1,440 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+class TCODLIB_API TCODImage {
+public :
+	/**
+	@PageName image
+	@PageTitle Image toolkit
+	@PageCategory Base toolkits
+	@PageDesc This toolkit contains some image manipulation utilities.	
+	*/	
+	
+	/**
+	@PageName image_create
+	@PageTitle Creating an image
+	@PageFather image
+	@FuncTitle Creating an empty image
+	@FuncDesc You can create an image of any size, filled with black with this function.
+	@Cpp TCODImage::TCODImage(int width, int height)
+	@C TCOD_image_t TCOD_image_new(int width, int height)
+	@Py image_new( width, height)
+	@C# TCODImage::TCODImage(int width, int height)
+	@Param width,height	Size of the image in pixels.
+	@CppEx TCODImage *pix = new TCODImage(80,50);
+	@CEx TCOD_image_t pix = TCOD_image_new(80,50);
+	@PyEx pix = litbcod.image_new(80,50)	
+	*/	
+	TCODImage(int width, int height);
+
+	/**
+	@PageName image_create
+	@FuncTitle Loading a .bmp or .png image
+	@FuncDesc You can read data from a .bmp or .png file (for example to draw an image using the background color of the console cells).
+		Note that only 24bits and 32bits PNG files are currently supported.
+	@Cpp TCODImage::TCODImage(const char *filename)
+	@C TCOD_image_t TCOD_image_load(const char *filename)
+	@Py image_load(filename)
+	@C# TCODImage::TCODImage(string filename)
+	@Param filename Name of the .bmp or .png file to load.
+	@CppEx TCODImage *pix = new TCODImage("mypic.bmp");
+	@CEx TCOD_image_t pix = TCOD_image_load("mypic.bmp");
+	@PyEx pix = libtcod.image_load("mypic.bmp")	
+	*/	
+	TCODImage(const char *filename);
+	
+	/**
+	@PageName image_create
+	@FuncTitle Creating an image from a console
+	@FuncDesc You can create an image from any console (either the root console or an offscreen console).
+		The image size will depend on the console size and the font characters size.
+		You can then save the image to a file with the save function.
+	@Cpp TCODImage::TCODImage(const TCODConsole *console)
+	@C TCOD_image_t TCOD_image_from_console(TCOD_console_t console)
+	@Py image_from_console(console)
+	@C# TCODImage::TCODImage(TCODConsole console)
+	@Param console The console to convert. In the C version, use NULL for the root console.
+	@CppEx TCODImage *pix = new TCODImage(TCODConsole::root);
+	@CEx TCOD_image_t pix = TCOD_image_from_console(NULL);
+	@PyEx pix = libtcod.image_from_console(0)
+	*/	
+	TCODImage(const TCODConsole *console);
+	
+	/**
+	@PageName image_create
+	@FuncTitle refreshing an image created from a console
+	@FuncDesc If you need to refresh the image with the console's new content, you don't have to delete it and create another one. Instead, use this function. Note that you must use the same console that was used in the TCOD_image_from_console call (or at least a console with the same size).
+	@Cpp void TCODImage::refreshConsole(const TCODConsole *console)
+	@C void TCOD_image_refresh_console(TCOD_image_t image, TCOD_console_t console)
+	@Py image_refresh_console(image, console)
+	@C# void TCODImage::refreshConsole(TCODConsole console)
+	@Param image In the C version, the image created with TCOD_image_from_console.
+	@Param console The console to capture. In the C version, use NULL for the root console.
+	@CppEx 
+		TCODImage *pix = new TCODImage(TCODConsole::root); // create an image from the root console
+		// ... modify the console
+		pix->refreshConsole(TCODConsole::root); // update the image with the console's new content
+	@CEx 
+		TCOD_image_t pix = TCOD_image_from_console(NULL);
+		// ... modify the console .. 
+		TCOD_image_refresh_console(pix,NULL);
+	@PyEx 
+		pix = libtcod.image_from_console(0)
+		# ... modify the console .. 
+		libtcod.image_refresh_console(pix,0)
+	*/
+	void refreshConsole(const TCODConsole *console);
+
+	/**
+	@PageName image_read
+	@PageTitle Reading data from a TCODImage
+	@PageFather image
+	@FuncTitle Getting the size of an image
+	@FuncDesc You can read the size of an image in pixels with this function.
+	@Cpp void TCODImage::getSize(int *w,int *h) const
+	@C void TCOD_image_get_size(TCOD_image_t image, int *w,int *h)
+	@Py image_get_size(image) # returns w,h
+	@C# void TCODImage::getSize(out int w, out int h)
+	@Param image In the C version, the image handler, obtained with the load function.
+	@Param w,h When the function returns, those variables contain the size of the image.
+	@CppEx 
+		TCODImage *pix = new TCODImage(80,50);
+		int w,h;
+		pix->getSize(&w,&h); // w = 80, h = 50
+	@CEx 
+		TCOD_image_t pix = TCOD_image_new(80,50);
+		int w,h;
+		TCOD_image_get_size(pix,&w,&h); // w = 80, h = 50
+	@PyEx 
+		pix = libtcod.image_new(80,50)
+		w,h=libtcod.image_get_size(pix)
+		# w = 80, h = 50 
+	*/		
+	void getSize(int *w,int *h) const;
+
+	/**
+	@PageName image_read
+	@FuncTitle Getting the color of a pixel
+	@FuncDesc You can read the colors from an image with this function.
+	@Cpp TCODColor TCODImage::getPixel(int x, int y) const
+	@C TCOD_color_t TCOD_image_get_pixel(TCOD_image_t image,int x, int y)
+	@Py image_get_pixel(image, x, y)
+	@C# TCODColor TCODImage::getPixel(int x, int y)
+	@Param image In the C and python version, the image handler, obtained with the load function.
+	@Param x,y The pixel coordinates inside the image.
+		0 <= x < width
+		0 <= y < height
+	@CppEx 
+		TCODImage *pix = new TCODImage(80,50);
+		TCODColor col=pix->getPixel(40,25);
+	@CEx 
+		TCOD_image_t pix = TCOD_image_new(80,50);
+		TCOD_color_t col=TCOD_image_get_pixel(pix,40,25);
+	@PyEx 
+		pix = litbcod.image_new(80,50)
+		col=litbcod.image_get_pixel(pix,40,25)
+	*/
+	TCODColor getPixel(int x, int y) const;
+
+	/**
+	@PageName image_read
+	@FuncTitle Getting the alpha value of a pixel
+	@FuncDesc If you have set a key color for this image with setKeyColor, or if this image was created from a 32 bits PNG file (with alpha layer), you can get the pixel transparency with this function. This function returns a value between 0 (transparent pixel) and 255 (opaque pixel).
+	@Cpp int TCODImage::getAlpha(int x, int y) const
+	@C int TCOD_image_get_alpha(TCOD_image_t image, int x, int y)
+	@Py image_get_alpha(image, x, y)
+	@C# int TCODImage::getAlpha(int x, int y)
+	@Param image In the C and python version, the image handler, obtained with the load function.
+	@Param x,y The pixel coordinates inside the image.
+		0 <= x < width
+		0 <= y < height
+	*/
+	int getAlpha(int x,int y) const;
+
+	/**
+	@PageName image_read
+	@FuncTitle Checking if a pixel is transparent
+	@FuncDesc You can use this simpler version (for images with alpha layer, returns true only if alpha == 0) :
+	@Cpp bool TCODImage::isPixelTransparent(int x,int y) const
+	@C bool TCOD_image_is_pixel_transparent(TCOD_image_t image,int x, int y)
+	@Py image_is_pixel_transparent(image, x, y)
+	@C# bool TCODImage::isPixelTransparent(int x,int y)
+	@Param image In the C and python version, the image handler, obtained with the load function.
+	@Param x,y The pixel coordinates inside the image.
+		0 <= x < width
+		0 <= y < height
+	*/
+   	bool isPixelTransparent(int x, int y) const;
+
+	/**
+	@PageName image_read
+	@FuncTitle Getting the average color of a part of the image
+	@FuncDesc This method uses mipmaps to get the average color of an arbitrary rectangular region of the image.
+		It can be used to draw a scaled-down version of the image. It's used by libtcod's blitting functions.
+	@Cpp TCODColor TCODImage::getMipmapPixel(float x0,float y0, float x1, float y1)
+	@C TCOD_color_t TCOD_image_get_mipmap_pixel(TCOD_image_t image,float x0,float y0, float x1, float y1)
+	@Py image_get_mipmap_pixel(image,x0,y0, x1, y1)
+	@C# TCODColor TCODImage::getMipmapPixel(float x0,float y0, float x1, float y1)
+	@Param image	In the C version, the image handler, obtained with the load function.
+	@Param x0,y0	Coordinates in pixels of the upper-left corner of the region.
+		0.0 <= x0 < x1
+		0.0 <= y0 < y1
+	@Param x1,y1	Coordinates in pixels of the lower-right corner of the region.
+		x0 < x1 < width
+		y0 < y1 < height
+	@CppEx 
+		// Get the average color of a 5x5 "superpixel" in the center of the image.
+		TCODImage *pix = new TCODImage(80,50);
+		TCODColor col=pix->getMipMapPixel(37.5f, 22.5f, 42.5f, 28.5f);
+	@CEx 
+		TCOD_image_t pix = TCOD_image_new(80,50);
+		TCOD_color_t col=TCOD_image_get_mipmap_pixel(pix,37.5f, 22.5f, 42.5f, 28.5f);
+	@PyEx
+		pix = libtcod.image_new(80,50)
+		col=libtcod.image_get_mipmap_pixel(pix,37.5, 22.5, 42.5, 28.5)
+	*/
+   	TCODColor getMipmapPixel(float x0,float y0, float x1, float y1);
+
+	/**
+	@PageName image_update
+	@PageTitle Updating an image
+	@PageFather image
+	@FuncTitle Filling an image with a color
+	@FuncDesc You can fill the whole image with a color with :
+	@Cpp void TCODImage::clear(const TCODColor color)
+	@C void TCOD_image_clear(TCOD_image_t image, TCOD_color_t color)
+	@Py image_clear(image,color)
+	@C# void TCODImage::clear(TCODColor color)
+	@Param image	In the C and python version, the image to fill.
+	@Param color	The color to use.
+	*/
+	void clear(const TCODColor col);
+
+	/**
+	@PageName image_update
+	@FuncTitle 	Changing the color of a pixel
+	@Cpp TCODColor TCODImage::putPixel(int x, int y, const TCODColor col)
+	@C void TCOD_image_put_pixel(TCOD_image_t image,int x, int y,TCOD_color_t col)
+	@Py image_put_pixel(image,x, y,col)
+	@C# TCODColor TCODImage::putPixel(int x, int y, TCODColor col)
+	@Param image	In the C version, the image handler, obtained with the load function.
+	@Param x,y	The pixel coordinates inside the image.
+		0 <= x < width
+		0 <= y < height
+	@Param col	The new color of the pixel.
+	*/
+	void putPixel(int x, int y, const TCODColor col);
+	
+	/**
+	@PageName image_update
+	@FuncTitle Scaling an image
+	@FuncDesc You can resize an image and scale its content. If neww < oldw or newh < oldh, supersampling is used to scale down the image. Else the image is scaled up using nearest neightbor.
+	@Cpp void TCODImage::scale(int neww, int newh)
+	@C void TCOD_image_scale(TCOD_image_t image,int neww, int newh)
+	@Py image_scale(image, neww,newh)
+	@C# void TCODImage::scale(int neww, int newh)
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	@Param neww,newh	The new size of the image.
+	*/
+	void scale(int neww, int newh);
+
+	/**
+	@PageName image_update
+	@FuncTitle Flipping the image horizontally
+	@Cpp void TCODImage::hflip()
+	@C void TCOD_image_hflip(TCOD_image_t image)
+	@Py image_hflip(image)
+	@C# void TCODImage::hflip()
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	*/
+	void hflip();
+
+    /**
+	@PageName image_update
+	@FuncTitle Flipping the image vertically
+	@Cpp void TCODImage::vflip()
+	@C void TCOD_image_vflip(TCOD_image_t image)
+	@Py image_vflip(image)
+	@C# void TCODImage::vflip()
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	*/
+	void vflip();
+
+    /**
+	@PageName image_update
+	@FuncTitle Rotating the image clockwise
+	@FuncDesc Rotate the image clockwise by increment of 90 degrees. 
+	@Cpp void TCODImage::rotate90(int numRotations=1)
+	@C void TCOD_image_rotate90(TCOD_image_t image, int numRotations)
+	@Py image_rotate90(image, num=1)
+	@C# void TCODImage::rotate90(int numRotations)
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	@Param numRotations	Number of 90 degrees rotations. Should be between 1 and 3.
+	*/
+	void rotate90(int numRotations=1);
+
+    /**
+	@PageName image_update
+	@FuncTitle Inverting the colors of the image
+	@Cpp void TCODImage::invert()
+	@C void TCOD_image_invert(TCOD_image_t image)
+	@Py image_invert(image)
+	@C# void TCODImage::invert()
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	*/
+	void invert();
+
+	/**
+	@PageName image_save
+	@PageFather image
+	@PageTitle Saving an image to a bmp or png file.
+	@PageDesc You can save an image to a 24 bits .bmp or .png file.
+	@Cpp void TCODImage::save(const char *filename)
+	@C void TCOD_image_save(TCOD_image_t image, const char *filename)
+	@Py image_save(image, filename)
+	@C# void TCODImage::save(string filename)
+	@Param image	In the C version, the image handler, obtained with any image creation function.
+	@Param filename	Name of the .bmp or .png file.
+	@CppEx 
+		TCODImage *pix = new TCODImage(10,10);
+		pix->save("mypic.bmp");
+	@CEx 
+		TCOD_image_t pix = TCOD_image_from_console(my_offscreen_console);
+		TCOD_image_save(pix,"mypic.bmp");
+	@PyEx 
+		pix = libtcod.image_from_console(my_offscreen_console)
+		libtcod.image_save(pix,"mypic.bmp")
+	  */	
+	void save(const char *filename) const;
+
+	/**
+	@PageName image_blit
+	@PageFather image
+	@PageTitle Blitting an image on a console
+	@FuncTitle Standard blitting
+	@FuncDesc This function blits a rectangular part of the image on a console without scaling it or rotating it. Each pixel of the image fills a console cell.
+	@Cpp void TCODImage::blitRect(TCODConsole *console, int x, int y, int w=-1, int h=-1, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET ) const
+	@C void TCOD_image_blit_rect(TCOD_image_t image, TCOD_console_t console, int x, int y, int w, int h, TCOD_bkgnd_flag_t bkgnd_flag)
+	@Py image_blit_rect(image, console, x, y, w, h, bkgnd_flag)
+	@C# 
+		void TCODImage::blitRect(TCODConsole console, int x, int y) 
+		void TCODImage::blitRect(TCODConsole console, int x, int y, int w)
+		void TCODImage::blitRect(TCODConsole console, int x, int y, int w, int h)
+		void TCODImage::blitRect(TCODConsole console, int x, int y, int w, int h, TCODBackgroundFlag bkgnd_flag)	
+	@Param image	In the C version, the image handler, obtained with the load function.
+	@Param console	The console on which the image will be drawn. In the C version, use NULL for the root console.
+	@Param x,y	Coordinates in the console of the upper-left corner of the image.
+	@Param w,h	Dimension of the image on the console. Use -1,-1 to use the image size.
+	@Param flag	This flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t.	
+	*/	
+	void blitRect(TCODConsole *console, int x, int y, int w=-1, int h=-1, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET ) const;
+	
+	/**
+	@PageName image_blit
+	@FuncTitle Blitting with scaling and/or rotation
+	@FuncDesc This function allows you to specify the floating point coordinates of the center
+		of the image, its scale and its rotation angle.
+	@Cpp void TCODImage::blit(TCODConsole *console, float x, float y, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET, float scalex=1.0f, float scaley=1.0f, float angle=0.0f) const
+	@C void TCOD_image_blit(TCOD_image_t image, TCOD_console_t console, int x, int y, TCOD_bkgnd_flag_t bkgnd_flag, float scalex, float scaley, float angle)
+	@Py image_blit(image, console, x, y, bkgnd_flag, scalex, scaley, angle)
+	@C#
+		void TCODImage::blit(TCODConsole console, float x, float y)
+		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag)
+		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag, float scalex)
+		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag, float scalex, float scaley)
+		void TCODImage::blit(TCODConsole console, float x, float y, TCODBackgroundFlag bkgnd_flag, float scalex, float scaley, float angle)
+	@Param image	In the C version, the image handler, obtained with the load function.
+	@Param console	The console on which the image will be drawn. In the C version, use NULL for the root console.
+	@Param x,y	Coordinates in the console of the center of the image.
+	@Param flag	This flag defines how the cell's background color is modified. See TCOD_bkgnd_flag_t.
+	@Param scalex,scaley	Scale coefficient. Must be > 0.0.
+	@Param angle	Rotation angle in radians.
+	*/	
+	void blit(TCODConsole *console, float x, float y, TCOD_bkgnd_flag_t bkgnd_flag = TCOD_BKGND_SET, float scalex=1.0f, float scaley=1.0f, float angle=0.0f) const;
+	/**
+	@PageName image_blit
+	@FuncTitle Blitting with a mask
+	@FuncDesc When blitting an image, you can define a key color that will be ignored by the blitting function. This makes it possible to blit non rectangular images or images with transparent pixels.
+	@Cpp void TCODImage::setKeyColor(const TCODColor keyColor)
+	@C void TCOD_image_set_key_color(TCOD_image_t image, TCOD_color_t keyColor)
+	@Py image_set_key_color(image, keyColor)
+	@C# void TCODImage::setKeyColor(TCODColor keyColor)
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	@Param color	Pixels with this color will be skipped by blitting functions.
+	@CppEx 
+		TCODImage *pix = TCODImage("mypix.bmp");
+		pix->setKeyColor(TCODColor::red);
+		// blitting the image, omitting red pixels
+		pix->blitRect(TCODConsole::root,40,25);
+	@CEx 
+		TCOD_image_t pix = TCOD_image_new(10,10);
+		TCOD_image_set_key_color(pix,TCOD_red);
+		TCOD_image_blit_rect(pix,NULL,40,25,5,5,TCOD_BKGND_SET);
+	@PyEx 
+		pix = libtcod.image_new(10,10)
+		libtcod.image_set_key_color(pix,libtcod.red)
+		libtcod.image_blit_rect(pix,0,40,25,5,5,libtcod.BKGND_SET)
+	*/	
+	void setKeyColor(const TCODColor keyColor);
+	
+	/**
+	@PageName image_blit
+	@FuncTitle Blitting with subcell resolution
+	@FuncDesc Eventually, you can use some special characters in the libtcod fonts :
+		<img src="subcell.png">
+		to double the console resolution using this blitting function.
+		<table><tr><td> 
+		Comparison before/after subcell resolution in TCOD :<br /> 
+		<img src="subcell_comp.png"></td><td> 
+		Pyromancer ! screenshot, making full usage of subcell resolution :<br /> 
+		<img src="subcell_pyro.png"></td></tr></table>
+	@Cpp void TCODImage::blit2x(TCODConsole *dest, int dx, int dy, int sx=0, int sy=0, int w=-1, int h=-1 ) const;
+	@C void TCOD_image_blit_2x(TCOD_image_t image, TCOD_console_t dest, int dx, int dy, int sx, int sy, int w, int h);
+	@Py image_blit_2x(image, dest, dx, dy, sx=0, sy=0, w=-1, h=-1)
+	@C#
+		void TCODImage::blit2x(TCODConsole dest, int dx, int dy);
+		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx);
+		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx, int sy);
+		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx, int sy, int w);
+		void TCODImage::blit2x(TCODConsole dest, int dx, int dy, int sx, int sy, int w, int h);
+	@Param image	In the C and python version, the image handler, obtained with the load function.
+	@Param dest	The console of which the image will be blited. Foreground, background and character data will be overwritten.
+	@Param dx,dy	Coordinate of the console cell where the upper left corner of the blitted image will be.
+	@Param sx,sy,w,h	Part of the image to blit. Use -1 in w and h to blit the whole image.
+	*/	
+	void blit2x(TCODConsole *dest, int dx, int dy, int sx=0, int sy=0, int w=-1, int h=-1) const;
+
+	TCODImage(TCOD_image_t img) : data(img), deleteData(false) {}
+	virtual ~TCODImage();
+
+protected :
+	friend class TCODLIB_API TCODSystem;
+	friend class TCODLIB_API TCODZip;
+	void *data;
+	bool deleteData;
+};
+
--- /dev/null
+++ b/include/libtcod/lex.hpp
@@ -0,0 +1,73 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_LEX_HPP
+#define _TCOD_LEX_HPP
+/*
+ * This is a libtcod internal module.
+ * Use at your own risks...
+ */
+ 
+class TCODLIB_API TCODLex {
+public :
+	TCODLex();
+	TCODLex( const char **symbols, const char **keywords, const char *simpleComment="//", 
+		const char *commentStart="/*", const char *commentStop="*/", const char *javadocCommentStart="/**", 
+		const char *stringDelim="\"", int flags=TCOD_LEX_FLAG_NESTING_COMMENT);
+	~TCODLex();
+
+	void setDataBuffer(char *dat);
+	bool setDataFile(const char *filename);
+
+	int parse(void);
+	int parseUntil(int tokenType);
+	int parseUntil(const char *tokenValue);
+
+	bool expect(int tokenType);
+	bool expect(int tokenType,const char *tokenValue);
+
+	void savepoint(TCODLex *savept);
+	void restore(TCODLex *savept);
+	char *getLastJavadoc();
+
+	int getFileLine() { return ((TCOD_lex_t *)data)->file_line; }
+	int getTokenType() { return ((TCOD_lex_t *)data)->token_type; }
+	int getTokenIntVal() { return ((TCOD_lex_t *)data)->token_int_val; }
+	int getTokenIdx() { return ((TCOD_lex_t *)data)->token_idx; }
+	float getTokenFloatVal() { return ((TCOD_lex_t *)data)->token_float_val; }
+	char *getToken() { return ((TCOD_lex_t *)data)->tok; }
+	char getStringLastDelimiter() { return ((TCOD_lex_t *)data)->lastStringDelim; }
+	char *getPos() { return ((TCOD_lex_t *)data)->pos; }
+	char *getBuf() { return ((TCOD_lex_t *)data)->buf; }
+	char *getFilename() { return ((TCOD_lex_t *)data)->filename; }
+	char *getLastJavadocComment() { return ((TCOD_lex_t *)data)->last_javadoc_comment; }
+	static const char *getTokenName(int tokenType) { return TCOD_lex_get_token_name(tokenType); }
+protected :
+	void *data;
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/list.hpp
@@ -0,0 +1,616 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_LIST_HPP
+#define _TCOD_LIST_HPP
+
+#include <string.h> // memcpy
+#include <stdlib.h> // NULL
+
+/**
+ @PageName list
+ @PageCategory Base toolkits
+ @PageTitle All purposes container
+ @PageDesc This is a fast, lightweight and generic container, that provides array, list and stack paradigms.
+Note that this module has no python wrapper. Use python built-in containers instead.
+ */
+
+// fast & lightweight list template
+template <class T> class TCODList {
+	T *array;
+	int fillSize;
+	int allocSize;
+
+public :
+	/**
+	@PageName list_create
+	@PageFather list
+	@PageTitle Creating a list
+	@FuncTitle Using the default constructor
+	@FuncDesc You can create an empty list with the default constructor. The C version returns a handler on the list.
+	@Cpp template <class T> TCODList::TCODList()
+	@C TCOD_list_t TCOD_list_new()
+	@CppEx 
+		TCODList<int> intList;
+		TCODList<float> *floatList = new TCODList<float>();
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_t floatList = TCOD_list_new();
+	*/
+	TCODList() {
+		array=NULL;
+		fillSize=allocSize=0;
+	}
+
+	/**
+	@PageName list_create
+	@FuncTitle Duplicating an existing list
+	@FuncDesc You can create a list by duplicating an existing list.
+	@Cpp template <class T> TCODList::TCODList(const TCODList &l)
+	@C TCOD_list_t TCOD_list_duplicate(TCOD_list_t l)
+	@Param l	Existing list to duplicate.
+	@CppEx 
+		TCODList<int> intList;
+		intList.push(3);
+		intList.push(5);
+		TCODList<int> intList2(intList); // intList2 contains two elements : 3 and 5
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)3);
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_t intList2 = TCOD_list_duplicate(intList); // intList2 contains two elements : 3 and 5
+	*/
+	TCODList(const TCOD_list_t l) {
+		array=NULL;
+		fillSize=allocSize=0;
+		for ( void **it=TCOD_list_begin(l); it != TCOD_list_end(l); it++ ) {
+			push(*((T *)(it)));
+		}
+	}
+	TCODList(const TCODList<T> &l2) {
+		array=NULL;
+		fillSize=allocSize=0;
+		*this = l2;
+	}
+
+	/**
+	@PageName list_create
+	@FuncTitle Preallocating memory
+	@FuncDesc You can also create an empty list and pre-allocate memory for elements. Use this if you know the list size and want the memory to fit it perfectly.
+	@Cpp template <class T> TCODList::TCODList(int nbElements)
+	@C TCOD_list_t TCOD_list_allocate(int nbElements)
+	@Param nbElements	Allocate memory for nbElements.
+	@CppEx TCODList<int> intList(5); // create an empty list, pre-allocate memory for 5 elements
+	@CEx TCOD_list_t intList = TCOD_list_allocate(5);
+	*/
+	TCODList(int nbElements) {
+		fillSize=0;
+		allocSize=nbElements;
+		array=new T[ nbElements ];
+	}
+
+	/**
+	@PageName list_create
+	@FuncTitle Deleting a list
+	@FuncDesc You can delete a list, freeing any allocated resources. Note that deleting the list does not delete it's elements. You have to use clearAndDelete before deleting the list if you want to destroy the elements too.
+	@Cpp virtual template <class T> TCODList::~TCODList()
+	@C void TCOD_list_delete(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> *intList = new TCODList<int>(); // allocate a new empty list
+		intList->push(5); // the list contains 1 element at position 0, value = 5
+		delete intList; // destroy the list
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_delete(intList);
+	*/
+	virtual ~TCODList() {
+		if ( array ) delete [] array;
+	}
+
+	/**
+	@PageName list_array
+	@PageTitle Basic array operations
+	@PageFather list
+	@FuncTitle Setting an element
+	@FuncDesc You can assign a value with set. If needed, the array will allocate new elements up to idx.
+	@Cpp template <class T> void TCODList::set(const T elt, int idx)
+	@C void TCOD_list_set(TCOD_list_t l,const void *elt, int idx)
+	@Param elt	Element to put in the array.
+	@Param idx	Index of the element.
+		0 <= idx
+	@Param l	In the C version, the handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the array is empty (contains 0 elements)
+		intList.set(5,0); // the array contains 1 element at position 0, value = 5
+		intList.set(7,2); // the array contains 3 elements : 5, 0, 7
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,(const void *)5,0);
+		TCOD_list_set(intList,(const void *)7,2);
+	*/
+	void set(const T elt, int idx) {
+		if ( idx < 0 ) return;
+		while ( allocSize < idx+1 ) allocate();
+		array[idx] = elt;
+		if ( idx+1 > fillSize ) fillSize = idx+1;
+	}
+
+	/**
+	@PageName list_array
+	@FuncTitle Getting an element value
+	@FuncDesc You can retrieve a value with get.
+	@Cpp template <class T> T TCODList::get(int idx) const
+	@C void * TCOD_list_get(TCOD_list_t l,int idx)
+	@Param idx	Index of the element.
+		0 <= idx < size of the array
+	@Param l	In the C version, the handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList;
+		intList.set(5,0);
+		int val = intList.get(0); // val == 5
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,(const void *)5,0);
+		int val = (int)TCOD_list_get(intList,0); // val == 5
+	*/
+	T get(int idx) const {
+		return array[idx];
+	}
+
+	/**
+	@PageName list_array
+	@FuncTitle Checking if a list is empty
+	@Cpp template <class T> bool TCODList::isEmpty() const
+	@C bool TCOD_list_is_empty(TCOD_list_t l)
+	@Param l	In the C version, the handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList;
+		bool empty=intList.isEmpty(); // empty == true
+		intList.set(3,0);
+		empty=intList.isEmpty(); // empty == false
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		bool empty=TCOD_list_is_empty(intList); // empty == true 
+		TCOD_list_set(intList,(const void *)5,0);
+		empty=TCOD_list_is_empty(intList); // empty == false 
+	*/
+	bool isEmpty() const {
+		return ( fillSize == 0 );
+	}
+
+	/**
+	@PageName list_array
+	@FuncTitle Getting the list size
+	@Cpp template <class T> int TCODList::size() const
+	@C int TCOD_list_size(TCOD_list_t l)
+	@Param l	In the C version, the handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList;
+		int size=intList.size(); // size == 0
+		intList.set(3,0);
+		size=intList.size(); // size == 1
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		int size=TCOD_list_size(intList); // size == 0 
+		TCOD_list_set(intList,(const void *)5,0);
+		size=TCOD_list_size(intList); // size == 1 
+	*/
+	int size() const {
+		return fillSize;
+	}
+
+	/**
+	@PageName list_array
+	@FuncTitle Checking if an element is in the list
+	@Cpp template <class T> bool TCODList::contains(const T elt) const
+	@C bool TCOD_list_contains(TCOD_list_t l,const void * elt)
+	@Param elt	The element.
+	@Param l	In the C version, the handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList;
+		intList.set(3,0);
+		bool has3 = intList.contains(3); // has3 == true
+		bool has4 = intList.contains(4); // has4 == false
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,(const void *)3,0);
+		bool has3 = TCOD_list_contains(intList,(const void *)3); // has3 == true 
+		bool has4 = TCOD_list_contains(intList,(const void *)4); // has4 == false 
+	*/
+	bool contains(const T elt) const {
+		for ( T* curElt = begin(); curElt != end(); curElt ++) {
+			if ( *curElt == elt ) return true;
+		}
+		return false;
+	}
+
+	/**
+	@PageName list_list
+	@PageFather list
+	@PageTitle Basic list operations
+	@FuncTitle Insert an element in the list
+	@Cpp template <class T> void TCODList::insertBefore(const T elt,int before)
+	@C void TCOD_list_insert_before(TCOD_list_t l,const void *elt,int before)
+	@Param elt	Element to insert in the list.
+	@Param idx	Index of the element after the insertion.
+		0 <= idx < list size
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.set(0,5); // the list contains 1 element at position 0, value = 5
+		intList.insertBefore(2,0); // the list contains 2 elements : 2,5
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,0,(const void *)5);
+		TCOD_list_insert_before(intList,(const void *)2,0);
+	*/
+	T * insertBefore(const T elt,int before) {
+		if ( fillSize+1 >= allocSize ) allocate();
+		for (int idx=fillSize; idx > before; idx--) {
+			array[idx]=array[idx-1];
+		}
+		array[before]=elt;
+		fillSize++;
+		return &array[before];
+	}
+
+	/**
+	@PageName list_list
+	@FuncTitle Removing an element from the list
+	@FuncDesc The _fast versions replace the element to remove with the last element of the list. They're faster, but do not preserve the list order.
+	@Cpp 
+		template <class T> void TCODList::remove(const T elt)
+		template <class T> void TCODList::removeFast(const T elt)
+	@C 
+		void TCOD_list_remove(TCOD_list_t l, const void * elt)
+		void TCOD_list_remove_fast(TCOD_list_t l, const void * elt)
+	@Param elt	The element to remove
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.set(0,5); // the list contains 1 element at position 0, value = 5
+		intList.remove(5); // the list is empty
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,0,(const void *)5);
+		TCOD_list_remove(intList,(const void *)5);
+	*/
+	void remove(const T elt) {
+		for ( T* curElt = begin(); curElt != end(); curElt ++) {
+			if ( *curElt == elt ) {
+				remove(curElt);
+				return;
+			}
+		}
+	}
+	void removeFast(const T elt) {
+		for ( T* curElt = begin(); curElt != end(); curElt ++) {
+			if ( *curElt == elt ) {
+				removeFast(curElt);
+				return;
+			}
+		}
+	}
+
+	/**
+	@PageName list_list
+	@FuncTitle Concatenating two lists
+	@FuncDesc You can concatenate two lists. Every element of l2 will be added to current list (or l in the C version) :
+	@Cpp template <class T> void TCODList::addAll(const TCODList &l2)
+	@C void TCOD_list_add_all(TCOD_list_t l, TCOD_list_t l2)
+	@Param l	The list inside which elements will be added.
+	@Param l2	the list handler containing elements to insert.
+	@CppEx 
+		TCODList<int> intList;
+		intList.set(1,3); // intList contains 2 elements : 0, 3
+		TCODList<int> intList2; // intList2 is empty
+		intList2.set(0,1); // intList2 contains 1 element : 1
+		intList2.addAll(intList); // intList2 contains 3 elements : 1, 0, 3
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,1,(const void *)3);
+		TCOD_list_t intList2 = TCOD_list_new();
+		TCOD_list_set(intList2,0,(const void *)1);
+		TCOD_list_add_all(intList2,intList);
+	*/
+	void addAll(const TCODList<T> &l2) {
+		for (T *t=l2.begin(); t!= l2.end(); t++) {
+			push(*t);
+		}
+	}
+
+	/**
+	@PageName list_list
+	@FuncTitle Emptying a list
+	@Cpp template <class T> void TCODList::clear()
+	@C void TCOD_list_clear(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList;
+		intList.set(0,3); // intList contains 1 element
+		intList.clear(); // intList is empty
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_set(intList,0,(const void *)5);
+		TCOD_list_clear(intList);
+	*/
+	void clear() {
+		fillSize=0;
+	}
+	/**
+	@PageName list_list
+	@FuncTitle Emptying a list and destroying its elements
+	@FuncDesc For lists containing pointers, you can clear the list and delete (or free for C) the elements :
+	@Cpp template <class T> void TCODList::clearAndDelete()
+	@C void TCOD_list_clear_and_delete(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<MyClass *> intList;
+		MyClass * cl=new MyClass(); // new instance of MyClass allocated here
+		intList.set(0,cl); 
+		intList.clear(); // the list is empty. cl is always valid
+		intList.set(0,cl); 
+		intList.clearAndDelete(); // the list is empty. delete cl has been called. The address cl is no longer valid.
+	@C 
+		TCOD_list_t intList = TCOD_list_new();
+		void *data=calloc(10,1); // some memory allocation here 
+		TCOD_list_set(intList,0,(const void *)data);
+		TCOD_list_clear(intList); // the list is empty, but data is always valid 
+		TCOD_list_set(intList,0,(const void *)data);
+		TCOD_list_clear_and_delete(intList); // the list is empty, free(data) has been called. The address data is no longer valid 
+	*/
+	void clearAndDelete() {
+		for ( T* curElt = begin(); curElt != end(); curElt ++ ) {
+			delete (*curElt);
+		}
+		fillSize=0;
+	}
+
+	/**
+	@PageName list_list
+	@FuncTitle Reversing a list
+	@FuncDesc This function reverses the order of the elements in the list.</b>
+	@Cpp 
+		void TCODList::reverse()
+	@C 
+		void TCOD_list_reverse(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.push(5); // the list contains 1 element at position 0, value = 5
+		intList.push(2); // the list contains 2 elements : 5,2
+		intList.reverse(); // now order is 2,5
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_push(intList,(const void *)2);
+		TCOD_list_reverse();
+	*/
+	void reverse() {
+		T* head = begin();
+		T* tail = end();
+		while ( head < tail ) {
+			T tmp = *head;
+			*head=*tail;
+			*tail=tmp;
+			head++;
+			tail--;
+		}
+	}
+
+	/**
+	@PageName list_stack
+	@PageTitle Basic stack operations
+	@PageFather list
+	@FuncTitle Pushing an element on the stack
+	@FuncDesc You can push an element on the stack (append it to the end of the list) :
+	@Cpp template <class T> void TCODList::push(const T elt) 
+	@C void TCOD_list_push(TCOD_list_t l, const void * elt)
+	@Param elt	Element to append to the list.
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.push(5); // the list contains 1 element at position 0, value = 5
+		intList.push(2); // the list contains 2 elements : 5,2
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_push(intList,(const void *)2);
+	*/
+	void push(const T elt) {
+		if ( fillSize+1 >= allocSize ) allocate();
+		array[fillSize++] = elt;
+	}
+
+	/**
+	@PageName list_stack
+	@FuncTitle Poping an element from the stack
+	@FuncDesc You can pop an element from the stack (remove the last element of the list).
+	@Cpp template <class T> T TCODList::pop()
+	@C void * TCOD_list_pop(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.push(5); // the list contains 1 element at position 0, value = 5
+		intList.push(2); // the list contains 2 elements : 5,2
+		int val = intList.pop(); // val == 2, the list contains 1 element : 5
+		val = intList.pop(); // val == 5, the list is empty
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_push(intList,(const void *)2);
+		int val = (int)TCOD_list_pop(intList);
+		val = (int)TCOD_list_pop(intList);
+	*/
+	T pop() {
+		if ( fillSize == 0 ) return (T)0;
+		return array[--fillSize];
+	}
+
+	/**
+	@PageName list_stack
+	@FuncTitle Peeking the last element of the stack
+	@FuncDesc You can read the last element of the stack without removing it :
+	@Cpp template <class T> T TCODList::peek() const
+	@C void * TCOD_list_peek(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList;
+		intList.push(3); // intList contains 1 elements : 3
+		int val = intList.peek(); // val == 3, inList contains 1 elements : 3
+		intList.push(2); // intList contains 2 elements : 3, 2
+		val = intList.peek(); // val == 2, inList contains 2 elements : 3, 2
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)3);
+		int val = (int)TCOD_list_peek(intList);
+		TCOD_list_push(intList,(const void *)2);
+		val = (int)TCOD_list_peek(intList);
+	*/
+	T peek() const {
+		if ( fillSize == 0 ) return (T)0;
+		return array[fillSize-1];
+	}
+
+	/**
+	@PageName list_iterator
+	@PageFather list
+	@PageTitle Iterators
+	@FuncDesc You can iterate through the elements of the list using an iterator. begin() returns the address of the first element of the list. You go to the next element using the increment operator ++. When the iterator's value is equal to end(), you've gone through all the elements. <b>Warning ! You cannot insert elements in the list while iterating through it. Inserting elements can result in reallocation of the list and your iterator will not longer be valid.</b>
+	@Cpp 
+		template <class T> T * TCODList::begin() const
+		template <class T> T * TCODList::end() const
+	@C 
+		void ** TCOD_list_begin(TCOD_list_t l)
+		void ** TCOD_list_end(TCOD_list_t l)
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.push(5); // the list contains 1 element at position 0, value = 5
+		intList.push(2); // the list contains 2 elements : 5,2
+		for ( int * iterator = intList.begin(); iterator != intList.end(); iterator ++ ) {
+			int currentValue=*iterator;
+			printf("value : %d\n", currentValue );
+		}
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_push(intList,(const void *)2);
+		for ( int * iterator = (int *)TCOD_list_begin(intList); iterator != (int *)TCOD_list_end(intList); iterator ++ ) {
+			int currentValue=*iterator;
+			printf("value : %d\n", currentValue );
+		}
+	*/
+	T * begin() const {
+		if ( fillSize == 0 ) return (T *)NULL;
+		return &array[0];
+	}
+	T * end() const {
+		if ( fillSize == 0 ) return (T *)NULL;
+		return &array[fillSize];
+	}
+
+	/**
+	@PageName list_iterator
+	@FuncDesc You can remove an element from the list while iterating. The element at the iterator position will be removed. The function returns the new iterator. The _fast versions replace the element to remove with the last element of the list. They're faster, but do not preserve the list order.
+	@Cpp 
+		template <class T> T *TCODList::remove(T *iterator)
+		template <class T> T *TCODList::removeFast(T *iterator)
+	@C 
+		void **TCOD_list_remove_iterator(TCOD_list_t l, void **iterator)
+		void **TCOD_list_remove_iterator_fast(TCOD_list_t l, void **iterator)
+	@Param iterator	The list iterator.
+	@Param l	In the C version, the list handler, returned by a constructor.
+	@CppEx 
+		TCODList<int> intList; // the list is empty (contains 0 elements)
+		intList.push(5); // the list contains 1 element at position 0, value = 5
+		intList.push(2); // the list contains 2 elements : 5,2
+		intList.push(3); // the list contains 3 elements : 5,2,3
+		for ( int * iterator = intList.begin(); iterator != intList.end(); iterator ++ ) {
+			int currentValue=*iterator;
+			if ( currentValue == 2 ) {
+				// remove this value from the list and keep iterating on next element (value == 3)
+				iterator = intList.remove(iterator);
+			}
+			printf("value : %d\n", currentValue ); // all 3 values will be printed : 5,2,3
+		}
+		// now the list contains only two elements : 5,3
+	@CEx 
+		TCOD_list_t intList = TCOD_list_new();
+		TCOD_list_push(intList,(const void *)5);
+		TCOD_list_push(intList,(const void *)2);
+		TCOD_list_push(intList,(const void *)3);
+		for ( int * iterator = (int *)TCOD_list_begin(intList); iterator != (int *)TCOD_list_end(intList); iterator ++ ) {
+			int currentValue=*iterator;
+			if ( currentValue == 2 ) {
+				iterator = (int *)TCOD_list_remove_iterator(intList,(void **)iterator);
+			}
+			printf("value : %d\n", currentValue );
+		}
+	*/
+	T *remove(T *elt) {
+		for ( T* curElt = elt; curElt < end()-1; curElt ++) {
+			*curElt = *(curElt+1);
+		}
+		fillSize--;
+		if ( fillSize == 0 ) return ((T *)NULL)-1;
+		else return elt-1;
+	}
+	T *removeFast(T *elt) {
+		*elt = array[fillSize-1];
+		fillSize--;
+		if ( fillSize == 0 ) return ((T *)NULL)-1;
+		else return elt-1;
+	}
+
+	TCODList<T> & operator = (TCODList<T> const & l2) {
+		while ( allocSize < l2.allocSize ) allocate();
+		fillSize=l2.fillSize;
+		int i=0;
+		for (T *t=l2.begin(); t != l2.end(); t++) {
+			array[i++]=*t;
+		}
+		return *this;
+	}  
+
+protected :
+	void allocate() {
+		int newSize = allocSize * 2;
+		if ( newSize == 0 ) newSize = 16;
+		T *newArray = new T[ newSize ];
+		if ( array ) {
+			if ( fillSize > 0 ) memcpy(newArray, array, sizeof(T)*fillSize);
+			delete [] array;
+		}
+		array=newArray;
+		allocSize=newSize;
+	}
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/mersenne.hpp
@@ -0,0 +1,400 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_RANDOM_HPP
+#define _TCOD_RANDOM_HPP
+
+#include "mersenne_types.h"
+
+/**
+ @PageName random
+ @PageCategory Base toolkits
+ @PageTitle Pseudorandom number generator
+ @PageDesc This toolkit is an implementation of two fast and high quality pseudorandom number generators:
+* a Mersenne twister generator,
+* a Complementary-Multiply-With-Carry generator.
+CMWC is faster than MT (see table below) and has a much better period (1039460 vs. 106001). It is the default algo since libtcod 1.5.0.
+
+Relative performances in two independent tests (lower is better) :
+<table class="param">
+    <tr>
+      <th>Algorithm</th>
+      <th>Numbers generated</th>
+      <th>Perf (1)</th>
+      <th>Perf (2)</th>
+    </tr>
+    <tr class="hilite">
+      <td>MT</td>
+      <td>integer</td>
+      <td>62</td>
+      <td>50</td>
+    </tr>
+    <tr>
+      <td>MT</td>
+      <td>float</td>
+      <td>54</td>
+      <td>45</td>
+    </tr>
+    <tr class="hilite">
+      <td>CMWC</td>
+      <td>integer</td>
+      <td>21</td>
+      <td>34</td>
+    </tr>
+    <tr>
+      <td>CMWC</td>
+      <td>float</td>
+      <td>32</td>
+      <td>27</td>
+    </tr>
+</table>
+
+<h6>For python users:</h6>
+Python already has great builtin random generators. But some parts of the Doryen library (noise, heightmap, ...) uses RNG as parameters. If you intend to use those functions, you must provide a RNG created with the library.
+
+<h6>For C# users:</h6>
+.NET already has great builtin random generators. But some parts of the Doryen library (noise, heightmap, ...) uses RNG as parameters. If you intend to use those functions, you must provide a RNG created with the library.
+ */
+
+class TCODLIB_API TCODRandom {
+	public :
+		/**
+		@PageName random_init
+		@PageFather random
+		@PageTitle Creating a generator
+		@FuncTitle Default generator
+		@FuncDesc The simplest way to get random number is to use the default generator. The first time you get this generator, it is initialized by calling TCOD_random_new. Then, on successive calls, this function returns the same generator (singleton pattern).
+		@Cpp static TCODRandom * TCODRandom::getInstance (void)
+		@C TCOD_random_t TCOD_random_get_instance (void)
+		@Py random_get_instance ()
+		@C# static TCODRandom TCODRandom::getInstance()
+		@Param algo	The PRNG algorithm the generator should be using. Possible values are:
+			* TCOD_RNG_MT for Mersenne Twister,
+			* TCOD_RNG_CMWC for Complementary Multiply-With-Carry.
+		*/
+		static TCODRandom * getInstance(void);
+
+		/**
+		@PageName random_init
+		@FuncTitle Generators with random seeds
+		@FuncDesc You can also create as many generators as you want with a random seed (the number of seconds since Jan 1 1970 at the time the constructor is called). Warning ! If you call this function several times in the same second, it will return the same generator.
+		@Cpp TCODRandom::TCODRandom (TCOD_random_algo_t algo = TCOD_RNG_CMWC)
+		@C TCOD_random_t TCOD_random_new (TCOD_random_algo_t algo)
+		@Py random_new (algo = RNG_CMWC)
+		@C#
+			TCODRandom::TCODRandom() // Defaults to ComplementaryMultiplyWithCarry
+			TCODRandom::TCODRandom(TCODRandomType algo)
+		@Param algo	The PRNG algorithm the generator should be using.
+		*/
+		TCODRandom(TCOD_random_algo_t algo = TCOD_RNG_CMWC, bool allocate = true);
+
+		/**
+		@PageName random_init
+		@FuncTitle Generators with user defined seeds
+		@FuncDesc Finally, you can create generators with a specific seed. Those allow you to get a reproducible set of random numbers. You can for example save a dungeon in a file by saving only the seed used for its generation (provided you have a determinist generation algorithm)
+		@Cpp TCODRandom::TCODRandom (uint32 seed, TCOD_random_algo_t algo = TCOD_RNG_CMWC);
+		@C TCOD_random_t TCOD_random_new_from_seed (TCOD_random_algo_t algo, uint32 seed);
+		@Py random_new_from_seed(seed, algo=RNG_CMWC)
+		@C#
+			TCODRandom::TCODRandom(uint32 seed) // Defaults to ComplementaryMultiplyWithCarry
+			TCODRandom::TCODRandom(uint32 seed, TCODRandomType algo)
+		@Param seed	The 32 bits seed used to initialize the generator. Two generators created with the same seed will generate the same set of pseudorandom numbers.
+		@Param algo	The PRNG algorithm the generator should be using.
+		@CppEx
+			// default generator
+			TCODRandom * default = TCODRandom::getInstance();
+			// another random generator
+			TCODRandom * myRandom = new TCODRandom();
+			// a random generator with a specific seed
+			TCODRandom * myDeterministRandom = new TCODRandom(0xdeadbeef);
+        @CEx
+			// default generator
+			TCOD_random_t default = TCOD_random_get_instance();
+			// another random generator
+			TCOD_random_t my_random = TCOD_random_new(TCOD_RNG_CMWC);
+			// a random generator with a specific seed
+			TCOD_random_t my_determinist_random = TCOD_random_new_from_seed(TCOD_RNG_CMWC,0xdeadbeef);
+		@PyEx
+			# default generator
+			default = libtcod.random_get_instance()
+			# another random generator
+			my_random = libtcod.random_new()
+			# a random generator with a specific seed
+			my_determinist_random = libtcod.random_new_from_seed(0xdeadbeef)
+		*/
+		TCODRandom(uint32 seed, TCOD_random_algo_t algo = TCOD_RNG_CMWC);
+
+		/**
+		@PageName random_init
+		@FuncTitle Destroying a RNG
+		@FuncDesc To release ressources used by a generator, use those functions :
+			NB : do not delete the default random generator !
+		@Cpp TCODRandom::~TCODRandom()
+		@C void TCOD_random_delete(TCOD_random_t mersenne)
+		@Py random_delete(mersenne)
+		@C# void TCODRandom::Dispose()
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions.
+		@CppEx
+			// create a generator
+			TCODRandom *rnd = new TCODRandom();
+			// use it
+			...
+			// destroy it
+			delete rnd;
+		@CEx
+			// create a generator
+			TCOD_random_t rnd = TCOD_random_new();
+			// use it
+			...
+			// destroy it
+			TCOD_random_delete(rnd);
+		@PyEx
+			# create a generator
+			rnd = libtcod.random_new()
+			# use it
+			...
+			# destroy it
+			libtcod.random_delete(rnd)
+		*/
+		virtual ~TCODRandom();
+
+		/**
+		@PageName random_distro
+		@PageFather random
+		@PageTitle Using a generator
+		@FuncTitle Setting the default RNG distribution
+		@FuncDesc Random numbers can be obtained using several different distributions. Linear is default, but if you wish to use one of the available Gaussian distributions, you can use this function to tell libtcod which is your preferred distribution. All random number getters will then use that distribution automatically to fetch your random numbers.
+The distributions available are as follows:
+1. TCOD_DISTRIBUTION_LINEAR
+This is the default distribution. It will return a number from a range min-max. The numbers will be evenly distributed, ie, each number from the range has the exact same chance of being selected.
+2. TCOD_DISTRIBUTION_GAUSSIAN
+This distribution does not have minimum and maximum values. Instead, a mean and a standard deviation are used. The mean is the central value. It will appear with the greatest frequency. The farther away from the mean, the less the probability of appearing the possible results have. Although extreme values are possible, 99.7% of the results will be within the radius of 3 standard deviations from the mean. So, if the mean is 0 and the standard deviation is 5, the numbers will mostly fall in the (-15,15) range.
+3. TCOD_DISTRIBUTION_GAUSSIAN_RANGE
+This one takes minimum and maximum values. Under the hood, it computes the mean (which falls right between the minimum and maximum) and the standard deviation and applies a standard Gaussian distribution to the values. The difference is that the result is always guaranteed to be in the min-max range.
+4. TCOD_DISTRIBUTION_GAUSSIAN_INVERSE
+Essentially, this is the same as TCOD_DISTRIBUTION_GAUSSIAN. The difference is that the values near +3 and -3 standard deviations from the mean have the highest possibility of appearing, while the mean has the lowest.
+5. TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE
+Essentially, this is the same as TCOD_DISTRIBUTION_GAUSSIAN_RANGE, but the min and max values have the greatest probability of appearing, while the values between them, the lowest.
+
+There exist functions to also specify both a min-max range AND a custom mean, which can be any value (possibly either min or max, but it can even be outside that range). In case such a function is used, the distributions will trigger a slihtly different behaviour:
+* TCOD_DISTRIBUTION_LINEAR
+* TCOD_DISTRIBUTION_GAUSSIAN
+* TCOD_DISTRIBUTION_GAUSSIAN_RANGE
+In these cases, the selected mean will have the highest probability of appearing.
+
+* TCOD_DISTRIBUTION_GAUSSIAN_INVERSE
+* TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE
+In these cases, the selected mean will appear with the lowest frequency.
+		@Cpp void TCODRandom::setDistribution(TCOD_distribution_t distribution)
+		@C void TCOD_random_set_distribution(TCOD_random_t mersenne, TCOD_distribution_t distribution)
+		@Py
+		@C#
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used..
+		@Param distribution The distribution constant from the available set:<ul><li>TCOD_DISTRIBUTION_LINEAR</li><li>TCOD_DISTRIBUTION_GAUSSIAN</li><li>TCOD_DISTRIBUTION_GAUSSIAN_RANGE</li><li>TCOD_DISTRIBUTION_GAUSSIAN_INVERSE</li><li>TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE</li></ul>
+		*/
+		inline void setDistribution (TCOD_distribution_t distribution) { TCOD_random_set_distribution(data,distribution); }
+
+		/**
+		@PageName random_use
+		@PageFather random
+		@PageTitle Using a generator
+		@FuncTitle Getting an integer
+		@FuncDesc Once you obtained a generator (using one of those methods), you can get random numbers using the following functions, using either the explicit or simplified API where applicable:
+		@Cpp
+			//explicit API:
+			int TCODRandom::getInt(int min, int max, int mean = 0)
+
+			//simplified API:
+			int TCODRandom::get(int min, int max, int mean = 0)
+		@C
+			int TCOD_random_get_int(TCOD_random_t mersenne, int min, int max)
+			int TCOD_random_get_int_mean(TCOD_random_t mersenne, int min, int max, int mean)
+		@Py
+		@C#
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used..
+		@Param min,max	Range of values returned. Each time you call this function, you get a number between (including) min and max
+		@Param mean This is used to set a custom mean, ie, not min+((max-min)/2). It can even be outside of the min-max range. Using a mean will force the use of a weighted (Gaussian) distribution, even if linear is set.
+		*/
+		inline int getInt (int min, int max, int mean = 0) { return (mean <= 0) ? TCOD_random_get_int(data,min,max) : TCOD_random_get_int_mean(data,min,max,mean); }
+		inline int get (int min, int max, int mean = 0) { return (mean <= 0) ? TCOD_random_get_int(data,min,max) : TCOD_random_get_int_mean(data,min,max,mean); }
+
+		/**
+		@PageName random_use
+		@FuncTitle Getting a float
+		@FuncDesc To get a random floating point number, using either the explicit or simplified API where applicable
+		@Cpp
+			//explicit API:
+			float TCODRandom::getFloat(float min, float max, float mean = 0.0f)
+
+			//simplified API:
+			float TCODRandom::get(float min, float max, float mean = 0.0f)
+		@C
+			float TCOD_random_get_float(TCOD_random_t mersenne, float min, float max)
+			float TCOD_random_get_float_mean(TCOD_random_t mersenne, float min, float max, float mean)
+		@Py random_get_float(mersenne, mi, ma)
+		@C# float TCODRandom::getFloat(float min, float max)
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
+		@Param min,max	Range of values returned. Each time you call this function, you get a number between (including) min and max
+		@Param mean This is used to set a custom mean, ie, not min+((max-min)/2). It can even be outside of the min-max range. Using a mean will force the use of a weighted (Gaussian) distribution, even if linear is set.
+		@CppEx
+			// default generator
+			TCODRandom * default = TCODRandom::getInstance();
+			int aRandomIntBetween0And1000 = default->getInt(0,1000);
+			int anotherRandomInt = default->get(0,1000);
+			// another random generator
+			TCODRandom *myRandom = new TCODRandom();
+			float aRandomFloatBetween0And1000 = myRandom->getFloat(0.0f,1000.0f);
+			float anotherRandomFloat = myRandom->get(0.0f,1000.0f);
+		@CEx
+			// default generator
+			int a_random_int_between_0_and_1000 = TCOD_random_get_float(NULL,0,1000);
+			// another random generator
+			TCOD_random_t my_random = TCOD_random_new();
+			float a_random_float_between_0_and_1000 = TCOD_random_get_float(my_random,0.0f,1000.0f);
+		@PyEx
+			# default generator
+			a_random_int_between_0_and_1000 = libtcod.random_get_float(0,0,1000)
+			# another random generator
+			my_random = libtcod.random_new()
+			a_random_float_between_0_and_1000 = libtcod.random_get_float(my_random,0.0,1000.0)
+		*/
+		inline float getFloat (float min, float max, float mean = 0.0f) { return (mean <= 0) ? TCOD_random_get_float(data,min,max) : TCOD_random_get_float_mean(data,min,max,mean); }
+		inline float get (float min, float max, float mean = 0.0f) { return (mean <= 0.0f) ? TCOD_random_get_float(data,min,max) : TCOD_random_get_float_mean(data,min,max,mean); }
+
+		/**
+		@PageName random_use
+		@FuncTitle Getting a double
+		@FuncDesc To get a random double precision floating point number, using either the explicit or simplified API where applicable
+		@Cpp
+			//explicit API:
+			double TCODRandom::getDouble(double min, double max, double mean = 0.0f)
+
+			//simplified API:
+			double TCODRandom::get(double min, double max, double mean = 0.0f)
+		@C
+			double TCOD_random_get_double(TCOD_random_t mersenne, double min, double max)
+			double TCOD_random_get_double_mean(TCOD_random_t mersenne, double min, double max, double mean)
+		@Py
+		@C#
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
+		@Param min,max	Range of values returned. Each time you call this function, you get a number between (including) min and max
+		@Param mean This is used to set a custom mean, ie, not min+((max-min)/2). It can even be outside of the min-max range. Using a mean will force the use of a weighted (Gaussian) distribution, even if linear is set.
+		@CppEx
+			// default generator
+			TCODRandom * default = TCODRandom::getInstance();
+			int aRandomIntBetween0And1000 = default->getInt(0,1000);
+			int anotherRandomInt = default->get(0,1000);
+			// another random generator
+			TCODRandom *myRandom = new TCODRandom();
+			float aRandomFloatBetween0And1000 = myRandom->getFloat(0.0f,1000.0f);
+			float anotherRandomFloat = myRandom->get(0.0f,1000.0f);
+		@CEx
+			// default generator
+			int a_random_int_between_0_and_1000 = TCOD_random_get_float(NULL,0,1000);
+			// another random generator
+			TCOD_random_t my_random = TCOD_random_new();
+			float a_random_float_between_0_and_1000 = TCOD_random_get_float(my_random,0.0f,1000.0f);
+		@PyEx
+			# default generator
+			a_random_int_between_0_and_1000 = libtcod.random_get_float(0,0,1000)
+			# another random generator
+			my_random = libtcod.random_new()
+			a_random_float_between_0_and_1000 = libtcod.random_get_float(my_random,0.0,1000.0)
+		*/
+		inline double getDouble (double min, double max, double mean = 0.0) { return (mean <= 0) ? TCOD_random_get_double(data,min,max) : TCOD_random_get_double_mean(data,min,max,mean); }
+		inline double get (double min, double max, double mean = 0.0f) { return (mean <= 0.0) ? TCOD_random_get_double(data,min,max) : TCOD_random_get_double_mean(data,min,max,mean); }
+
+		/**
+		@PageName random_use
+		@FuncTitle Saving a RNG state
+		@FuncDesc You can save the state of a generator with :
+		@Cpp TCODRandom *TCODRandom::save() const
+		@C TCOD_random_t TCOD_random_save(TCOD_random_t mersenne)
+		@Py random_save(mersenne)
+		@C# TCODRandom TCODRandom::save()
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
+		*/
+		TCODRandom * save() const;
+
+		/**
+		@PageName random_use
+		@FuncTitle Restoring a saved state
+		@FuncDesc And restore it later. This makes it possible to get the same serie of number several times with a single generator.
+		@Cpp void TCODRandom::restore(const TCODRandom *backup)
+		@C void TCOD_random_restore(TCOD_random_t mersenne, TCOD_random_t backup)
+		@Py random_restore(mersenne, backup)
+		@C# void TCODRandom::restore(TCODRandom backup)
+		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
+		@CppEx
+			// default generator
+			TCODRandom * default = TCODRandom::getInstance();
+			// save the state
+			TCODRandom *backup=default->save();
+			// get a random number (or several)
+			int number1 = default->getInt(0,1000);
+			// restore the state
+			default->restore(backup);
+			// get a random number
+			int number2 = default->getInt(0,1000);
+			// => number1 == number2
+		@CEx
+			// save default generator state
+			TCOD_random_t backup=TCOD_random_save(NULL);
+			// get a random number
+			int number1 = TCOD_random_get_float(NULL,0,1000);
+			// restore the state
+			TCOD_random_restore(NULL,backup);
+			// get a random number
+			int number2 = TCOD_random_get_float(NULL,0,1000);
+			// number1 == number2
+		@PyEx
+			# save default generator state
+			backup=libtcod.random_save(0)
+			# get a random number
+			number1 = libtcod.random_get_float(0,0,1000)
+			# restore the state
+			libtcod.random_restore(0,backup)
+			# get a random number
+			number2 = libtcod.random_get_float(0,0,1000)
+			# number1 == number2
+		*/
+		void restore(const TCODRandom *backup);
+
+		//dice
+		inline TCOD_dice_t dice (const char * s) { return TCOD_random_dice_new(s); }
+		inline int diceRoll (TCOD_dice_t dice) { return TCOD_random_dice_roll(data,dice); }
+		inline int diceRoll (const char * s) { return TCOD_random_dice_roll(data,TCOD_random_dice_new(s)); }
+
+	protected :
+		friend class TCODLIB_API TCODNoise;
+		friend class TCODLIB_API TCODHeightMap;
+		friend class TCODLIB_API TCODNamegen;
+		friend class TCODNameGenerator;	// Used for SWIG interface, does NOT need TCODLIB_API
+		TCOD_random_t data;
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/mouse.hpp
@@ -0,0 +1,111 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_MOUSE_HPP
+#define _TCOD_MOUSE_HPP
+
+#include "mouse_types.h"
+
+class TCODLIB_API TCODMouse {
+public :
+	/**
+	@PageName mouse
+	@PageTitle Mouse support
+	@PageCategory Base toolkits
+	@FuncTitle Display and hide the mouse cursor
+	@FuncDesc By default, the mouse cursor in visible in windowed mode, hidden in fullscreen mode. You can change it with:
+	@Cpp static void TCODMouse::showCursor (bool visible)
+	@C void TCOD_mouse_show_cursor (bool visible)
+	@Py mouse_show_cursor (visible)
+	@C# void TCODMouse::showCursor(bool visible)
+	@Param visible	If true, this function turns the mouse cursor on. Else it turns the mouse cursor off.
+	*/
+	static void showCursor(bool visible);
+
+	/**
+	@PageName mouse
+	@FuncTitle Getting the cursor status
+	@FuncDesc You can get the current cursor status (hidden or visible) with:
+	@Cpp static bool TCODMouse::isCursorVisible (void)
+	@C bool TCOD_mouse_is_cursor_visible (void)
+	@Py mouse_is_cursor_visible ()
+	@C# bool TCODMouse::isCursorVisible()
+	*/
+	static bool isCursorVisible();
+
+	/**
+	@PageName mouse
+	@FuncTitle Setting the mouse cursor's position
+	@FuncDesc You can set the cursor position (in pixel coordinates, where [0,0] is the window's top left corner) with:
+	@Cpp static void TCODMouse::move (int x, int y)
+	@C void TCOD_mouse_move (int x, int y)
+	@Py mouse_move (x, y)
+	@C# void TCODMouse::moveMouse(int x, int y)
+	@Param x,y	New coordinates of the mouse cursor in pixels.
+	*/
+	static void move(int x, int y);
+
+	/**
+	@PageName mouse
+	@FuncTitle Getting the mouse status
+	@FuncDesc You can read the current mouse status with this function. Note that this function does not update the mouse status. You have to call either TCODSystem::checkForEvent or TCODSystem::waitForEvent for the mouse status to be updated.
+<div class="code"><pre>typedef struct {
+  int x,y;
+  int dx,dy;
+  int cx,cy;
+  int dcx,dcy;
+  bool lbutton; 
+  bool rbutton;
+  bool mbutton;
+  bool lbutton_pressed; 
+  bool rbutton_pressed; 
+  bool mbutton_pressed; 
+  bool wheel_up;
+  bool wheel_down;
+} TCOD_mouse_t;
+</pre></div>
+	@Cpp static TCOD_mouse_t TCODMouse::getStatus (void)
+	@C TCOD_mouse_t TCOD_mouse_get_status (void)
+	@Py mouse_get_status ()
+	@C# TCODMouseData TCODMouse::getStatus()
+	@Param x, y	Absolute position of the mouse cursor in pixels relative to the window top-left corner.
+	@Param dx, dy	Movement of the mouse cursor since the last call in pixels.
+	@Param cx, cy	Coordinates of the console cell under the mouse cursor (pixel coordinates divided by the font size).
+	@Param dcx, dcy	Movement of the mouse since the last call in console cells (pixel coordinates divided by the font size).
+	@Param lbutton	true if the left button is pressed.
+	@Param rbutton	true if the right button is pressed.
+	@Param mbutton	true if the middle button (or the wheel) is pressed.
+	@Param lbutton_pressed	true if the left button was pressed and released.
+	@Param rbutton_pressed	true if the right button was pressed and released.
+	@Param mbutton_pressed	true if the middle button was pressed and released.
+	@Param wheel_up	true if the wheel was rolled up.
+	@Param wheel_down	true if the wheel was rolled down.
+	*/
+	static TCOD_mouse_t getStatus();
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/namegen.hpp
@@ -0,0 +1,290 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*
+* Mingos' NameGen
+* This file was written by Dominik "Mingos" Marczuk.
+*/
+
+#ifndef _TCOD_NAMEGEN_HPP
+#define _TCOD_NAMEGEN_HPP
+
+/**
+ @PageName namegen
+ @PageCategory Roguelike toolkits
+ @PageTitle Name generator
+ @PageDesc This tool allows to generate random names out of custom made syllable sets.
+ */
+class TCODLIB_API TCODNamegen {
+	public:
+		/**
+		@PageName namegen_init
+		@PageFather namegen
+		@PageTitle Creating a generator
+		@FuncDesc In order to be able to generate names, the name generator needs to be fed proper data. It will then be ready to generate random names defined in the file(s) it is fed. Syllable set parsing is achieved via the following.
+			Note 1: Each file will be parsed once only. If, for some reason, you would like to parse the same file twice, you will need to destroy the generator first, which will empty the list of parsed files along with erasing all the data retrieved from those files.
+			
+			Note 2: The generator can be fed data multiple times if you have it in separate files. Just make sure the structure names in them aren't duplicated, otherwise they will be silently ignored.
+			
+			Note 3: In the C++ version, you are not obliged to specify the random number generator. If you skip it in the function call, the generator will assume you would like to use an instance of the default generator.
+
+		@Cpp static void TCODNamegen::parse (const char * filename, TCODRandom * random = NULL)
+		@C void TCOD_namegen_parse (const char * filename, TCOD_random_t random)
+		@Py namegen_parse (filename, random = 0)
+		@C#
+			static void TCODNameGenerator::parse(string filename)
+			static void TCODNameGenerator::parse(string filename, TCODRandom random)
+		@Param filename 	The file where the desired syllable set is saved, along with its relative parh, for instance, "data/names.txt".
+		@Param random 	A random number generator object. Use NULL for the default random number generator
+		@CppEx 
+			TCODNamegen::parse("data/names.txt",TCODRandom::getInstance());
+			TCODNamegen::parse("data/names2.txt");
+		@CEx TCOD_namegen_parse("data/names.txt",TCOD_random_get_instance());
+		@PyEx libtcod.namegen_parse('data/names.txt')
+		*/
+		static void parse (const char * filename, TCODRandom * random = NULL);
+
+		/**
+		@PageName namegen_init
+		@FuncTitle Destroying a generator
+		@FuncDesc To release the resources used by a name generator, you may call:
+			This will free all memory used by the generator. In order to generate a name again, you have to parse a file again. 
+		@Cpp static void TCODNamegen::destroy (void)
+		@C void TCOD_namegen_destroy (void)
+		@Py namegen_destroy ()
+		@C# static void TCODNameGenerator::destroy()
+		*/
+		static void destroy (void);
+
+		/**
+		@PageName namegen_generate
+		@PageTitle Generating a name
+		@PageFather namegen
+		@FuncTitle Generating a default name
+		@FuncDesc The following will output a random name generated using one of the generation rules specified in the syllable set:
+			Should you choose to allocate memory for the output, you need to remember to deallocate it once you don't need the name anymore using the free() function. This applies to C++ as well (delete won't work - you have to use free()).
+			
+			On the other hand, should you choose not to allocate memory, be aware that subsequent calls will overwrite the previously returned pointer, so make sure to copy the output using strcpy(), strdup() or other means of your choosing.
+			
+			The name you specify needs to be in one of the files the generator has previously parsed (see Creating a generator). If such a name doesn't exist, a warning will be displayed and NULL will be returned.
+		@Cpp static char * TCODNamegen::generate (char * name, bool allocate = false)
+		@C char * TCOD_namegen_generate (char * name, bool allocate)
+		@Py namegen_generate (name, allocate = 0)
+		@C# string TCODNameGenerator::generate (string name)
+		@Param name 	The structure name you wish to refer to, for instance, "celtic female".
+			For more about how structure names work, please refer to <a href="namegen_file.html">those</a> <a href="parser_format.html">chapters</a>.
+		@Param allocate 	Whether memory should be allocated for the output or not.
+		@CppEx 
+			TCODNamegen::parse("data/names.txt",TCODRandom::getInstance());
+			char * myName = TCODNamegen::generate("fantasy female");
+		@CEx 
+			TCOD_namegen_parse("data/names.txt",TCOD_random_get_instance());
+			char * my_name = TCOD_namegen_generate("Celtic male",false);
+		@PyEx 
+			libtcod.namegen_parse('data/names.txt')
+			name = libtcod.namegen_generate('Nordic female')
+		*/
+		static char * generate (char * name, bool allocate = false);
+
+		/**
+		@PageName namegen_generate
+		@FuncTitle Generating a custom name
+		@FuncDesc It is also possible to generate a name using custom generation rules. This overrides the random choice of a generation rule from the syllable set. Please refer to chapter 16.5 to learn about the name generation rules syntax.
+		@Cpp static char * TCODNamegen::generateCustom (char * name, char * rule, bool allocate = false)
+		@C char * TCOD_namegen_generate_custom (char * name, char * rule, bool allocate)
+		@Py namegen_generate_custom (name, rule, allocate = 0)
+		@C# string TCODNameGenerator::generateCustom (string name, string rule)
+		@Param name 	The structure name you wish to refer to, for instance, "celtic female".
+			For more about how structure names work, please refer to <a href="namegen_file.html">those</a> <a href="parser_format.html">chapters</a>.
+		@Param rule 	The name generation rule. See <a href="namegen_file.html">this chapter</a> for more details.
+		@Param allocate 	Whether memory should be allocated for the output or not.
+		@CppEx 
+			TCODNamegen::parse("data/names.txt",TCODRandom::getInstance());
+			char * myName = TCODNamegen::generateCustom("Nordic male","$s$e");
+		@CEx 
+			TCOD_namegen_parse("data/names.txt",TCOD_random_get_instance());
+			char * my_name = TCOD_namegen_generate_custom("Mesopotamian female","$s$e",false);
+		@PyEx 
+			libtcod.namegen_parse('data/names.txt')
+			name = libtcod.namegen_generate_custom('Nordic female','$s$e')
+		*/
+		static char * generateCustom (char * name, char * rule, bool allocate = false);
+
+		/**
+		@PageName namegen_generate
+		@FuncTitle Retrieving available set names
+		@FuncDesc If you wish to check the sylable set names that are currently available, you may call:
+		This will create a list with all the available syllable set names. Remember to delete that list after you don't need it anymore!
+		@Cpp static TCODList TCODNamegen::getSets ()
+		@C TCOD_list_t TCOD_namegen_get_sets ()
+		@Py namegen_get_sets ()
+		@C# static IEnumerable<string> TCODNameGenerator::getSets()
+		*/
+		static TCOD_list_t getSets (void);
+
+		/**
+		@PageName namegen_file
+		@PageFather namegen
+		@PageTitle Syllable set configuration
+		@PageDesc Configuring the syllable set is vital to obtaining high quality randomly generated names. Please refer to the following subchapters for detailed information:
+		*/
+
+		/**
+		@PageName namegen_file_1
+		@PageFather namegen_file
+		@PageTitle  Syllable set basic structure
+		@PageDesc The syllable sets need to be written in one or more text files that will be opened and parsed by the generator.
+
+The data uses a standard TCODParser file and data should be inserted according to the general rules of creating a configuration file. For more information, please refer to <a href="parser_format.html">The libtcod config file format</a>.
+
+The structure type that's defined in the generator is "name". This structure type must also be accompanied by a structure name. It will be used for identification purposes in the generator. For instance, if you use a structure name "fantasy female", you will be able to access this syllable set by creating a generator using "fantasy female" syllables. In the initialisation function, this is the "const char * name" argument.
+
+The structure contains different members, all of which must be of TCOD_TYPE_STRING type. The tokens inside the strings, be them phonemes or syllables, form a single string, but are separated with separator characters. Characters used for token separation are all characters that are not Latin upper- or lowercase characters, dashes or apostrophes. A comma, a space or a comma+space are all perfectly valid, human-readable separators. In order to use a character inside a string that would normally be considered a separator, precede it with a slash (eg. "/:", "/.", "/!", etc.). An exception to this rule is the space character, which can also be achieved by using an underscore (eg. "the_Great").
+
+The structure members that may thus be defined are:
+<div class="code"><p>phonemesVocals
+phonemesConsonants
+syllablesPre
+syllablesStart
+syllablesMiddle
+syllablesEnd
+syllablesPost
+</p></div>
+
+All of those strings are considered optional. However, if you don't define a string, but reference it in the name generation rules, you will see a warning displayed on stderr about missing data.
+		*/
+
+		/**
+		@PageName namegen_file_2
+		@PageFather namegen_file
+		@PageTitle  Illegal strings
+		@PageDesc Another optional property is
+<div class="code"><p>illegal</p></div>
+
+This property contains strings that are considered illegal and thus not desired in your names. Should a generated name contain any of the tokens specified in this string, it will be discarded and replaced by a new one. Illegal strings may be as short as single characters or as long as entire names. However, it is best to create a syllable set that generates very few names that sound bad. Otherwise, the illegal list might become very long.
+
+Be aware that the generator will automatically correct or reject certain words, so you don't need to place every undesired possibility in this string.
+
+The generator will correct the following:
+
+    * leading spaces ("_NAME")
+    * ending spaces ("NAME_")
+    * double spaces ("NAME1__NAME2")
+
+It will generate a new name in the following cases:
+
+    * triple characters ("Raaagnar")
+    * two-character adjacent repetitions ("Bobofur" is wrong, but "Bombofur" is OK)
+    * three-character (or more) repetitions, whether adjacent or not ("Bombombur", "Dagbjoerdag", "Gwaerdygwaern")
+
+Remember that all of this is case-insensitive, so you don't need to care about uppercase/lowercase distinction in your illegal strings.
+		*/
+
+		/**
+		@PageName namegen_file_3
+		@PageFather namegen_file
+		@PageTitle Rules
+		@PageDesc There's one last string that's contained within the structure:
+<div class="code"><p>rules</p></div>
+
+It is mandatory, so not defining it will trigger an error. It defines how the generator should join the supplied data in order to generate a name. This string uses a syntax of its own, which is also used when specifying a rule when generating a custom name (see chapter 16.2).
+
+The rules are parsed pretty much the same way as all other strings, so all rules regarding separators and special characters apply as well. However, you can additionally use a set of wildcards and frequency markers. Each wildcard is preceded by the dollar sign ('$'), while frequency markers are preceded by the per cent sign ('%'). Here's the complete wildcard list:
+<table class="param">
+<tbody><tr><th>Wildcard</th><th>Example</th><th>Description</th></tr>
+<tr class="hilite"><td>$[INT]P</td><td>$P, $25P</td><td>Use a random Pre syllable.<br>The optional integer value denotes the per cent chance of adding the syllable.</td></tr>
+<tr><td>$[INT]s</td><td>$s, $25s</td><td>Use a random Start syllable.</td></tr>
+<tr class="hilite"><td>$[INT]m</td><td>$m, $25m</td><td>Use a random Middle syllable.</td></tr>
+
+<tr><td>$[INT]e</td><td>$e, $25e</td><td>Use a random End syllable.</td></tr>
+<tr class="hilite"><td>$[INT]p</td><td>$p, $25p</td><td>Use a random Post syllable.</td></tr>
+<tr><td>$[INT]v</td><td>$v, $25v</td><td>Use a random vocal.</td></tr>
+<tr class="hilite"><td>$[INT]c</td><td>$c, $25c</td><td>Use a random consonant.</td></tr>
+<tr><td>$[INT]?</td><td>$?, $25?</td><td>Use a random phoneme (vocal or consonant).</td></tr>
+
+<tr class="hilite"><td>%INT</td><td>%50, %25</td><td>Frequency marker. Denotes the per cent chance for the rule to be accepted if it's picked.<br>If the rule is not accepted, another roll is made to choose a name generation rule.<br>It's used to reduce the frequency a given rule is chosen with.<br>This marker may only appear at the beginning of a rule.</td></tr>
+</tbody></table>
+		*/
+
+		/**
+		@PageName namegen_file_4
+		@PageFather namegen_file
+		@PageTitle Example structure
+		@PageDesc Consider this example structure. It does not contain syllables, but rather full names.
+<div class="code"><p>name "king" {
+  syllablesStart = "Alexander, Augustus, Casimir, Henry, John, Louis, Sigismund,"
+    "Stanislao, Stephen, Wenceslaus"
+  syllablesMiddle = "I, II, III, IV, V"
+  syllablesEnd = "Bathory, Herman, Jogaila, Lambert, of_Bohemia, of_France,"
+    "of_Hungary, of_Masovia, of_Poland, of_Valois, of_Varna, Probus,"
+    "Spindleshanks, Tanglefoot, the_Bearded, the_Black, the_Bold, the_Brave,"
+    "the_Chaste, the_Curly, the_Elbow-high, the_Exile, the_Great,"
+    "the_Jagiellonian, the_Just, the_Old, the_Pious, the_Restorer, the_Saxon,"
+    "the_Strong, the_Wheelwright, the_White, Vasa, Wrymouth"
+  rules = "%50$s, $s_$m, $s_$50m_$e"
+}</p></div>
+
+The above structure only uses three syllable lists and has three different rules. Let's analyse them one by one.
+
+%50$s - this will simply output a random Start syllable, but this rule is not intended to be picked with the same frequency as the others, so the frequency marker at the beginning ("%50") ensures that 50% of the time this syllable will be rejected and a different one will be picked.
+
+$s_$m - this will output a Start syllable and a Middle syllable, separated with a space.
+
+$s_$50m_$e - This will output a Start syllable, followed by a Middle syllable, followed by an End sylable, all separated with spaces. However, the Middle syllable has only 50% chance of appearing at all, so 50% of the time the rule will actually produce a Start syllable followed directly by an End syllable, separated with a space.
+
+As you may have noticed, the third rule may produce a double space if the Middle syllable is not chosen. You do not have to worry about such cases, as the generator will automatically reduce all double spaces to single spaces, and leading/ending spaces will be removed completely.
+
+Output from this example set would contain kings' names based on the names of real monarchs of Poland. Have a look at the sample:
+<div class="code"><p>Alexander IV
+Alexander
+Sigismund
+Stanislao V
+Stanislao
+Henry I of Poland
+Augustus V
+Stanislao I the Pious
+Sigismund IV the Brave
+John the Great
+Henry the Old
+John the Bold
+Stanislao II the Saxon
+Wenceslaus of France
+John Probus
+Louis V
+Wenceslaus Lambert
+Stanislao Spindleshanks
+Henry Herman
+Alexander the Old
+Louis V the Curly
+Wenceslaus II
+Augustus IV
+Alexander V
+Augustus Probus
+</p></div>
+		*/
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/noise.hpp
@@ -0,0 +1,323 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_PERLIN_HPP
+#define _TCOD_PERLIN_HPP
+
+#include "noise_defaults.h"
+
+/**
+ @PageName noise
+ @PageCategory Base toolkits
+ @PageTitle Noise generator
+ @PageDesc This toolkit provides several functions to generate Perlin noise and other derived noises. It can handle noise functions from 1 to 4 dimensions.
+ @FuncDesc
+	Usage example:
+	1D noise : the variation of a torch intensity
+	2D fbm : heightfield generation or clouds
+	3D fbm : animated smoke
+	If you don't know what is Perlin noise and derived functions, or what is the influence of the different fractal parameters, check the Perlin noise sample included with the library.
+	<table width="800px" class="none">
+		<tr><td align="center">Simplex noise, fbm, turbulence</td>
+		<td align="center"><img border="1" src="simplex.png"></td>
+		<td align="center"><img border="1" src="fbm_simplex.png"></td>
+		<td align="center"><img border="1" src="turbulence_simplex.png"></td></tr>
+		<tr><td align="center">Perlin noise, fbm, turbulence</td>
+		<td align="center"><img border="1" src="perlin.png"></td>
+		<td align="center"><img border="1" src="fbm_perlin.png"></td>
+		<td align="center"><img border="1" src="turbulence_perlin.png"></td></tr>
+		<tr><td align="center">Wavelet noise, fbm, turbulence</td>
+		<td align="center"><img border="1" src="wavelet.png"></td>
+		<td align="center"><img border="1" src="fbm_wavelet.png"></td>
+		<td align="center"><img border="1" src="turbulence_wavelet.png"></td></tr>
+	</table>
+	<h6>Noise functions relative times</h6>
+
+	For example, in 4D, Perlin noise is 17 times slower than simplex noise.
+	<table border="1">
+		<tr><td></td><td>1D</td><td>2D</td><td>3D</td><td>4D</td></tr>
+		<tr><td>simplex</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
+		<tr><td>Perlin</td><td>1.3</td><td>4</td><td>5</td><td>17</td></tr>
+		<tr><td>wavelet</td><td>53</td><td>32</td><td>14</td><td>X</td></tr>
+	</table>
+ */
+class TCODLIB_API TCODNoise {
+	public :
+		/**
+		@PageName noise_init
+		@PageFather noise
+		@PageTitle Creating a noise generator
+		@FuncDesc Those functions initialize a noise generator from a number of dimensions (from 1 to 4), some fractal parameters and a random number generator.
+			The C++ version provides several constructors. When the hurst and lacunarity parameters are omitted, default values (TCOD_NOISE_DEFAULT_HURST = 0.5f and TCOD_NOISE_DEFAULT_LACUNARITY = 2.0f) are used.
+		@Cpp
+			TCODNoise::TCODNoise(int dimensions, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+			TCODNoise::TCODNoise(int dimensions, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+		@C TCOD_noise_t TCOD_noise_new(int dimensions, float hurst, float lacunarity, TCOD_random_t random)
+		@Py noise_new(dimensions, hurst=TCOD_NOISE_DEFAULT_HURST, lacunarity=TCOD_NOISE_DEFAULT_LACUNARITY, random=0)
+		@C#
+			TCODNoise::TCODNoise(int dimensions)
+			TCODNoise::TCODNoise(int dimensions, TCODRandom random)
+			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity)
+			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity, TCODRandom random)
+		@Param dimensions	From 1 to 4.
+		@Param hurst	For fractional brownian motion and turbulence, the fractal Hurst exponent. You can use the default value TCOD_NOISE_DEFAULT_HURST = 0.5f.
+		@Param lacunarity	For fractional brownian motion and turbulence, the fractal lacunarity. You can use the default value TCOD_NOISE_DEFAULT_LACUNARITY = 2.0f.
+		@Param random	A random number generator obtained with the Mersenne twister toolkit or NULL to use the default random number generator.
+		@CppEx
+			// 1 dimension generator
+			TCODNoise * noise1d = new TCODNoise(1);
+			// 2D noise with a predefined random number generator
+			TCODRandom *myRandom = new TCODRandom();
+			TCODNoise *noise2d = new TCODNoise(2,myRandom);
+			// a 3D noise generator with a specific fractal parameters
+			TCODNoise *noise3d = new TCODNoise(3,0.7f,1.4f);
+		@CEx
+			// 1 dimension generator
+			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			// 2D noise with a predefined random number generator
+			TCOD_random_t my_random = TCOD_random_new();
+			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,my_random);
+			// a 3D noise generator with a specific fractal parameters
+			TCOD_noise_t noise3d = TCOD_noise_new(3,0.7f, 1.4f,NULL);
+		@PyEx
+			# 1 dimension generator
+			noise1d = libtcod.noise_new(1)
+			# 2D noise with a predefined random number generator
+			my_random = libtcod.random_new();
+			noise2d = libtcod.noise_new(2,libtcod.NOISE_DEFAULT_HURST, libtcod.NOISE_DEFAULT_LACUNARITY,my_random)
+			# a 3D noise generator with a specific fractal parameters
+			noise3d = libtcod.noise_new(3, 0.7, 1.4)
+		*/
+		TCODNoise(int dimensions, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+		TCODNoise(int dimensions, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+		TCODNoise(int dimensions, float hurst, float lacunarity, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+		TCODNoise(int dimensions, float hurst, float lacunarity, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+
+		/**
+		@PageName noise_init
+		@FuncDesc To release ressources used by a generator, use those functions :
+		@Cpp TCODNoise::~TCODNoise()
+		@C void TCOD_noise_delete(TCOD_noise_t noise)
+		@Py noise_delete(noise)
+		@C# void TCODNoise::Dispose()
+		@Param noise	In the C and python versions, the generator handler, returned by the initialization function.
+		@CppEx
+			// create a generator
+			TCODNoise *noise = new TCODNoise(2);
+			// use it
+			...
+			// destroy it
+			delete noise;
+		@CEx
+			// create a generator
+			TCOD_noise_t noise = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAUT_LACUNARITY, NULL);
+			// use it
+			...
+			// destroy it
+			TCOD_noise_delete(noise);
+		@PyEx
+			# create a generator
+			noise = libtcod.noise_new(2,litbcod.NOISE_DEFAULT_HURST, litbcod.NOISE_DEFAUT_LACUNARITY, 0)
+			# use it
+			...
+			# destroy it
+			litbcod.noise_delete(noise)
+		*/
+		virtual ~TCODNoise();
+
+   		/**
+   		@PageName noise_setType
+		@PageFather noise
+		@PageTitle Choosing a noise type
+		@FuncTitle Choosing a noise type
+		@FuncDesc Use this function to define the default algorithm used by the noise functions. 
+			The default algorithm is simplex. It's much faster than Perlin, especially in 4 dimensions. It has a better contrast too.
+		@Cpp void TCODNoise::setType(TCOD_noise_type_t type)
+		@C void TCOD_noise_set_type(TCOD_noise_t noise, TCOD_noise_type_t type)
+		@Py noise_set_type(noise, type)
+		@C# void TCODNoise::setType(type)
+		@Param noise	In the C version, the generator handler, returned by the initialization function.
+		@Param type		The algorithm to use, either TCOD_NOISE_SIMPLEX, TCOD_NOISE_PERLIN or TCOD_NOISE_WAVELET.
+		@CppEx
+			TCODNoise * noise1d = new TCODNoise(1);
+			noise1d->setType(TCOD_NOISE_PERLIN);
+		@CEx
+			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			TCOD_noise_set_type(noise1d,TCOD_NOISE_PERLIN);
+		@PyEx
+			noise1d = libtcod.noise_new(1)
+			libtcod.noise_set_type(noise1d,libtcod.NOISE_PERLIN)
+   		*/
+		void setType (TCOD_noise_type_t type);
+   		/**
+   		@PageName noise_get
+		@PageFather noise
+		@PageTitle Getting flat noise
+		@FuncDesc This function returns the noise function value between -1.0 and 1.0 at given coordinates.
+		@Cpp float TCODNoise::get(float *f, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+		@C	float TCOD_noise_get(TCOD_noise_t noise, float *f)
+float TCOD_noise_get_ex(TCOD_noise_t noise, float *f, TCOD_noise_type_t type)
+		@Py noise_get(noise, f, type=NOISE_DEFAULT)
+		@C# float TCODNoise::get(float[] f, type=NoiseDefault)
+		@Param noise	In the C version, the generator handler, returned by the initialization function.
+		@Param f	An array of coordinates, depending on the generator dimensions (between 1 and 4). The same array of coordinates will always return the same value.
+		@Param type	The algorithm to use. If not defined, use the default one (set with setType or simplex if not set) 
+		@CppEx
+			// 1d noise
+			TCODNoise * noise1d = new TCODNoise(1);
+			float p=0.5f;
+			// get a 1d simplex value
+			float value = noise1d->get(&p);
+			// 2d noise
+			TCODNoise * noise2d = new TCODNoise(2);
+			float p[2]={0.5f,0.7f};
+			// get a 2D Perlin value
+			float value = noise2d->get(p, TCOD_NOISE_PERLIN);
+		@CEx
+			// 1d noise
+			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			float p=0.5f;
+			// get a 1d simplex value
+			float value = TCOD_noise_get(noise1d,&p);
+			// 2d noise
+			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			float p[2]={0.5f,0.7f};
+			// get a 2d perlin value
+			float value = TCOD_noise_get_ex(noise2d,p,TCOD_NOISE_PERLIN);
+		@PyEx
+			# 1d noise
+			noise1d = libtcod.noise_new(1)
+			# get a 1d simplex value
+			value = libtcod.noise_get(noise1d,[0.5])
+			# 2d noise
+			noise2d = libtcod.noise_new(2)
+			# get a 2d perlin value
+			value = libtcod.noise_get(noise2d,[0.5,0.7], libtcod.NOISE_PERLIN)
+   		*/
+		float get(float *f, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+		/**
+		@PageName noise_get_fbm
+		@PageFather noise
+		@PageTitle Getting fbm noise
+		@FuncDesc This function returns the fbm function value between -1.0 and 1.0 at given coordinates, using fractal hurst and lacunarity defined when the generator has been created.
+		@Cpp float TCODNoise::getFbm(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+		@C	float TCOD_noise_get_fbm(TCOD_noise_t noise, float *f, float octaves)
+float TCOD_noise_get_fbm(TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t type)
+		@Py noise_get_fbm(noise, f, octaves, type=NOISE_DEFAULT)
+		@C# float TCODNoise::getBrownianMotion(float[] f, float octaves, type=NoiseDefault)
+		@Param noise	In the C version, the generator handler, returned by the initialization function.
+		@Param f	An array of coordinates, depending on the generator dimensions (between 1 and 4). The same array of coordinates will always return the same value.
+		@Param octaves	Number of iterations. Must be < TCOD_NOISE_MAX_OCTAVES = 128
+		@Param type	The algorithm to use. If not defined, use the default one (set with setType or simplex if not set) 
+		@CppEx
+			// 1d fbm
+			TCODNoise * noise1d = new TCODNoise(1);
+			float p=0.5f;
+			// get a 1d simplex fbm
+			float value = noise1d->getFbm(&p,32.0f);
+			// 2d fbm
+			TCODNoise * noise2d = new TCODNoise(2);
+			float p[2]={0.5f,0.7f};
+			// get a 2d perlin fbm
+			float value = noise2d->getFbm(p,32.0f, TCOD_NOISE_PERLIN);
+		@CEx
+			// 1d fbm
+			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			float p=0.5f;
+			// get a 1d simplex fbm
+			float value = TCOD_noise_get_fbm(noise1d,&p,32.0f);
+			// 2d fbm
+			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			float p[2]={0.5f,0.7f};
+			// get a 2d perlin fbm
+			float value = TCOD_noise_get_fbm_ex(noise2d,p,32.0f,TCOD_NOISE_PERLIN);
+		@PyEx
+			# 1d noise
+			noise1d = libtcod.noise_new(1)
+			# 1d simplex fbm
+			value = libtcod.noise_get_fbm(noise1d,[0.5],32.0)
+			# 2d noise
+			noise2d = libtcod.noise_new(2)
+			# 2d perlin fbm
+			value = libtcod.noise_get_fbm(noise2d,[0.5,0.7],32.0, libtcod.NOISE_PERLIN)
+		*/
+		float getFbm(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+		/**
+		@PageName noise_get_turbulence
+		@PageFather noise
+		@PageTitle Getting turbulence
+		@FuncDesc This function returns the turbulence function value between -1.0 and 1.0 at given coordinates, using fractal hurst and lacunarity defined when the generator has been created.
+		@Cpp float TCODNoise::getTurbulence(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
+		@C	float TCOD_noise_get_turbulence(TCOD_noise_t noise, float *f, float octaves)
+float TCOD_noise_get_turbulence_ex(TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t)
+		@Py noise_get_turbulence(noise, f, octaves, type=NOISE_DEFAULT)
+		@C# float TCODNoise::getTurbulence(float[] f, float octaves, type=NoiseDefault)
+		@Param noise	In the C version, the generator handler, returned by the initialization function.
+		@Param f	An array of coordinates, depending on the generator dimensions (between 1 and 4). The same array of coordinates will always return the same value.
+		@Param octaves	Number of iterations. Must be < TCOD_NOISE_MAX_OCTAVES = 128
+		@CppEx
+			// 1d fbm
+			TCODNoise * noise1d = new TCODNoise(1);
+			float p=0.5f;
+			// a 1d simplex turbulence
+			float value = noise1d->getTurbulence(&p,32.0f);
+			// 2d fbm
+			TCODNoise * noise2d = new TCODNoise(2);
+			float p[2]={0.5f,0.7f};
+			// a 2d perlin turbulence
+			float value = noise2d->getTurbulence(p,32.0f, TCOD_NOISE_PERLIN);
+		@CEx
+			// 1d fbm
+			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			float p=0.5f;
+			// a 1d simplex turbulence
+			float value = TCOD_noise_get_turbulence(noise1d,&p,32.0f);
+			// 2d fbm
+			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
+			float p[2]={0.5f,0.7f};
+			// a 2d perlin turbulence
+			float value = TCOD_noise_get_turbulence_ex(noise2d,p,32.0f, TCOD_NOISE_PERLIN);
+		@PyEx
+			# 1d noise
+			noise1d = libtcod.noise_new(1)
+			# 1d simplex turbulence
+			value = libtcod.noise_get_turbulence(noise1d,[0.5],32.0)
+			# 2d noise
+			noise2d = libtcod.noise_new(2)
+			# 2d perlin turbulence
+			value = libtcod.noise_get_turbulence(noise2d,[0.5,0.7],32.0,libtcod.NOISE_PERLIN)
+		*/
+		float getTurbulence(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
+
+	protected :
+		friend class TCODLIB_API TCODHeightMap;
+		TCOD_noise_t data;
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/parser.hpp
@@ -0,0 +1,671 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_PARSER_HPP
+#define _TCOD_PARSER_HPP
+
+/**
+@PageName parser
+@PageTitle File parser
+@PageCategory Base toolkits
+@PageDesc This toolkit provides an easy way to parse complex text configuration files. It has two main advantages compared to a standard XML SAX parser:
+	* The configuration file format is more human readable than XML
+	* The parser knows some data types that it automatically converts to C variables (see <a href="parser_types.html">Standard data types</a>)
+*/
+
+/**
+@PageName parser_format
+@PageFather parser
+@PageTitle The libtcod config file format
+@FuncTitle Comments
+@FuncDesc Your file can contain single line or multi-line comments :
+<div class="code"><pre>// This is a single line comment
+/<span>*</span>
+   This is a
+   multi-line comment
+*<span>/</span>
+</pre></div>
+Multi-line comments can be nested :
+<div class="code"><pre>/<span>*</span>
+   This is a
+   multi-line comment containing another
+   /<span>*</span>
+&nbsp;&nbsp;&nbsp;&nbsp;multi-line
+&nbsp;&nbsp;&nbsp;&nbsp;comment
+   *<span>/</span>
+*<span>/</span>
+</pre></div>
+The parser is not sensible to space characters, tabulations or carriage return except inside strings.
+*/
+/**
+@PageName parser_format
+@FuncTitle Structures
+@FuncDesc The libtcod config file format is basically a list of structures. A structure has a type, an optional name and contains properties. The type of the structure defines which properties are allowed / mandatory.
+<div class="code"><pre>item_type "blade" {            // structure's type : 'item_type'. structure's name : 'blade'
+	cost=300                   // an integer property
+	weight=3.5                 // a float property
+	deal_damage=true           // a boolean property
+	damages="3d6+2"            // a dice property
+	col="#FF0000"              // a color property, using #RRGGBB syntax
+	damaged_color="128,96,96"  // another color property, using rrr,ggg,bbb syntax
+	damage_type="slash"        // a string property
+	description="This is a long"
+	            "description." // a multi-line string property
+	abstract                   // a flag (simplified boolean property)
+        intList= [ 1,2,3 ]         // a list of int values
+        floatList= [ 1.0,2,3.5 ]   // a list of float values
+        stringList= [ "string1","string2","string3" ]         // a list of string values
+}
+</pre></div>
+A structure can also contain other structures either of the same type, or structures of another type :
+<div class="code"><pre>item_type "blade" {
+	item_type "one-handed blades" {
+		// the item_type "blade" contains another item_type named "one-handed blades"
+	}
+	item_type "two-handed blades" {
+		// the item_type "blade" contains another item_type named "two-handed blades"
+	}
+	feature "damage" {
+		// the item_type "blade" contains another structure, type "feature", name "damage"
+	}
+}
+</pre></div>
+Sometimes, you don't know the list of properties at compile-time. Fortunately, since libtcod 1.5.1, you can add auto-declaring properties in the file, using one of the type keywords :
+<div class="code"><pre>item_type "blade" {
+	bool deal_damage=true
+	char character='D'
+	int cost=300
+	float weight=3.5
+	string damage_type="slash"
+	color col="#FF0000"
+	dice damages="3d6+2"
+	int[] intList= [ 1,2,3 ]
+	float[] floatList= [ 1.0,2,3.5 ]
+	string[] stringList= [ "string1","string2","string3" ]
+}
+</pre></div>
+The properties declared with this syntax were not previously declared for the structure item_type. But since the type is specified, the parser won't reject them. Instead, it will add the property declaration to the structure dynamically (when it parses the file).
+You can also dynamically create new structures and sub-structures with the struct keyword :
+<div class="code"><pre>item_type "blade" {
+    struct component {
+	    string name="blade"
+		float weight=1.0
+	}
+}
+</div>
+With this syntax, you don't need to declare the "component" structure at all in the parser. It will be dynamically registered as the file is parsed.
+*/
+
+class TCODLIB_API TCODParser;
+class TCODLIB_API TCODParserStruct;
+class TCODLIB_API ITCODParserListener;
+
+class TCODLIB_API TCODParser {
+public :
+	/**
+	@PageName parser_str
+	@PageTitle Defining the file syntax
+	@PageFather parser
+	@FuncTitle Creating a parser
+	@FuncDesc Use this function to create a generic parser. Then you'll specialize this parser by defining the structures it can read.
+	@Cpp TCODParser::TCODParser()
+	@C TCOD_parser_t TCOD_parser_new()
+	@Py parser_new()
+	*/
+	TCODParser();
+
+	/**
+	@PageName parser_str
+	@FuncTitle Registering a new structure type
+	@Cpp TCODParserStruct *TCODParser::newStructure(const char *name)
+	@C TCOD_parser_struct_t TCOD_parser_new_struct(TCOD_parser_t parser, char *name)
+	@Py parser_new_struct(parser, name)
+	@Param parser	In the C version, the parser handler, returned by TCOD_parser_new.
+	@Param name	The name of the structure type (in the example, this would be "item_type").
+	@CppEx
+		TCODParser parser();
+		TCODParserStruct *itemTypeStruct = parser.newStructrue("item_type");
+	@CEx
+		TCOD_parser_t parser = TCOD_parser_new();
+		TCOD_parser_struct_t item_type_struct = TCOD_parser_new_struct(parser, "item_type");
+	@PyEx
+		parser=libtcod.parser_new()
+		item_type_struct = libtcod.parser_new_struct(parser, "item_type")
+	*/
+	TCODParserStruct *newStructure(const char *name);
+
+	// register a new custom type
+	TCOD_value_type_t newCustomType(TCOD_parser_custom_t custom_type_parser);
+
+	/**
+	@PageName parser_run
+	@PageFather parser
+	@PageTitle Running the parser
+	@FuncTitle Running the parser
+	@FuncDesc Once you defined all the structure types and created your listener, you can start the actual parsing of the file :
+	@Cpp void TCODParser::run(const char *filename, ITCODParserListener *listener = NULL)
+	@C void TCOD_parser_run(TCOD_parser_t parser, const char *filename, TCOD_parser_listener_t *listener)
+	@Py parser_run(parser, filename, listener=0)
+	@Param parser	In the C version, the parser handler, returned by TCOD_parser_new.
+	@Param filename	The name of the text file to parse, absolute or relative to current directory.
+	@Param listener	The listener containing the callbacks. Use NULL for the default listener
+	@Cpp myParser.run("config.txt",new MyListener());
+	@C TCOD_parser_run(my_parser,"config.txt", my_listener);
+	@Py libtcod.parser_run(my_parser,"config.txt", MyListener())
+	*/
+	void run(const char *filename, ITCODParserListener *listener = NULL);
+
+	/**
+	@PageName parser_run
+	@FuncTitle Destroying the parser
+	@FuncDesc Once you've done with the file parsing, you can release the resources used by the parser :
+	@Cpp TCODParser::~TCODParser()
+	@C void TCOD_parser_delete(TCOD_parser_t parser)
+	@Py parser_delete(parser)
+	@Param parser	In the C version, the parser handler, returned by TCOD_parser_new.
+	*/
+
+	// error during parsing. can be called by the parser listener
+	void error(const char *msg, ...);
+#ifdef TCOD_VISUAL_STUDIO
+    // silly stuff to avoid VS warning
+	#pragma warning(disable: 4251)
+#endif
+	TCODList<TCODParserStruct *> defs;
+#ifdef TCOD_VISUAL_STUDIO
+	// restore warning again
+	#pragma warning(default: 4251)
+#endif
+
+	bool getBoolProperty(const char *name) const;
+	int getIntProperty(const char *name) const;
+	int getCharProperty(const char *name) const;
+	float getFloatProperty(const char *name) const;
+	TCODColor getColorProperty(const char *name) const;
+	TCOD_dice_t getDiceProperty(const char *name) const;
+	const char * getStringProperty(const char *name) const;
+	void * getCustomProperty(const char *name) const;
+	TCOD_list_t getListProperty(const char *name, TCOD_value_type_t type) const;
+private :
+	bool parseEntity(TCODParserStruct *def, ITCODParserListener *listener);
+	TCOD_parser_t data;
+};
+
+// a parser structure
+class TCODLIB_API TCODParserStruct {
+public :
+	/**
+	@PageName parser_str
+	@FuncTitle Adding a new flag
+	@FuncDesc Use this function to add a flag property to a structure type. A flag is a simplified boolean property. It cannot be mandatory: either it's present and it's true, or it's absent and it's false.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
+	@Cpp TCODParserStruct* TCODParserStruct::addFlag(const char *name)
+	@C void TCOD_struct_add_flag(TCOD_parser_struct_t str,char *name)
+	@Py struct_add_flag(str,name)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param name	The name of the flag (in the example, this would be "abstract").
+	@CppEx itemTypeStruct->addFlag("abstract")->addFlag("static");
+	@CEx TCOD_struct_add_flag(item_type_struct, "abstract");
+	@PyEx libtcod.struct_add_flag(item_type_struct, "abstract")
+	*/
+	TCODParserStruct* addFlag(const char *propname);
+
+	/**
+	@PageName parser_str
+	@FuncTitle Adding a new property
+	@FuncDesc Use this function to add a standard property to a structure type. Check standard property types here.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
+	@Cpp TCODParserStruct* TCODParserStruct::addProperty(const char *name, TCOD_value_type_t type, bool mandatory)
+	@C void TCOD_struct_add_property(TCOD_parser_struct_t str, char *name, TCOD_value_type_t type, bool mandatory)
+	@Py struct_add_property(str, name, type, mandatory)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param name	The name of the property (in the example, this would be "cost" or "damage" or ...).
+	@Param type	The type of the property. It can be a standard type (see <a href="parser_types.html">this</a>).
+	@Param mandatory	Is this property mandatory? If true and the property is not defined in the file, the parser will raise an error.
+	@CppEx
+		itemTypeStruct->addProperty("cost",TCOD_TYPE_INT,true)
+		    ->addProperty("weight",TCOD_TYPE_FLOAT,true)
+		    ->addProperty("deal_damage",TCOD_TYPE_BOOL,true)
+		    ->addProperty("damaged_color",TCOD_TYPE_COLOR,true);
+	@CEx
+		TCOD_struct_add_property(item_type_struct, "cost", TCOD_TYPE_INT, true);
+		TCOD_struct_add_property(item_type_struct, "damages", TCOD_TYPE_DICE, true);
+		TCOD_struct_add_property(item_type_struct, "color", TCOD_TYPE_COLOR, true);
+		TCOD_struct_add_property(item_type_struct, "damaged_color", TCOD_TYPE_COLOR, true);
+	@PyEx
+		libtcod.struct_add_property(item_type_struct, "cost", libtcod.TYPE_INT, True)
+		libtcod.struct_add_property(item_type_struct, "damages", libtcod.TYPE_DICE, True)
+		libtcod.struct_add_property(item_type_struct, "color", libtcod.TYPE_COLOR, True)
+		libtcod.struct_add_property(item_type_struct, "damaged_color", libtcod.TYPE_COLOR, True)
+	*/
+	TCODParserStruct* addProperty(const char *propname, TCOD_value_type_t type, bool mandatory);
+
+	/**
+	@PageName parser_str
+	@FuncTitle Adding a new value-list property
+	@FuncDesc A value-list property is a string property for which we define the list of allowed values. The parser will raise an error if the file contains an unauthorized value for this property.
+		The first value-list property that you add to a structure type will have the TCOD_TYPE_VALUELIST00 type. The next TCOD_TYPE_VALUELIST01. You can define up to 16 value list property for each structure type. The last one has the type TCOD_TYPE_VALUELIST15.
+		You must provide a value list as a NULL terminated array of strings.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
+	@Cpp TCODParserStruct* TCODParserStruct::addValueList(const char *name, const char **value_list, bool mandatory)
+	@C void TCOD_struct_add_value_list(TCOD_parser_struct_t str, char *name, char **value_list, bool mandatory)
+	@Py struct_add_value_list(str, name, value_list, mandatory)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param name	The name of the property (in the example, this would be "damage_type").
+	@Param value_list	The list of allowed strings.
+	@Param mandatory	Is this property mandatory ? If true and the property is not defined in the file, the parser will raise an error.
+	@CppEx
+		static const char *damageTypes[] = { "slash", "pierce", "bludgeon", NULL }; // note the ending NULL
+		itemTypeStruct->addValueList("damage_type", damageTypes, true);
+	@CEx
+		static const char *damage_types[] = { "slash", "pierce", "bludgeon", NULL };
+		TCOD_struct_add_value_list(item_type_struct, "damage_type", damage_types, true);
+	@PyEx
+		damage_types = [ "slash", "pierce", "bludgeon" ]
+		litbcod.struct_add_value_list(item_type_struct, "damage_type", damage_types, True)
+	*/
+	TCODParserStruct* addValueList(const char *propname, const char **value_list, bool mandatory);
+
+	/**
+	@PageName parser_str
+	@FuncTitle Adding a new list property
+	@FuncDesc Use this function to add a list property to a structure type.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
+	@Cpp TCODParserStruct* TCODParserStruct::addListProperty(const char *name, TCOD_value_type_t type, bool mandatory)
+	@C void TCOD_struct_add_list_property(TCOD_parser_struct_t str, char *name, TCOD_value_type_t type, bool mandatory)
+	@Py struct_add_list_property(str, name, type, mandatory)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param name	The name of the property (in the example, this would be "cost" or "damages" or ...).
+	@Param type	The type of the list elements. It must be a standard type (see <a href="parser_types.html">this</a>). It cannot be TCOD_TYPE_LIST.
+	@Param mandatory	Is this property mandatory ? If true and the property is not defined in the file, the parser will raise an error.
+	@CppEx
+		itemTypeStruct->addListProperty("intList",TCOD_TYPE_INT,true)
+		    ->addListProperty("floatList",TCOD_TYPE_FLOAT,true)
+		    ->addListProperty("stringList",TCOD_TYPE_STRING,true);
+	@CEx
+		TCOD_struct_add_list_property(item_type_struct, "intList", TCOD_TYPE_INT, true);
+		TCOD_struct_add_list_property(item_type_struct, "floatList", TCOD_TYPE_FLOAT, true);
+		TCOD_struct_add_list_property(item_type_struct, "stringList", TCOD_TYPE_STRING, true);
+	@PyEx
+		libtcod.struct_add_list_property(item_type_struct, "intList", libtcod.TYPE_INT, True)
+		libtcod.struct_add_list_property(item_type_struct, "floatList", libtcod.TYPE_FLOAT, True)
+		libtcod.struct_add_list_property(item_type_struct, "stringList", libtcod.TYPE_STRING, True)
+	*/
+	TCODParserStruct* addListProperty(const char *propname, TCOD_value_type_t type, bool mandatory);
+
+	/**
+	@PageName parser_str
+	@FuncTitle Adding a sub-structure
+	@FuncDesc A structure can contain others structures. You can tell the parser which structures are allowed inside one structure type with this function.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
+	@Cpp TCODParserStruct* TCODParserStruct::addStructure(TCODParserStruct *sub_structure)
+	@C void TCOD_struct_add_structure(TCOD_parser_struct_t str, TCOD_parser_struct_t sub_structure)
+	@Py struct_add_structure(str, sub_structure)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param sub_structure	The structure type that can be embedded.
+	@CppEx
+		// The item_type structure can contain itself
+		itemTypeStruct->addStructure(itemTypeStruct);
+	@CEx TCOD_struct_add_value_list(item_type_struct, item_type_struct);
+	@PyEx libtcod.struct_add_value_list(item_type_struct, item_type_struct)
+	*/
+	TCODParserStruct* addStructure(TCODParserStruct *sub_entity);
+
+	/**
+	@PageName parser_str
+	@FuncTitle Getting a structure type's name
+	@FuncDesc You can retrieve the name of the structure type with these functions. Warning ! Do not confuse the structure type's name with the structure's name :
+		<div class="code"><p>item_type "sword" { ... }</p></div>
+		Here, the structure type's name is "item_type", the structure name is "sword". Obviously, the structure name cannot be retrieved from the TCODParserStruct object because it's only known at "runtime" (while parsing the file).
+	@Cpp const char *TCODParserStruct::getName() const
+	@C const char *TCOD_struct_get_name(TCOD_parser_struct_t str)
+	@Py struct_get_name(str)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@CppEx const char *structName = itemTypeStruct->getName(); // returns "item_type"
+	@CEx const char *struct_name = TCOD_struct_get_name(item_type_struct);
+	@PyEx struct_name = libtcod.struct_get_name(item_type_struct)
+	*/
+	const char *getName() const;
+
+	/**
+	@PageName parser_str
+	@FuncTitle Checking if a property is mandatory
+	@FuncDesc You can know if a property is mandatory :
+	@Cpp bool TCODParserStruct::isPropertyMandatory(const char *name) const
+	@C bool TCOD_struct_is_mandatory(TCOD_parser_struct_t str,const char *name)
+	@Py struct_is_mandatory(str,name)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param name	The name of the property, as defined when you called addProperty or addValueList or addListProperty.
+	@CppEx bool costMandatory = itemTypeStruct->isPropertyMandatory("cost");
+	@CEx bool cost_mandatory = TCOD_struct_is_mandatory(item_type_struct, "cost");
+	@PyEx cost_mandatory = libtcod.struct_is_mandatory(item_type_struct, "cost")
+	*/
+	bool isPropertyMandatory(const char *propname) const;
+
+	/**
+	@PageName parser_str
+	@FuncTitle Retrieving the type of a property
+	@FuncDesc You get the type of a property :
+		In the case of a list property, the value returned is a bitwise or of TCOD_TYPE_LIST and the list element's type. For example, for a list of int, it will return TCOD_TYPE_LIST | TCOD_TYPE_INT.
+	@Cpp TCOD_value_type_t TCODParserStruct::getPropertyType(const char *name) const
+	@C TCOD_value_type_t TCOD_struct_get_type(TCOD_parser_struct_t str, const char *name)
+	@Py struct_get_type(str, name)
+	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
+	@Param name	The name of the property, as defined when you called addProperty or addValueList or addListProperty.
+	@CppEx
+		TCOD_value_type_t costType = itemTypeStruct->getPropertyType("cost"); // returns TCOD_TYPE_INT
+		TCOD_value_type_t intListType = itemTypeStruct->getPropertyType("intList"); // returns TCOD_TYPE_LIST|TCOD_TYPE_INT
+	@CEx TCOD_value_type_t cost_type = TCOD_struct_get_type(item_type_struct, "cost");
+	@PyEx cost_type = libtcod.struct_get_type(item_type_struct, "cost")
+	*/
+	TCOD_value_type_t getPropertyType(const char *propname) const;
+
+// private stuff
+	TCOD_parser_struct_t data;
+};
+
+/**
+ @PageName parser_run
+ @FuncTitle Creating a listener
+ @FuncDesc For basic config files, you don't have to write a listener. Instead, use the default listener. The parser uses a SAX-like approach during the parsing of the file. This means that the whole file is not stored in memory in a tree structure. Instead, it works like a stream parser and raises events. Each event has an associated callback that is provided by a listener :
+ @Cpp
+	class ITCODParserListener {
+	public :
+		virtual bool parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)=0;
+		virtual bool parserFlag(TCODParser *parser,const char *name)=0;
+		virtual bool parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)=0;
+		virtual bool parserEndStruct(TCODParser *parser,const TCODParserStruct *str, const char *name)=0;
+		virtual void error(const char *msg) = 0;
+	};
+ @C
+	typedef struct {
+		bool (*new_struct)(TCOD_parser_struct_t str,const char *name);
+		bool (*new_flag)(const char *name);
+		bool (*new_property)(const char *name, TCOD_value_type_t type, TCOD_value_t value);
+		bool (*end_struct)(TCOD_parser_struct_t str, const char *name);
+		void (*error)(const char *msg);
+	} TCOD_parser_listener_t;
+ @Py
+	class ParserListener :
+		def new_struct(str,name) : ...
+		def new_flag(name) : ...
+		def new_property(name,type,value) : ...
+		def end_struct(self, struct, name) : ...
+		def error(msg) : ...
+*/
+/**
+ @PageName parser_run
+ @FuncDesc Before running the parser, you have to build a listener :
+ @Cpp
+	class MyListener : public ITCODParserListener {
+		bool parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name) {
+			printf ("new structure type '%s' with name '%s'\n",str->getname(),name ? name : "NULL");
+			return true;
+		}
+		bool parserFlag(TCODParser *parser,const char *name) {
+			printf ("found new flag '%s'\n",name);
+			return true;
+		}
+		bool parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value) {
+			printf ("found new property '%s'\n",name);
+			return true;
+		}
+		bool parserEndStruct(TCODParser *parser,const TCODParserStruct *str,const char *name) {
+			printf ("end of structure type '%s'\n",name);
+			return true;
+		}
+		void error(char *msg) {
+			fprintf(stderr,msg);
+			exit(1);
+		}
+	};
+ @C
+	bool my_parser_new_struct(TCOD_parser_struct_t str, const char *name) {
+		printf ("new structure type '%s' with name '%s'\n",TCOD_struct_get_name(str),name ? name : "NULL");
+		return true;
+	}
+	bool my_parser_flag(const char *name) {
+		printf ("found new flag '%s'\n",name);
+		return true;
+	}
+	bool my_parser_property(const char *name, TCOD_value_type_t type, TCOD_value_t value) {
+		printf ("found new property '%s'\n",name);
+		return true;
+	}
+	bool my_parser_end_struct(TCOD_parser_struct_t str, const char *name) {
+		printf ("end of structure type '%s'\n",name);
+		return true;
+	}
+	void my_parser_error(const char *msg) {
+		fprintf(stderr,msg);
+		exit(1);
+	}
+	TCOD_parser_listener_t my_listener = {
+		my_parser_new_struct,
+		my_parser_flag,
+		my_parser_property,
+		my_parser_end_struct,
+		my_parser_error
+	};
+ @Py
+    class MyListener:
+        def new_struct(self, struct, name):
+            print 'new structure type', libtcod.struct_get_name(struct),
+                  ' named ', name
+            return True
+        def new_flag(self, name):
+            print 'new flag named ', name
+            return True
+        def new_property(self,name, typ, value):
+            type_names = ['NONE', 'BOOL', 'CHAR', 'INT', 'FLOAT', 'STRING',
+                          'COLOR', 'DICE']
+            if typ == libtcod.TYPE_COLOR :
+                print 'new property named ', name,' type ',type_names[typ],
+                      ' value ', value.r, value.g, value.b
+            elif typ == libtcod.TYPE_DICE :
+                print 'new property named ', name,' type ',type_names[typ],
+                      ' value ', value.nb_rolls, value.nb_faces,
+                      value.multiplier, value.addsub
+            else:
+                print 'new property named ', name,' type ',type_names[typ],
+                      ' value ', value
+            return True
+        def end_struct(self, struct, name):
+            print 'end structure type', libtcod.struct_get_name(struct),
+                  ' named ', name
+            return True
+        def error(self,msg):
+            print 'error : ', msg
+            return True
+ */
+
+// sax event listener
+class TCODLIB_API ITCODParserListener {
+public :
+	virtual ~ITCODParserListener(){}
+	/**
+	@PageName parser_run
+	@FuncTitle Handling 'newStruct' events
+	@FuncDesc This callback is called each time the parser find a new structure declaration in the file. Example :
+<div class="code"><pre>item_type "blade" { // <= newStruct event here
+	...
+}
+</pre></div>
+It must return true if everything is right, false if there is an error and the parser must exit.
+	@Cpp bool ITCODParserListener::parserNewStruct(TCODParser *parser,TCODParserStruct *str,const char *name)
+	@C bool new_struct(TCOD_parser_struct_t str,const char *name)
+	@Py new_struct(str,name)
+	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
+	@Param str	The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type".
+	@Param name	The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade".
+	*/
+	virtual bool parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)=0;
+
+	/**
+	@PageName parser_run
+	@FuncTitle Handling 'newFlag' events
+	@FuncDesc This callback is called each time the parser find a new flag in the file. Example :
+<div class="code"><pre>item_type "blade" {
+	abstract  // <= newFlag event here
+}
+</pre></div>
+It must return true if everything is right, false if there is an error and the parser must exit.
+	@Cpp bool ITCODParserListener::parserFlag(TCODParser *parser,const char *name)
+	@C bool new_flag(const char *name)
+	@Py new_flag(name)
+	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
+	@Param name	The name of the flag. In the example, this would be "abstract".
+	*/
+	virtual bool parserFlag(TCODParser *parser,const char *name)=0;
+
+	/**
+	@PageName parser_run
+	@FuncTitle Handling 'newProperty' events
+	@FuncDesc This callback is called each time the parser find a new property in the file. Example :
+<div class="code"><pre>item_type "blade" {
+	abstract
+	cost=300 // <= newProperty event here
+}
+</pre></div>
+It must return true if everything is right, false if there is an error and the parser must exit.
+	@Cpp bool ITCODParserListener::parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)
+	@C bool new_property(const char *name, TCOD_value_type_t type, TCOD_value_t value)
+	@Py new_property(name,type,value)
+	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
+	@Param name	The name of the property. In the example, this would be "cost".
+	@Param type	The type of the property as defined when you called addProperty or addValueList. In the example, this would be TCOD_TYPE_INT.
+	@Param value	The value of the property, stored in a generic value structure. In the example, we would have value.i == 300.
+In the case of a value-list property, the type would reflect the list id (between TCOD_TYPE_VALUELIST00 and TCOD_TYPE_VALUELIST15) and value.s would contain the actual string.
+	*/
+	virtual bool parserProperty(TCODParser *parser,const char *propname, TCOD_value_type_t type, TCOD_value_t value)=0;
+
+	/**
+	@PageName parser_run
+	@FuncTitle Handling 'endStruct' events
+	@FuncDesc This callback is called each time the parser find the end of a structure declaration in the file. Example :
+<div class="code"><pre>item_type "blade" {
+	...
+} // <= endStruct event here
+</pre></div>
+It must return true if everything is right, false if there is an error and the parser must exit.
+	@Cpp bool ITCODParserListener::parserEndStruct(TCODParser *parser,TCODParserStruct *str,const char *name)
+	@C bool end_struct(TCOD_parser_struct_t str,const char *name)
+	@Py end_struct(str,name)
+	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
+	@Param str	The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type".
+	@Param name	The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade".
+	*/
+	virtual bool parserEndStruct(TCODParser *parser,const TCODParserStruct *str, const char *name)=0;
+
+	/**
+	@PageName parser_run
+	@FuncTitle Handling errors
+	@FuncDesc There are two kind of errors :
+    * Errors that are detected by the parser itself (malformed file, bad value syntax for a property, missing mandatory property in a structure, ...).
+    * Errors that you detect in your callbacks.
+	When the parser finds an error in the file, it will call the error callback and stop :
+	@Cpp void ITCODParserListener::error(const char *msg)
+	@C void error(const char *msg)
+	@Py error(msg)
+	@Param msg	The error message from the parser with the file name and the line number.
+	*/
+
+	/**
+	@PageName parser_run
+	@FuncDesc If you find an error in your callback, you have to call the parser error function. It will add the file name and line number to your error message, and then call your error callback :
+The code in the example below will result in your error callback called with the following string :
+"error in &lt;filename&gt; line &lt;line_number&gt; : Bad cost value %d. Cost must be between 0 and 1000"
+	@Cpp void TCODParser::error(const char *msg, ...)
+	@C void TCOD_parser_error(const char *msg, ...)
+	@Py parser_error(msg)
+	@Param msg	printf-like format string for your error message.
+	@CppEx parser->error("Bad cost value %d. Cost must be between 0 and 1000", value.i);
+	@CEx TCOD_parser_error("Bad cost value %d. Cost must be between 0 and 1000", value.i);
+	@PyEx libtcod.parser_error("Bad cost value %d. Cost must be between 0 and 1000"%( value ))
+	*/
+	virtual void error(const char *msg) = 0;
+};
+
+/**
+ @PageName parser_types
+ @PageFather parser
+ @PageTitle Standard types
+ @FuncDesc The parser can parse natively several data types. It stores them in a generic union :
+ @C
+	typedef struct {
+		int nb_rolls;
+		int nb_faces;
+		float multiplier;
+		float addsub;
+	} TCOD_dice_t;
+
+	typedef union {
+		bool b;
+		char c;
+		int32 i;
+		float f;
+		char *s;
+		TCOD_color_t col;
+		TCOD_dice_t dice;
+		TCOD_list_t list;
+		void *custom;
+	} TCOD_value_t;
+*/
+/**
+ @PageName parser_types
+ @FuncDesc Possible types are defined by the TCOD_value_type_t enumeration :
+For python, remove TCOD_ : libtcod.TYPE_BOOL
+<table class="param">
+<tbody><tr><th>TCOD_value_type_t</th><th>Value in file</th><th>TCOD_value_t</th></tr>
+
+<tr><td>TCOD_TYPE_BOOL</td><td>true<br>false</td><td>value.b == true/false</td></tr>
+<tr><td>TCOD_TYPE_CHAR</td><td>decimal notation : 0 .. 255<br>
+hexadecimal notation : 0x00 .. 0xff <br>
+char notation : 'a' ';' ...<br>
+Special characters :<br>
+'\n' : carriage return (ascii 13)<br>
+'\t' : tabulation (ascii 9)<br>
+
+'\r' : line feed (ascii 10)<br>
+'\\' : antislash (ascii 92)<br>
+'\"' : double-quote (ascii 34)<br>
+'\'' : simple quote (ascii 39)<br>
+'\xHH' : hexadecimal value, same as 0xHH, HH between 0 and FF<br>
+'\NNN' : octal value, NNN between 0 and 377<br>
+</td><td>value.c == The corresponding ascii code</td></tr>
+<tr><td>TCOD_TYPE_INT</td><td>decimal notation : -2147483648 .. 2147483647<br>hexadecimal notation : 0x0 .. 0xFFFFFFFF</td><td>value.i == the integer value</td></tr>
+
+<tr><td>TCOD_TYPE_FLOAT</td><td>Any format parsable by atof. Examples:<br>3.14159<br>1.25E-3</td><td>value.f == the float value</td></tr>
+<tr><td>TCOD_TYPE_STRING</td><td>A double-quote delimited string :<br>"This is a string"<br>Support the same special characters as TCOD_TYPE_CHAR.</td><td>value.s == the corresponding string.<br>Warning ! If you want to store this string, you have to duplicate it (with strdup) as it will be overwritten by the parser</td></tr>
+<tr><td>TCOD_TYPE_COLOR</td><td>decimal notation : "16,32,64"<br>hexadecimal notation : "#102040"</td><td>value.col == the color.</td></tr>
+
+<tr><td>TCOD_TYPE_DICE</td><td>[multiplier (x|*)] nb_rolls (d|D) nb_faces [(+|-) addsub] :<br>"3d6"<br>"3D6+2"<br>"0.5x3d6-2"<br>"2*3d8"</td><td>value.dice == the dice components</td></tr>
+<tr><td>TCOD_TYPE_VALUELISTxx</td><td>Same as TCOD_TYPE_STRING</td><td>value.s == the string value from the value list</td></tr>
+<tr><td>TCOD_TYPE_LIST</td><td>[ &lt;value1&gt;,&lt;value2&gt;,... ]</td><td>value.list == the TCOD_list_t containing the elements</td></tr>
+
+</tbody></table>
+
+To define a list type, use the appropriate function (TCODParserStruct::addListProperty / TCOD_parser_add_list_property) and specify the type of the elements in the list. Lists of list are not supported.
+ */
+
+
+#endif
--- /dev/null
+++ b/include/libtcod/path.hpp
@@ -0,0 +1,552 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_PATH_HPP
+#define _TCOD_PATH_HPP
+
+class TCODLIB_API ITCODPathCallback {
+public :
+	virtual ~ITCODPathCallback() {}
+	virtual float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void *userData ) const = 0;
+};
+
+/**
+ @PageName path
+ @PageTitle Path finding
+ @PageCategory Roguelike toolkits
+ @PageDesc This toolkit allows to easily calculate the optimal path between two points in your dungeon by using either the <a href="http://en.wikipedia.org/wiki/A*">A* algorithm</a> or <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a>.
+Please note that the paths generated with the two algorithms may differ slightly. Due to how they're implemented, A* will usually prefer diagonal moves over orthogonal, while Dijkstra will have the opposite preference. In other words, paths from point X to point Y will look like this:
+<div class="code"><pre>
+Dijkstra:      A*:
+..........   ..........
+.X........   .X*.......
+..*.......   ...**.....
+...*......   .....**...
+....****Y.   .......*Y.
+..........   ..........
+</pre></div>
+ */
+class TCODLIB_API TCODPath {
+public :
+	/**
+	@PageName path_init
+	@PageFather path
+	@PageTitle Creating a path
+	@FuncTitle Allocating a pathfinder from a map
+	@FuncDesc First, you have to allocate a path using a map from <a href="fov.html">the Field of view module</a>.
+	@Cpp
+		TCODPath::TCODPath(const TCODMap *map, float diagonalCost=1.41f)
+		TCODDijkstra::TCODDijkstra(const TCODMap *map, float diagonalCost=1.41f)
+	@C 
+		TCOD_path_t TCOD_path_new_using_map(TCOD_map_t map, float diagonalCost)
+		TCOD_dijkstra_t TCOD_dijkstra_new(TCOD_map_t map, float diagonalCost)
+	@Py 
+		path_new_using_map(map, diagonalCost=1.41)
+		dijkstra_new(map, diagonalCost=1.41)
+	@C#
+		TCODPath(TCODMap map, float diagonalCost)
+		TCODPath(TCODMap map)
+		TCODDijkstra(TCODMap map, float diagonalCost)
+		TCODDijkstra(TCODMap map)
+	@Param map	The map. The path finder will use the 'walkable' property of the cells to find a path.
+	@Param diagonalCost	Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f).
+		It you want the same cost for all movements, use 1.0f.
+		If you don't want the path finder to use diagonal movements, use 0.0f.
+	@CppEx 
+		// A* :
+		TCODMap *myMap = new TCODMap(50,50);
+		TCODPath *path = new TCODPath(myMap); // allocate the path
+		// Dijkstra:
+		TCODMap *myMap = new TCODMap(50,50);
+		TCODDijkstra *dijkstra = new TCODDijkstra(myMap); // allocate the path
+	@CEx 
+		// A* :
+		TCOD_map_t my_map=TCOD_map_new(50,50,true);
+		TCOD_path_t path = TCOD_path_new_using_map(my_map,1.41f);
+		// Dijkstra :
+		TCOD_map_t my_map=TCOD_map_new(50,50,true);
+		TCOD_dijkstra_t dijk = TCOD_dijkstra_new(my_map,1.41f);
+	@PyEx 
+		# A* :
+		my_map=libtcod.map_new(50,50,True)
+		path = libtcod.path_new_using_map(my_map)
+		# Dijkstra
+		my_map=libtcod.map_new(50,50,True)
+		dijk = libtcod.dijkstra_new(my_map) 	
+	*/	
+	TCODPath(const TCODMap *map, float diagonalCost=1.41f);
+	/**
+	@PageName path_init
+	@FuncTitle Allocating a pathfinder using a callback
+	@FuncDesc Since the walkable status of a cell may depend on a lot of parameters (the creature type, the weather, the terrain type...), you can also create a path by providing a function rather than relying on a TCODMap.
+	@Cpp 
+		// Callback :
+		class ITCODPathCallback {
+			public: virtual float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void *userData ) const = 0;
+		};
+		// A* constructor:
+		TCODPath::TCODPath(int width, int height, const ITCODPathCallback *callback, void *userData, float diagonalCost=1.41f)
+		// Dijkstra constructor
+		TCODDijkstra::TCODDijkstra(int width, int height, const ITCODPathCallback *callback, void *userData, float diagonalCost=1.41f)
+	@C 
+		typedef float (*TCOD_path_func_t)( int xFrom, int yFrom, int xTo, int yTo, void *user_data )
+		TCOD_path_t TCOD_path_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost)
+		TCOD_dijkstra_t TCOD_dijkstra_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost)
+	@Py 
+		def path_func(xFrom,yFrom,xTo,yTo,userData) : ...
+		path_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41)
+		dijkstra_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41)
+	@C#
+		TCODPath(int width, int height, ITCODPathCallback listener, float diagonalCost)
+		TCODPath(int width, int height, ITCODPathCallback listener)
+		TCODDijkstra(int width, int height, ITCODPathCallback listener, float diagonalCost)
+		TCODDijkstra(int width, int height, ITCODPathCallback listener)
+	@Param width,height	The size of the map (in map cells).
+	@Param callback	A custom function that must return the walk cost from coordinates xFrom,yFrom to coordinates xTo,yTo.
+		The cost must be > 0.0f if the cell xTo,yTo is walkable.
+		It must be equal to 0.0f if it's not.
+		You must not take additional cost due to diagonal movements into account as it's already done by the pathfinder.
+	@Param userData	Custom data that will be passed to the function.
+	@Param diagonalCost	Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f).
+		It you want the same cost for all movements, use 1.0f.
+		If you don't want the path finder to use diagonal movements, use 0.0f.
+	@CppEx 
+		class MyCallback : public ITCODPathCallback {
+		public :
+			float getWalkCost(int xFrom, int yFrom, int xTo, int yTo, void *userData ) const { ... }
+		};
+		TCODPath *path = new TCODPath(50,50,new MyCallback(),NULL); // allocate the path
+		TCODDijkstra *dijkstra = new TCODDijkstra(50,50,new MyCallback(),NULL); // allocate Dijkstra
+	@CEx 
+		float my_func(int xFrom, int yFrom, int xTo, int yTo, void *user_data) { ... }
+		TCOD_path_t path = TCOD_path_new_using_function(50,50,my_func,NULL,1.41f);
+		TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new_using_function(50,50,my_func,NULL,1.41f);
+	@PyEx 
+		def my_func(xFrom, yFrom, xTo, yTo, user_data) :
+			# return a float cost for this movement
+			return 1.0
+		path = libtcod.path_new_using_function(50,50,my_func)
+		dijkstra = libtcod.dijkstra_new_using_function(50,50,my_func)
+	*/	
+	TCODPath(int width, int height, const ITCODPathCallback *listener, void *userData, float diagonalCost=1.41f);
+	
+	/**
+	@PageName path_init
+	@FuncTitle Destroying a path
+	@FuncDesc To release the resources used by a path, destroy it with :
+	@Cpp 
+		TCODPath::~TCODPath()
+		TCODDijkstra::~TCODDijkstra()
+	@C 
+		void TCOD_path_delete(TCOD_path_t path)
+		void TCOD_dijkstra_delete(TCOD_dijkstra_t dijkstra)
+	@Py 
+		path_delete(path)
+		dijkstra_delete(dijkstra)
+	@C#
+		void TCODPath::Dispose()
+		void TCODDijkstra::Dispose()
+	@Param path	In the C version, the path handler returned by one of the TCOD_path_new_* function.
+	@Param dijkstra	In the C version, the path handler returned by one of the TCOD_dijkstra_new* function.
+	@CppEx 
+		TCODPath *path = new TCODPath(myMap); // allocate the path
+		// use the path...
+		delete path; // destroy the path
+		
+		TCODDijkstra *dijkstra = new TCODDijkstra(myMap); // allocate the path
+		// use the path...
+		delete dijkstra; // destroy the path
+	@CEx 
+		TCOD_path_t path = TCOD_path_new_using_map(my_map);
+		// use the path ... 
+		TCOD_path_delete(path);
+		
+		TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map);
+		// use the path ... 
+		TCOD_dijkstra_delete(dijkstra);
+	@PyEx 
+		path = libtcod.path_new_using_map(my_map)
+		# use the path ... 
+		libtcod.path_delete(path)
+		
+		dijkstra = libtcod.dijkstra_new(my_map)
+		# use the path ... 
+		libtcod.dijkstra_delete(dijkstra)	
+	*/	
+	virtual ~TCODPath();
+
+	/**
+	@PageName path_compute
+	@PageFather path
+	@PageTitle Computing the path
+	@FuncTitle Computing an A* path
+	@FuncDesc Once you created a TCODPath object, you can compute the path between two points:
+	@Cpp bool TCODPath::compute(int ox, int oy, int dx, int dy)     
+	@C bool TCOD_path_compute(TCOD_path_t path, int ox,int oy, int dx, int dy)
+	@Py path_compute(path, ox, oy, dx, dy)
+	@C#	void TCODPath::compute(int ox, int oy, int dx, int dy)
+	@Param path	In the C version, the path handler returned by a creation function.
+	@Param ox,oy	Coordinates of the origin of the path.
+	@Param dx,dy	Coordinates of the destination of the path.
+		Both points should be inside the map, and at a walkable position. The function returns false if there is no possible path.
+	@CppEx 
+		TCODMap *myMap = new TCODMap(50,50);
+		TCODPath *path = new TCODPath(myMap); // allocate the path
+		path->compute(5,5,25,25); // calculate path from 5,5 to 25,25
+	@CEx 
+		TCOD_map_t my_map=TCOD_map_new(50,50);
+		TCOD_path_t path = TCOD_path_new_using_map(my_map);
+		TCOD_path_compute(path,5,5,25,25);
+	@PyEx 
+		my_map=libtcod.map_new(50,50)
+		path = libtcod.path_new_using_map(my_map)
+		libtcod.path_compute(path,5,5,25,25)	
+	*/	
+	bool compute(int ox, int oy, int dx, int dy);
+
+	/**
+	@PageName path_compute
+	@FuncTitle Reversing a path
+	@FuncDesc Once you computed a path, you can exchange origin and destination :
+	@Cpp 
+		void TCODPath::reverse()     
+		void TCODDijkstra::reverse()
+	@C 
+		void TCOD_path_reverse(TCOD_path_t path)
+		void TCOD_dijkstra_reverse(TCOD_dijkstra_t dijkstra)
+	@Py 
+		path_reverse(path)
+		dijkstra_reverse(dijkstra)
+	@C#	
+		void TCODPath::reverse()
+		void TCODDijkstra::reverse()
+	@Param path	In the C version, the path handler returned by a creation function.
+	@CppEx 
+		TCODMap *myMap = new TCODMap(50,50);
+		TCODPath *path = new TCODPath(myMap); // allocate the path
+		path->compute(5,5,25,25); // calculate path from 5,5 to 25,25
+		path->reverse(); // now the path goes from 25,25 to 5,5
+	@CEx 
+		TCOD_map_t my_map=TCOD_map_new(50,50);
+		TCOD_path_t path = TCOD_path_new_using_map(my_map);
+		TCOD_path_compute(path,5,5,25,25); // calculate path from 5,5 to 25,25
+		TCOD_path_reverse(path); // now the path goes from 25,25 to 5,5
+	@PyEx 
+		my_map=libtcod.map_new(50,50)
+		path = libtcod.path_new_using_map(my_map)
+		libtcod.path_compute(path,5,5,25,25) # calculate path from 5,5 to 25,25
+		libtcod.path_reverse(path) # now the path goes from 25,25 to 5,5
+	*/
+	void reverse();
+	
+
+	/**
+	@PageName path_read
+	@PageTitle Reading path information
+	@PageFather path
+	@PageDescDesc Once the path has been computed, you can get information about it using of one those functions.
+	@FuncTitle Getting the path origin and destination
+	@FuncDesc 	
+		You can read the current origin and destination cells with getOrigin/getDestination.
+		Note that when you walk the path, the origin changes at each step.
+	@Cpp 
+		void TCODPath::getOrigin(int *x,int *y) const
+		void TCODPath::getDestination(int *x,int *y) const
+	@C 
+		void TCOD_path_get_origin(TCOD_path_t path, int *x, int *y)
+		void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y)
+	@Py 
+		path_get_origin(path) # returns x,y
+		path_get_destination(path) # returns x,y
+	@C#
+		void TCODPath::getOrigin(out int x, out int y)
+		void TCODPath::getDestination(out int x, out int y)
+	@Param path	In the C version, the path handler returned by a creation function.
+	@Param x,y	The function returns the cell coordinates in these variables
+	*/	
+	void getOrigin(int *x,int *y) const;
+	void getDestination(int *x,int *y) const;
+
+	/**
+	@PageName path_read
+	@FuncTitle Getting the path length
+	@FuncDesc You can get the number of steps needed to reach destination :
+	@Cpp 
+		int TCODPath::size() const
+		int TCODDijkstra::size() const
+	@C 
+		int TCOD_path_size(TCOD_path_t path)
+		int TCOD_dijkstra_size(TCOD_dijkstra_t dijkstra)
+	@Py 
+		path_size(path)
+		dijkstra_size(dijkstra)
+	@C#
+		int TCODPath::size()
+		int TCODDijkstra::size()
+	@Param path, dijkstra	In the C version, the path handler returned by a creation function.
+	*/		
+	int size() const;
+	
+	/**
+	@PageName path_read
+	@FuncTitle Read the path cells' coordinates	
+	@FuncDesc You can get the coordinates of each point along the path :
+	@Cpp 
+		void TCODPath::get(int index, int *x, int *y) const
+		void TCODDijkstra::get(int index, int *x, int *y) const
+	@C 
+		void TCOD_path_get(TCOD_path_t path, int index, int *x, int *y)
+		void TCOD_dijkstra_get(TCOD_dijkstra_t dijkstra, int index, int *x, int *y)
+	@Py 
+		path_get(path, index) # returns x,y
+		dijkstra_get(dijkstra, index) # returns x,y
+	@C#
+		int TCODPath::size()
+		int TCODDijkstra::size()
+	@Param path, dijkstra	In the C version, the path handler returned by a creation function.
+	@Param index	Step number.
+		0 <= index < path size
+	@Param x,y	Address of the variables receiving the coordinates of the point.
+	@CppEx 
+		for (int i=0; i < path->size(); i++ ) {
+			int x,y;
+			path->get(i,&x,&y);
+			printf ("Astar coord : %d %d\n", x,y );
+		}
+		for (int i=0; i < dijkstra->size(); i++ ) {
+			int x,y;
+			dijkstra->get(i,&x,&y);
+			printf ("Dijkstra coord : %d %d\n", x,y );
+		}
+	@CEx 
+		int i;
+		for (i=0; i < TCOD_path_size(path); i++ ) {
+			int x,y;
+			TCOD_path_get(path,i,&x,&y);
+			printf ("Astar coord : %d %d\n", x,y );
+		}
+		for (i=0; i < TCOD_dijkstra_size(dijkstra); i++ ) {
+			int x,y;
+			TCOD_dijkstra_get(dijkstra,i,&x,&y);
+			printf ("Dijsktra coord : %d %d\n", x,y );
+		}
+	@PyEx 
+		for i in range (libtcod.path_size(path)) :
+			x,y=libtcod.path_get(path,i)
+			print 'Astar coord : ',x,y
+		for i in range (libtcod.dijkstra_size(dijkstra)) :
+			x,y=libtcod.dijkstra_get(dijkstra,i)
+			print 'Dijkstra coord : ',x,y
+	*/	
+	void get(int index, int *x, int *y) const;
+
+	/**
+	@PageName path_read
+	@FuncTitle Checking if the path is empty
+	@FuncDesc If you want a creature to follow the path, a more convenient way is to walk the path :
+		You know when you reached destination when the path is empty :
+	@Cpp 
+		bool TCODPath::isEmpty() const
+		bool TCODDijkstra::isEmpty() const
+	@C 
+		bool TCOD_path_is_empty(TCOD_path_t path)
+		bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t dijkstra)
+	@Py 
+		path_is_empty(path)
+		dijkstra_is_empty(dijkstra)
+	@C#
+		bool TCODPath::isEmpty()
+		bool TCODDijkstra::isEmpty()
+	@Param path, dijkstra	In the C version, the path handler returned by a creation function.	
+	*/
+	bool isEmpty() const;
+
+	/**
+	@PageName path_read
+	@FuncTitle Walking the path
+	@FuncDesc You can walk the path and go to the next step with :
+		Note that walking the path consume one step (and decrease the path size by one). The function returns false if recalculateWhenNeeded is false and the next cell on the path is no longer walkable, or if recalculateWhenNeeded is true, the next cell on the path is no longer walkable and no other path has been found. Also note that recalculateWhenNeeded only applies to A*.
+	@Cpp 
+		bool TCODPath::walk(int *x, int *y, bool recalculateWhenNeeded)
+		bool TCODDijkstra::walk(int *x, int *y)
+	@C 
+		bool TCOD_path_walk(TCOD_path_t path, int *x, int *y, bool recalculate_when_needed)
+		bool TCOD_dijkstra_walk(TCOD_dijkstra_t dijkstra, int *x, int *y)
+	@Py 
+		path_walk(TCOD_path_t path, recalculate_when_needed) # returns x,y or None,None if no path
+		dijkstra_walk(TCOD_dijkstra_t dijkstra)
+	@C#
+		bool TCODPath::walk(ref int x, ref int y, bool recalculateWhenNeeded)
+		bool TCODDijkstra::walk(ref int x, ref int y)
+	@Param path, dijkstra	In the C version, the path handler returned by a creation function.
+	@Param x,y	Address of the variables receiving the coordinates of the next point.
+	@Param recalculateWhenNeeded	If the next point is no longer walkable (another creature may be in the way), recalculate a new path and walk it.
+	@CppEx 
+		while (! path->isEmpty()) {
+			int x,y;
+			if (path->walk(&x,&y,true)) {
+				printf ("Astar coord: %d %d\n",x,y );
+			} else {
+				printf ("I'm stuck!\n" );
+				break;
+			}
+		}
+		while (! dijkstra->isEmpty()) {
+			int x,y;
+			if (dijkstra->walk(&x,&y)) {
+				printf ("Dijkstra coord: %d %d\n",x,y );
+			} else {
+				printf ("I'm stuck!\n" );
+				break;
+			}
+		}
+	@CEx 
+		while (! TCOD_path_is_empty(path)) {
+			int x,y;
+			if (TCOD_path_walk(path,&x,&y,true)) {
+				printf ("Astar coord: %d %d\n",x,y );
+			} else {
+				printf ("I'm stuck!\n" );
+				break;
+			}
+		}
+		while (! TCOD_dijkstra_is_empty(dijkstra)) {
+			int x,y;
+			if (TCOD_dijkstra_walk(dijkstra,&x,&y)) {
+				printf ("Dijkstra coord: %d %d\n",x,y );
+			} else {
+				printf ("I'm stuck!\n" );
+				break;
+			}
+		}
+	@PyEx 
+		while not libtcod.path_is_empty(path)) :
+			x,y=libtcod.path_walk(path,True)
+			if not x is None :
+				print 'Astar coord: ',x,y
+			else :
+				print "I'm stuck!"
+				break
+		while not libtcod.dijkstra_is_empty(dijkstra)) :
+			x,y=libtcod.dijkstra_walk(dijkstra,True)
+			if not x is None :
+				print 'Dijkstra coord: ',x,y
+			else :
+				print "I'm stuck!"
+				break	
+	*/	
+	bool walk(int *x, int *y, bool recalculateWhenNeeded);
+
+protected :
+	friend float TCOD_path_func(int xFrom, int yFrom, int xTo,int yTo, void *data);
+	TCOD_path_t data;
+	struct WrapperData {
+		void *userData;
+		const ITCODPathCallback *listener;
+	} cppData;
+};
+
+//Dijkstra kit
+class TCODLIB_API TCODDijkstra {
+    public:
+        TCODDijkstra (TCODMap *map, float diagonalCost=1.41f);
+        TCODDijkstra (int width, int height, const ITCODPathCallback *listener, void *userData, float diagonalCost=1.41f);
+        ~TCODDijkstra (void);
+        /**
+        @PageName path_compute
+		@FuncTitle Computing a Dijkstra grid
+		@FuncDesc In case of Dijkstra, this works in a slightly different way. In order to be able to compute a path, Dijkstra must first analyse the distances from the selected root (origin) node to all other nodes:
+		@Cpp void TCODDijkstra::compute(int rootX, int rootY)     
+		@C void TCOD_dijkstra_compute(TCOD_dijkstra_t dijkstra, int root_x, int root_y)
+		@Py dijkstra_compute(dijkstra, root_x, root_y)
+		@C# void TCODDijkstra::compute(int rootX, int rootY)
+		@Param dijkstra	In the C version, the path handler returned by a creation function.
+		@Param root_x,root_y	Coordinates of the root node (origin) of the path.
+			The coordinates should be inside the map, at a walkable position. Otherwise, the function's behaviour will be undefined.        
+        */        
+        void compute (int rootX, int rootY);
+
+        /**
+        @PageName path_compute
+		@FuncTitle Computing a path from a Dijkstra grid
+		@FuncDesc After the map is analysed and all the distances from the root node are known, an unlimited number of paths can be set, all originating at the root node, using:
+			The path setting function will return true if there's a path from the root node to the destination node. Otherwise, it will return false.
+		@Cpp bool TCODDijkstra::setPath(int toX, int toY)     
+		@C bool TCOD_dijkstra_path_set(TCOD_dijkstra_t dijkstra, int to_x, int to_y)
+		@Py dijkstra_path_set(dijkstra, to_x, to_y)
+		@C# bool TCODDijkstra::setPath(int toX, int toY)
+		@Param dijkstra	In the C version, the path handler returned by a creation function.
+		@Param to_x,to_y	Coordinates of the destination node of the path.
+		@CppEx 
+			TCODMap *myMap = new TCODMap(50,50);
+			TCODDijkstra *dijkstra = new TCODDijkstra(myMap); // allocate the path
+			dijkstra->compute(25,25); // calculate distance from 25,25 to all other nodes
+			dijkstra->setPath(5,5); // calculate a path to node 5,5
+			dijkstra->setPath(45,45); //calculate another path from the same origin
+		@CEx 
+			TCOD_map_t my_map=TCOD_map_new(50,50);
+			TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map);
+			TCOD_dijkstra_compute(dijkstra,25,25);
+			TCOD_dijkstra_path_set(dijkstra,5,5);
+			TCOD_dijkstra_path_set(dijkstra,45,45);
+		@PyEx 
+			my_map=libtcod.map_new(50,50)
+			dijkstra = libtcod.dijkstra_new(my_map)
+			libtcod.dijkstra_compute(dijkstra,25,25)
+			libtcod.dijkstra_path_set(dijkstra,5,5)
+			libtcod.dijkstra_path_set(dijkstra,45,45)        
+        */        
+        bool setPath (int toX, int toY);
+
+        /**
+        @PageName path_read
+		@FuncTitle Getting the distance from a cell to the root node
+		@FuncDesc You can get the distance of any set of coordinates from the root node:
+			Note that if the coordinates x,y are outside of the map or are a non-walkable position, the function will return -1.0f. This functionality is only available for Dijkstra's algorithm.        
+		@Cpp float TCODDijkstra::getDistance(int x, int y)
+		@C float TCOD_dijkstra_get_distance(TCOD_dijkstra_t dijkstra, int x, int y)
+		@Py dijkstra_get_distance(dijkstra, x, y)
+		@C# float TCODDijkstra::getDistance(int x, int y)
+		@Param dijkstra	In the C version, the path handler returned by a creation function.
+		@Param x,y	The coordinates whose distance from the root node are to be checked
+        */        
+        float getDistance (int x, int y);
+        bool walk (int *x, int *y);
+		bool isEmpty() const;
+		void reverse();
+		int size() const;
+		void get(int index, int *x, int *y) const;
+    private:
+        TCOD_dijkstra_t data;
+        struct WrapperData {
+            void *userData;
+            const ITCODPathCallback *listener;
+        } cppData;
+};
+
+#endif
+
--- /dev/null
+++ b/include/libtcod/sys.hpp
@@ -0,0 +1,540 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_SYS_HPP
+#define _TCOD_SYS_HPP
+
+/**
+	@PageName system
+	@PageCategory Core
+	@PageTitle System layer
+	@PageDesc This toolkit contains some system specific miscellaneous utilities. Use them is you want your code to be easily portable.
+ */
+
+class TCODLIB_API ITCODSDLRenderer {
+public :
+	virtual ~ITCODSDLRenderer() {}
+	virtual void render(void *sdlSurface) = 0;
+};
+
+class TCODLIB_API TCODSystem {
+public :
+	/**
+	@PageName system_time
+	@PageFather system
+	@PageTitle High precision time functions
+	@PageDesc These are functions specifically aimed at real time game development.
+	@FuncTitle Limit the frames per second
+	@FuncDesc The setFps function allows you to limit the number of frames per second.
+		If a frame is rendered faster than expected, the TCOD_console_flush function will wait so that the frame rate never exceed this value.
+		You can call this function during your game initialization.
+		You can dynamically change the frame rate. Just call this function once again.
+		<b>You should always limit the frame rate, except during benchmarks, else your game will use 100% of the CPU power</b>
+	@Cpp static void TCODSystem::setFps(int val)
+	@C void TCOD_sys_set_fps(int val)
+	@Py sys_set_fps(val)
+	@C# static void TCODSystem::setFps(int val)
+	@Lua tcod.system.setFps(val)
+	@Param val Maximum number of frames per second. 0 means unlimited frame rate.
+	*/
+	static void setFps(int val);
+
+	/**
+	@PageName system_time
+	@FuncTitle Get the number of frames rendered during the last second
+	@FuncDesc The value returned by this function is updated every second.
+	@Cpp static int TCODSystem::getFps()
+	@C int TCOD_sys_get_fps()
+	@Py sys_get_fps()
+	@C# static int TCODSystem::getFps()
+	@Lua tcod.system.getFps()
+	*/
+	static int getFps();
+
+	/**
+	@PageName system_time
+	@FuncTitle Get the duration of the last frame
+	@FuncDesc This function returns the length in seconds of the last rendered frame.
+		You can use this value to update every time dependent object in the world.
+	@Cpp static float TCODSystem::getLastFrameLength()
+	@C float TCOD_sys_get_last_frame_length()
+	@Py sys_get_last_frame_length()
+	@C# static float TCODSystem::getLastFrameLength()
+	@Lua tcod.system.getLastFrameLength()
+	@CppEx
+		// moving an objet at 5 console cells per second
+		float x=0,y=0; // object coordinates
+		x += 5 * TCODSystem::getLastFrameLength();
+		TCODConsole::root->putChar((int)(x),(int)(y),'X');
+	@CEx
+		float x=0,y=0;
+		x += 5 * TCOD_sys_get_last_frame_length();
+		TCOD_console_put_char(NULL,(int)(x),(int)(y),'X');
+	@PyEx
+		x=0.0
+		y=0.0
+		x += 5 * libtcod.sys_get_last_frame_length()
+		libtcod.console_put_char(0,int(x),int(y),'X')
+	@LuaEx
+		-- moving an objet at 5 console cells per second
+		x=0
+		y=0 -- object coordinates
+		x = x + 5 * tcod.system.getLastFrameLength()
+		libtcod.TCODConsole_root:putChar(x,y,'X')
+	*/
+	static float getLastFrameLength();
+
+	/**
+	@PageName system_time
+	@FuncTitle Pause the program
+	@FuncDesc Use this function to stop the program execution for a specified number of milliseconds.
+	@Cpp static void TCODSystem::sleepMilli(uint32 val)
+	@C void TCOD_sys_sleep_milli(uint32 val)
+	@Py sys_sleep_milli(val)
+	@C# static void TCODSystem::sleepMilli(uint val)
+	@Lua tcod.system.sleepMilli(val)
+	@Param val number of milliseconds before the function returns
+	*/
+	static void sleepMilli(uint32 val);
+
+	/**
+	@PageName system_time
+	@FuncTitle Get global timer in milliseconds
+	@FuncDesc This function returns the number of milliseconds since the program has started.
+	@Cpp static uint32 TCODSystem::getElapsedMilli()
+	@C uint32 TCOD_sys_elapsed_milli()
+	@Py sys_elapsed_milli()
+	@C# static uint TCODSystem::getElapsedMilli()
+	@Lua tcod.system.getElapsedMilli()
+	*/
+	static uint32 getElapsedMilli();
+
+	/**
+	@PageName system_time
+	@FuncTitle Get global timer in seconds
+	@FuncDesc This function returns the number of seconds since the program has started.
+	@Cpp static float TCODSystem::getElapsedSeconds()
+	@C float TCOD_sys_elapsed_seconds()
+	@Py sys_elapsed_seconds()
+	@C# static float TCODSystem::getElapsedSeconds()
+	@Lua tcod.system.getElapsedSeconds()
+	*/
+	static float getElapsedSeconds();
+
+	/**
+	@PageName console_blocking_input
+	@FuncTitle Waiting for any event (mouse or keyboard)
+	@FuncDesc There's a more generic function that waits for an event from the user. The eventMask shows what events we're waiting for.
+		The return value indicate what event was actually triggered. Values in key and mouse structures are updated accordingly.
+		If flush is false, the function waits only if there are no pending events, else it returns the first event in the buffer.
+	@Cpp typedef enum {
+		TCOD_EVENT_KEY_PRESS=1,
+		TCOD_EVENT_KEY_RELEASE=2,
+		TCOD_EVENT_KEY=TCOD_EVENT_KEY_PRESS|TCOD_EVENT_KEY_RELEASE,
+		TCOD_EVENT_MOUSE_MOVE=4,
+		TCOD_EVENT_MOUSE_PRESS=8,
+		TCOD_EVENT_MOUSE_RELEASE=16,
+		TCOD_EVENT_MOUSE=TCOD_EVENT_MOUSE_MOVE|TCOD_EVENT_MOUSE_PRESS|TCOD_EVENT_MOUSE_RELEASE,
+		TCOD_EVENT_ANY=TCOD_EVENT_KEY|TCOD_EVENT_MOUSE,		
+	} TCOD_event_t; 
+	static TCOD_event_t TCODSystem::waitForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush)
+	@C TCOD_event_t TCOD_sys_wait_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush)
+	@Py sys_wait_for_event(eventMask,key,mouse,flush)
+	@Param eventMask event types to wait for (other types are discarded)
+	@Param key updated in case of a key event. Can be null if eventMask contains no key event type
+	@Param mouse updated in case of a mouse event. Can be null if eventMask contains no mouse event type
+	@Param flush if true, all pending events are flushed from the buffer. Else, return the first available event
+	@CppEx
+		TCOD_key_t key;
+		TCOD_mouse_t mouse;
+		TCOD_event_t ev = TCODSystem::waitForEvent(TCOD_EVENT_ANY,&key,&mouse,true);
+		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }
+	@CEx
+		TCOD_key_t key;
+		TCOD_mouse_t mouse;
+		TCOD_event_t ev = TCOD_sys_wait_for_event(TCOD_EVENT_ANY,&key,&mouse,true);
+		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }	
+	*/
+	static TCOD_event_t waitForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush);
+
+	/**
+	@PageName console_non_blocking_input
+	@FuncTitle Checking for any event (mouse or keyboard)
+	@FuncDesc There's a more generic function that checks if an event from the user is in the buffer. The eventMask shows what events we're waiting for.
+		The return value indicate what event was actually found. Values in key and mouse structures are updated accordingly.
+	@Cpp typedef enum {
+		TCOD_EVENT_KEY_PRESS=1,
+		TCOD_EVENT_KEY_RELEASE=2,
+		TCOD_EVENT_KEY=TCOD_EVENT_KEY_PRESS|TCOD_EVENT_KEY_RELEASE,
+		TCOD_EVENT_MOUSE_MOVE=4,
+		TCOD_EVENT_MOUSE_PRESS=8,
+		TCOD_EVENT_MOUSE_RELEASE=16,
+		TCOD_EVENT_MOUSE=TCOD_EVENT_MOUSE_MOVE|TCOD_EVENT_MOUSE_PRESS|TCOD_EVENT_MOUSE_RELEASE,
+		TCOD_EVENT_ANY=TCOD_EVENT_KEY|TCOD_EVENT_MOUSE,		
+	} TCOD_event_t; 
+	static TCOD_event_t TCODSystem::checkForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse)
+	@C TCOD_event_t TCOD_sys_check_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse)
+	@Py sys_check_for_event(eventMask,key,mouse)
+	@Param eventMask event types to wait for (other types are discarded)
+	@Param key updated in case of a key event. Can be null if eventMask contains no key event type
+	@Param mouse updated in case of a mouse event. Can be null if eventMask contains no mouse event type
+	@CppEx
+		TCOD_key_t key;
+		TCOD_mouse_t mouse;
+		TCOD_event_t ev = TCODSystem::checkForEvent(TCOD_EVENT_ANY,&key,&mouse);
+		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }
+	@CEx
+		TCOD_key_t key;
+		TCOD_mouse_t mouse;
+		TCOD_event_t ev = TCOD_sys_check_for_event(TCOD_EVENT_ANY,&key,&mouse);
+		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }	
+	*/
+	static TCOD_event_t checkForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse);
+	/**
+	@PageName system_screenshots
+	@PageFather system
+	@PageTitle Easy screenshots
+	@FuncDesc This function allows you to save the current game screen in a png file, or possibly a bmp file if you provide a filename ending with .bmp.
+	@Cpp static void TCODSystem::saveScreenshot(const char *filename)
+	@C void TCOD_sys_save_screenshot(const char *filename)
+	@Py sys_save_screenshot(filename)
+	@C# static void TCODSystem::saveScreenshot(string filename);
+	@Lua tcod.system.saveScreenshot(filename)
+	@Param filename Name of the file. If NULL, a filename is automatically generated with the form "./screenshotNNN.png", NNN being the first free number (if a file named screenshot000.png already exist, screenshot001.png will be used, and so on...).
+	*/
+	static void saveScreenshot(const char *filename);
+
+	/**
+	@PageName system_filesystem
+	@PageFather system
+	@PageTitle Filesystem utilities
+	@PageDesc Those are a few function that cannot be easily implemented in a portable way in C/C++. They have no python wrapper since python provides its own builtin functions. All those functions return false if an error occured.
+	@FuncTitle Create a directory
+	@Cpp static bool TCODSystem::createDirectory(const char *path)
+	@C bool TCOD_sys_create_directory(const char *path)
+	@Param path Directory path. The immediate father directory (<path>/..) must exist and be writable.
+	*/
+	static bool createDirectory(const char *path);
+
+	/**
+	@PageName system_filesystem
+	@FuncTitle Delete an empty directory
+	@Cpp static bool TCODSystem::deleteDirectory(const char *path)
+	@C bool TCOD_sys_delete_directory(const char *path)
+	@Param path directory path. This directory must exist, be writable and empty
+	*/
+	static bool deleteDirectory(const char *path);
+
+	/**
+	@PageName system_filesystem
+	@FuncTitle Delete a file
+	@Cpp static bool TCODSystem::deleteFile(const char *path)
+	@C bool TCOD_sys_delete_file(const char *path)
+	@Param path File path. This file must exist and be writable.
+	*/
+	static bool deleteFile(const char *path);
+
+	/**
+	@PageName system_filesystem
+	@FuncTitle Check if a path is a directory
+	@Cpp static bool TCODSystem::isDirectory(const char *path)
+	@C bool TCOD_sys_is_directory(const char *path)
+	@Param path a path to check
+	*/
+	static bool isDirectory(const char *path);
+
+	/**
+	@PageName system_filesystem
+	@FuncTitle List files in a directory
+	@FuncDesc To get the list of entries in a directory (including sub-directories, except . and ..).
+		The returned list is allocated by the function and must be deleted by you. All the const char * inside must be also freed with TCODList::clearAndDelete.
+	@Cpp static TCODList TCODSystem::getDirectoryContent(const char *path, const char *pattern)
+	@C TCOD_list_t TCOD_sys_get_directory_content(const char *path)
+	@Param path a directory
+	@Param pattern If NULL or empty, returns all directory entries. Else returns only entries matching the pattern. The pattern is NOT a regular expression. It can only handle one '*' wildcard. Examples : *.png, saveGame*, font*.png
+	*/
+	static TCOD_list_t getDirectoryContent(const char *path, const char *pattern);
+
+	/**
+	@PageName system_filesystem
+	@FuncTitle Check if a given file exists
+	@FuncDesc In order to check whether a given file exists in the filesystem. Useful for detecting errors caused by missing files.
+	@Cpp static bool TCODSystem::fileExists(const char *filename, ...)
+	@C bool TCOD_sys_file_exists(const char * filename, ...)
+	@Param filename the file name, using printf-like formatting
+	@Param ... optional arguments for filename formatting
+	@CppEx
+		if (!TCODSystem::fileExists("myfile.%s","txt")) {
+		    fprintf(stderr,"no such file!");
+		}
+	@CEx
+		if (!TCOD_sys_file_exists("myfile.%s","txt")) {
+		    fprintf(stderr,"no such file!");
+		}
+	*/
+	static bool fileExists(const char * filename, ...);
+	/**
+	@PageName system_filesystem
+	@FuncTitle Read the content of a file into memory
+	@FuncDesc This is a portable function to read the content of a file from disk or from the application apk (android).
+		buf must be freed with free(buf).
+	@Cpp static bool TCODSystem::readFile(const char *filename, unsigned char **buf, uint32 *size)
+	@C bool TCOD_sys_read_file(const char *filename, unsigned char **buf, uint32 *size)
+	@Param filename the file name
+	@Param buf a buffer to be allocated and filled with the file content
+	@Param size the size of the allocated buffer.
+	@CppEx
+		unsigned char *buf;
+		uint32 size;
+		if (TCODSystem::readFile("myfile.dat",&buf,&size)) {
+		    // do something with buf
+		    free(buf);
+		}
+	@CEx
+		if (TCOD_sys_read_file("myfile.dat",&buf,&size)) {
+		    // do something with buf
+		    free(buf);
+		}
+	*/	
+	static bool readFile(const char *filename, unsigned char **buf, uint32 *size);
+	/**
+	@PageName system_filesystem
+	@FuncTitle Write the content of a memory buffer to a file
+	@FuncDesc This is a portable function to write some data to a file.
+	@Cpp static bool TCODSystem::writeFile(const char *filename, unsigned char *buf, uint32 size)
+	@C bool TCOD_sys_write_file(const char *filename, unsigned char *buf, uint32 size)
+	@Param filename the file name
+	@Param buf a buffer containing the data to write
+	@Param size the number of bytes to write.
+	@CppEx
+		TCODSystem::writeFile("myfile.dat",buf,size));
+	@CEx
+		TCOD_sys_write_file("myfile.dat",buf,size));
+	*/		
+	static bool writeFile(const char *filename, unsigned char *buf, uint32 size);
+	/**
+	@PageName system_sdlcbk
+	@PageFather system
+	@PageTitle Draw custom graphics on top of the root console
+	@PageDesc You can register a callback that will be called after the libtcod rendering phase, but before the screen buffer is swapped. This callback receives the screen SDL_Surface reference.
+		This makes it possible to use any SDL drawing functions (including openGL) on top of the libtcod console.
+	@FuncTitle Render custom graphics
+	@FuncDesc To disable the custom renderer, call the same method with a NULL parameter.
+		Note that to keep libtcod from requiring the SDL headers, the callback parameter is a void pointer. You have to include SDL headers and cast it to SDL_Surface in your code.
+	@Cpp
+		class TCODLIB_API ITCODSDLRenderer {
+		public :
+			virtual void render(void *sdlSurface) = 0;
+		};
+		static void TCODSystem::registerSDLRenderer(ITCODSDLRenderer *callback);
+	@C
+		typedef void (*SDL_renderer_t) (void *sdl_surface);
+		void TCOD_sys_register_SDL_renderer(SDL_renderer_t callback)
+	@Py
+		def renderer ( sdl_surface ) : ...
+		TCOD_sys_register_SDL_renderer( callback )
+	@Param callback The renderer to call before swapping the screen buffer. If NULL, custom rendering is disabled
+	@CppEx
+		class MyRenderer : public ITCODSDLRenderer {
+		public :
+			void render(void *sdlSurface) {
+				SDL_Surface *s = (SDL_Surface *)sdlSurface;
+				... draw something on s
+			}
+		};
+		TCODSystem::registerSDLRenderer(new MyRenderer());
+	@CEx
+		void my_renderer( void *sdl_surface ) {
+			SDL_Surface *s = (SDL_Surface *)sdl_surface;
+			... draw something on s
+		}
+		TCOD_sys_register_SDL_renderer(my_renderer);
+	@Py
+		def my_renderer(sdl_surface) :
+			... draw something on sdl_surface using pygame
+		libtcod.sys_register_SDL_renderer(my_renderer)
+	*/
+	static void registerSDLRenderer(ITCODSDLRenderer *renderer);
+
+	/**
+	@PageName system_sdlcbk
+	@FuncTitle Managing screen redraw
+	@FuncDesc libtcod is not aware of the part of the screen your SDL renderer has updated. If no change occured in the console, it won't redraw them except if you tell him to do so with this function
+	@Cpp void TCODConsole::setDirty(int x, int y, int w, int h)
+	@C void TCOD_console_set_dirty(int x, int y, int w, int h)
+	@Py TCOD_console_set_dirty(x, y, w, h)
+	@Param x,y,w,h Part of the root console you want to redraw even if nothing has changed in the console back/fore/char.
+	*/
+
+	/**
+	@PageName system_misc
+	@PageFather system
+	@PageTitle Miscellaneous utilities
+	@FuncTitle Using a custom resolution for the fullscreen mode
+	@FuncDesc This function allows you to force the use of a specific resolution in fullscreen mode.
+		The default resolution depends on the root console size and the font character size.
+	@Cpp static void TCODSystem::forceFullscreenResolution(int width, int height)
+	@C void TCOD_sys_force_fullscreen_resolution(int width, int height)
+	@Py sys_force_fullscreen_resolution(width, height)
+	@C# static void TCODSystem::forceFullscreenResolution(int width, int height);
+	@Lua tcod.system.forceFullscreenResolution(width,height)
+	@Param width,height Resolution to use when switching to fullscreen.
+		Will use the smallest available resolution so that :
+		resolution width >= width and resolution width >= root console width * font char width
+		resolution width >= height and resolution height >= root console height * font char height
+	@CppEx
+		TCODSystem::forceFullscreenResolution(800,600); // use 800x600 in fullscreen instead of 640x400
+		TCODConsole::initRoot(80,50,"",true); // 80x50 console with 8x8 char => 640x400 default resolution
+	@CEx
+		TCOD_sys_force_fullscreen_resolution(800,600);
+		TCOD_console_init_root(80,50,"",true);
+	@PyEx
+		libtcod.sys_force_fullscreen_resolution(800,600)
+		libtcod.console_init_root(80,50,"",True)
+	@LuaEx
+		tcod.system.forceFullscreenResolution(800,600) -- use 800x600 in fullscreen instead of 640x400
+		tcod.console.initRoot(80,50,"",true) -- 80x50 console with 8x8 char => 640x400 default resolution
+	*/
+	static void forceFullscreenResolution(int width, int height);
+
+	/**
+	@PageName system_misc
+	@FuncTitle Get current resolution
+	@FuncDesc You can get the current screen resolution with getCurrentResolution. You can use it for example to get the desktop resolution before initializing the root console.
+	@Cpp static void TCODSystem::getCurrentResolution(int *width, int *height)
+	@C void TCOD_sys_get_current_resolution(int *width, int *height)
+	@Py sys_get_current_resolution() # returns w,h
+	@C# static void TCODSystem::getCurrentResolution(out int w, out int h);
+	@Param width,height contains current resolution when the function returns
+	*/
+	static void getCurrentResolution(int *w, int *h);
+	/**
+	@PageName system_misc
+	@FuncTitle Get fullscreen offset
+	@FuncDesc If the fullscreen resolution does not matches the console size in pixels, black borders are added. This function returns the position in pixels of the console top left corner in the screen.
+	@Cpp static void TCODSystem::getFullscreenOffsets(int *offx, int *offy)
+	@C void TCOD_sys_get_fullscreen_offsets(int *offx, int *offy)
+	@C# static void TCODSystem::getFullscreenOffsets(out int offx, out int offy);
+	@Param offx,offy contains the position of the console on the screen when using fullscreen mode.
+	*/
+	static void getFullscreenOffsets(int *offx, int *offy);
+	/**
+	@PageName system_misc
+	@FuncTitle Get the font size
+	@FuncDesc You can get the size of the characters in the font
+	@Cpp static void TCODSystem::getCharSize(int *width, int *height)
+	@C void TCOD_sys_get_char_size(int *width, int *height)
+	@Py sys_get_char_size() # returns w,h
+	@C# static void TCODSystem::getCharSize(out int w, out int h);
+	@Param width,height contains a character size when the function returns
+	*/
+	static void getCharSize(int *w, int *h);
+
+	/**
+	@PageName system_misc
+	@FuncTitle Dynamically updating the font bitmap
+	@FuncDesc You can dynamically change the bitmap of a character in the font. All cells using this ascii code will be updated at next flush call.
+	@Cpp static void TCODSystem::updateChar(int asciiCode, int fontx, int fonty,const TCODImage *img,int x,int y)
+	@C void TCOD_sys_update_char(int asciiCode, int fontx, int fonty, TCOD_image_t img, int x, int y)
+	@Py sys_update_char(asciiCode,fontx,fonty,img,x,y)
+	@Param asciiCode ascii code corresponding to the character to update
+	@Param fontx,fonty coordinate of the character in the bitmap font (in characters, not pixels)
+	@Param img image containing the new character bitmap
+	@Param x,y position in pixels of the top-left corner of the character in the image
+	*/
+	static void updateChar(int asciiCode, int fontx, int fonty,const TCODImage *img,int x,int y);
+
+	/**
+	@PageName system_misc
+	@FuncTitle Dynamically change libtcod's internal renderer
+	@FuncDesc As of 1.5.1, libtcod contains 3 different renderers :
+		* SDL : historic libtcod renderer. Should work and be pretty fast everywhere
+		* OpenGL : requires OpenGL compatible video card. Might be much faster or much slower than SDL, depending on the drivers
+		* GLSDL : requires OpenGL 1.4 compatible video card with GL_ARB_shader_objects extension. Blazing fast if you have the proper hardware and drivers.
+		This function switches the current renderer dynamically.
+	@Cpp static void TCODSystem::setRenderer(TCOD_renderer_t renderer)
+	@C void TCOD_sys_set_renderer(TCOD_renderer_t renderer)
+	@Py sys_set_renderer(renderer)
+	@C# static void TCODSystem::setRenderer(TCODRendererType renderer);
+	@Param renderer Either TCOD_RENDERER_GLSL, TCOD_RENDERER_OPENGL or TCOD_RENDERER_SDL
+	*/
+	static void setRenderer(TCOD_renderer_t renderer);
+
+	/**
+	@PageName system_misc
+	@FuncTitle Get the current internal renderer
+	@Cpp static TCOD_renderer_t TCODSystem::getRenderer()
+	@C TCOD_renderer_t TCOD_sys_get_renderer()
+	@Py sys_get_renderer()
+	@C# static TCODRendererType TCODSystem::getRenderer();
+	*/
+	static TCOD_renderer_t getRenderer();
+
+	/**
+	@PageName system_clipboard
+	@PageTitle Clipboard integration
+	@PageDesc With these functions, you can copy data in your OS' clipboard from the game or retrieve data from the clipboard.
+	@PageFather system
+	@FuncTitle Copy data to the clipboard
+	@Cpp static void TCODSystem::setClipboard(const char *value)
+	@C void TCOD_sys_clipboard_set(const char *value)
+	@Param value Text to copy in the clipboard
+	*/
+	static void setClipboard(const char *value);
+
+	/**
+	@PageName system_clipboard
+	@FuncTitle Paste data from the clipboard
+	@Cpp static char *TCODSystem::getClipboard()
+	@C char *TCOD_sys_clipboard_get()
+	*/
+	static char *getClipboard();
+
+	// thread stuff
+	static int getNumCores();
+	static TCOD_thread_t newThread(int (*func)(void *), void *data);
+	static void deleteThread(TCOD_thread_t th);
+	static void waitThread(TCOD_thread_t th);
+	// mutex
+	static TCOD_mutex_t newMutex();
+	static void mutexIn(TCOD_mutex_t mut);
+	static void mutexOut(TCOD_mutex_t mut);
+	static void deleteMutex(TCOD_mutex_t mut);
+	// semaphore
+	static TCOD_semaphore_t newSemaphore(int initVal);
+	static void lockSemaphore(TCOD_semaphore_t sem);
+	static void unlockSemaphore(TCOD_semaphore_t sem);
+	static void deleteSemaphore( TCOD_semaphore_t sem);
+	// condition
+	static TCOD_cond_t newCondition();
+	static void signalCondition(TCOD_cond_t sem);
+	static void broadcastCondition(TCOD_cond_t sem);
+	static void waitCondition(TCOD_cond_t sem, TCOD_mutex_t mut);
+	static void deleteCondition( TCOD_cond_t sem);
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/tree.hpp
@@ -0,0 +1,51 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_TREE_HPP
+#define _TCOD_TREE_HPP
+
+class TCODLIB_API TCODTree {
+public :
+	TCODTree *next;
+	TCODTree *father;
+	TCODTree *sons;
+
+	TCODTree() : next(NULL),father(NULL),sons(NULL){}
+	void addSon(TCODTree *data) {
+		data->father=this;
+		TCODTree *lastson = sons;
+		while ( lastson && lastson->next ) lastson=lastson->next;
+		if ( lastson ) {
+			lastson->next=data;
+		} else {
+			sons=data;
+		}
+	}
+
+};
+
+#endif
--- /dev/null
+++ b/include/libtcod/txtfield.hpp
@@ -0,0 +1,48 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_TEXT_HPP_
+#define _TCOD_TEXT_HPP_
+
+#include "color.hpp"
+
+class TCODLIB_API TCODText {
+public :
+	TCODText(int x, int y, int w, int h, int max_chars);
+	~TCODText();
+	void setProperties(int cursor_char, int blink_interval, const char * prompt, int tab_size);
+	void setColors(TCODColor fore, TCODColor back, float back_transparency);
+	bool update(TCOD_key_t key);
+	void render(TCODConsole * con);
+	const char *getText();
+	void reset();
+protected :
+	TCOD_text_t data;
+};
+
+
+#endif
--- /dev/null
+++ b/include/libtcod/zip.hpp
@@ -0,0 +1,331 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_ZIP_HPP
+#define _TCOD_ZIP_HPP
+
+/**
+ @PageName zip
+ @PageCategory Base toolkits
+ @PageTitle Compression toolkit
+ @PageDesc This toolkit provides functions to save or read compressed data from a file. While the module is named Zip, it has nothing to do with the .zip format as it uses zlib compression (.gz format).
+	Note that this modules has no python wrapper. Use python built-in zip module instead.
+	
+	You can use the compression buffer in two modes:
+	* put data in the buffer, then save it to a file,
+	* load a file into the buffer, then get data from it.
+ */
+class TCODLIB_API TCODZip {
+public :
+
+	/**
+	@PageName zip_init
+	@PageFather zip
+	@PageTitle Creating a compression buffer
+	@FuncDesc This function initializes a compression buffer.
+	@Cpp TCODZip::TCODZip()
+	@C TCOD_zip_t TCOD_zip_new()	
+	*/	
+	TCODZip();
+	
+	/**
+	@PageName zip_init
+	@FuncDesc Once you don't need the buffer anymore, you can release resources. Note that the adresses returned by the getString function are no longer valid once the buffer has been destroyed.
+	@Cpp TCODZip::~TCODZip()
+	@C void TCOD_zip_delete(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@CppEx 
+		TCODZip *zip = new TCODZip();
+		zip->loadFromFile("myCompressedFile.gz");
+		char c=zip->getChar();
+		int i=zip->getInt();
+		float f= zip->getFloat();
+		const char *s=strdup(zip->getString()); // we duplicate the string to be able to use it after the buffer deletion
+		zip->getData(nbBytes, dataPtr);
+		delete zip;
+	@CEx 
+		TCOD_zip_t zip=TCOD_zip_new();
+		TCOD_zip_load_from_file(zip,"myCompressedFile.gz");
+		char c=TCOD_zip_get_char(zip);
+		int i=TCOD_zip_get_int(zip);
+		float f=TCOD_zip_get_float(zip);
+		const char *s=strdup(TCOD_zip_get_string(zip));
+		TCOD_zip_get_data(zip,nbBytes, dataPtr);
+		TCOD_zip_delete(zip);	
+	*/	
+	~TCODZip();
+
+	/**
+	@PageName zip_put
+	@PageFather zip
+	@PageTitle Using the buffer in output mode
+	@FuncTitle Putting a char in the buffer
+	@Cpp void TCODZip::putChar(char val)
+	@C void TCOD_zip_put_char(TCOD_zip_t zip, char val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	A 8 bits value to store in the buffer
+	*/	
+	void putChar(char val);
+	
+	/**
+	@PageName zip_put
+	@FuncTitle Putting an integer in the buffer
+	@Cpp void TCODZip::putInt(int val)
+	@C void TCOD_zip_put_int(TCOD_zip_t zip, int val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	An integer value to store in the buffer
+	*/	
+	void putInt(int val);
+
+	/**
+	@PageName zip_put
+	@FuncTitle Putting a floating point value in the buffer
+	@Cpp void TCODZip::putFloat(float val)
+	@C void TCOD_zip_put_float(TCOD_zip_t zip, float val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	A float value to store in the buffer
+	*/
+	void putFloat(float val);
+
+	/**
+	@PageName zip_put
+	@FuncTitle Putting a string in the buffer
+	@Cpp void TCODZip::putString(const char *val)
+	@C void TCOD_zip_put_string(TCOD_zip_t zip, const char *val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	A string to store in the buffer
+	*/
+	void putString(const char *val);
+
+   	/**
+	@PageName zip_put
+	@FuncTitle Putting a color in the buffer
+	@Cpp void TCODZip::putColor(const TCODColor *val)
+	@C void TCOD_zip_put_color(TCOD_zip_t zip, const TCOD_color_t val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	A color to store in the buffer
+	*/
+	void putColor(const TCODColor *val);
+
+	/**
+	@PageName zip_put
+	@FuncTitle Putting an image in the buffer
+	@Cpp void TCODZip::putImage(const TCODImage *val)
+	@C void TCOD_zip_put_image(TCOD_zip_t zip, const TCOD_image_t val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	An image to store in the buffer
+	*/
+	void putImage(const TCODImage *val);
+
+	/**
+	@PageName zip_put
+	@FuncTitle Putting a console in the buffer
+	@Cpp void TCODZip::putConsole(const TCODConsole *val)
+	@C void TCOD_zip_put_console(TCOD_zip_t zip, const TCOD_console_t val)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param val	A console to store in the buffer
+	*/
+	void putConsole(const TCODConsole *val);
+
+	/**
+	@PageName zip_put
+	@FuncTitle Putting some custom data in the buffer
+	@Cpp void TCODZip::putData(int nbBytes, const void *data)
+	@C void TCOD_zip_put_data(TCOD_zip_t zip, int nbBytes, const void *data)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param nbBytes	Number of bytes to store in the buffer
+	@Param val	Address of the data to store in the buffer
+	*/
+	void putData(int nbBytes, const void *data);
+
+	/**
+	@PageName zip_put
+	@FuncTitle Reading the number of (uncompressed) bytes in the buffer
+	@Cpp uint32 TCODZip::getCurrentBytes()
+	@C uint32 TCOD_zip_get_current_bytes(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	uint32 getCurrentBytes() const;
+	
+	/**
+	@PageName zip_put
+	@FuncTitle Saving the buffer on disk
+	@FuncDesc Once you have finished adding data in the buffer, you can compress it and save it in a file.
+		The function returns the number of (uncompressed) bytes saved.
+	@Cpp int TCODZip::saveToFile(const char *filename)
+	@C int TCOD_zip_save_to_file(TCOD_zip_t zip, const char *filename)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param filename	Name of the file
+	@CppEx 
+		TCODZip zip;
+		zip.putChar('A');
+		zip.putInt(1764);
+		zip.putFloat(3.14f);
+		zip.putString("A string");
+		zip.putData(nbBytes, dataPtr);
+		zip.saveToFile("myCompressedFile.gz");
+	@CEx 
+		TCOD_zip_t zip=TCOD_zip_new();
+		TCOD_zip_put_char(zip,'A');
+		TCOD_zip_put_int(zip,1764);
+		TCOD_zip_put_float(zip,3.14f);
+		TCOD_zip_put_string(zip,"A string");
+		TCOD_zip_put_data(zip,nbBytes, dataPtr);
+		TCOD_zip_save_to_file(zip,"myCompressedFile.gz");
+	*/	
+	int saveToFile(const char *filename);
+
+	/**
+	@PageName zip_load
+	@PageTitle Using the buffer in input mode
+	@PageFather zip
+	@FuncTitle Reading from a compressed file
+	@FuncDesc You can read data from a file (compressed or not) into the buffer.
+		The function returns the number of (uncompressed) bytes read or 0 if an error occured. 
+	@Cpp int TCODZip::loadFromFile(const char *filename)
+	@C int TCOD_zip_load_from_file(TCOD_zip_t zip, const char *filename)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param filename	Name of the file
+	*/	
+	int loadFromFile(const char *filename);
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading a char from the buffer
+	@Cpp char TCODZip::getChar()
+	@C char TCOD_zip_get_char(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor
+	*/	
+	char getChar();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading an integer from the buffer
+	@Cpp int TCODZip::getInt()
+	@C int TCOD_zip_get_int(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	int getInt();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading a floating point value from the buffer
+	@Cpp float TCODZip::getFloat()
+	@C float TCOD_zip_get_float(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	float getFloat();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading a string from the buffer
+	@FuncDesc The address returned is in the buffer. It is valid as long as you don't destroy the buffer.
+	@Cpp const char *TCODZip::getString()
+	@C const char *TCOD_zip_get_string(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	const char *getString();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading a color from the buffer
+	@Cpp TCODColor TCODZip::getColor()
+	@C TCOD_color_t TCOD_zip_get_color(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	TCODColor getColor();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading a color from the buffer
+	@Cpp TCODImage *TCODZip::getImage()
+	@C TCOD_image_t TCOD_zip_get_image(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	TCODImage *getImage();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading a console from the buffer
+	@Cpp TCODConsole *TCODZip::getConsole()
+	@C TCOD_console_t TCOD_zip_get_console(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	TCODConsole *getConsole();
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Reading some custom data from the buffer
+	@FuncDesc Note that the getData length must match the length of the data when the file was created (with putData).
+		The function returns the number of bytes that were stored in the file by the putData call. If more than nbBytes were stored, the function read only nbBytes and skip the rest of them.
+	@Cpp int TCODZip::getData(int nbBytes, void *data)
+	@C int TCOD_zip_get_data(TCOD_zip_t zip, int nbBytes, void *data)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param nbBytes	Number of bytes to read
+	@Param data	Address of a pre-allocated buffer (at least nbBytes bytes)
+	@CppEx 
+		TCODZip zip;
+		zip.loadFromFile("myCompressedFile.gz");
+		char c=zip.getChar();
+		int i=zip.getInt();
+		float f= zip.getFloat();
+		const char *s=zip.getString();
+		zip.getData(nbBytes, dataPtr);
+	@CEx 
+		TCOD_zip_t zip=TCOD_zip_new();
+		TCOD_zip_load_from_file(zip,"myCompressedFile.gz");
+		char c=TCOD_zip_get_char(zip);
+		int i=TCOD_zip_get_int(zip);
+		float f=TCOD_zip_get_float(zip);
+		const char *s=TCOD_zip_get_string(zip);
+		TCOD_zip_get_data(zip,nbBytes, dataPtr);
+	*/	
+	int getData(int nbBytes, void *data);
+	
+	/**
+	@PageName zip_load
+	@FuncTitle Getting the number of remaining bytes in the buffer
+	@Cpp uint32 TCODZip::getRemainingBytes() const
+	@C uint32 TCOD_zip_get_remaining_bytes(TCOD_zip_t zip)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	*/	
+	uint32 getRemainingBytes() const;
+
+	/**
+	@PageName zip_load
+	@FuncTitle Skiping some bytes in the buffer
+	@Cpp void TCODZip::skipBytes(uint32 nbBytes)
+	@C void TCOD_zip_skip_bytes(TCOD_zip_t zip, uint32 nbBytes)
+	@Param zip	In the C version, the buffer handler, returned by the constructor.
+	@Param nbBytes number of uncompressed bytes to skip
+	*/	
+	void skipBytes(uint32 nbBytes);
+protected :
+	TCOD_zip_t data;
+};
+
+#endif
--- a/include/list.hpp
+++ /dev/null
@@ -1,616 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_LIST_HPP
-#define _TCOD_LIST_HPP
-
-#include <string.h> // memcpy
-#include <stdlib.h> // NULL
-
-/**
- @PageName list
- @PageCategory Base toolkits
- @PageTitle All purposes container
- @PageDesc This is a fast, lightweight and generic container, that provides array, list and stack paradigms.
-Note that this module has no python wrapper. Use python built-in containers instead.
- */
-
-// fast & lightweight list template
-template <class T> class TCODList {
-	T *array;
-	int fillSize;
-	int allocSize;
-
-public :
-	/**
-	@PageName list_create
-	@PageFather list
-	@PageTitle Creating a list
-	@FuncTitle Using the default constructor
-	@FuncDesc You can create an empty list with the default constructor. The C version returns a handler on the list.
-	@Cpp template <class T> TCODList::TCODList()
-	@C TCOD_list_t TCOD_list_new()
-	@CppEx 
-		TCODList<int> intList;
-		TCODList<float> *floatList = new TCODList<float>();
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_t floatList = TCOD_list_new();
-	*/
-	TCODList() {
-		array=NULL;
-		fillSize=allocSize=0;
-	}
-
-	/**
-	@PageName list_create
-	@FuncTitle Duplicating an existing list
-	@FuncDesc You can create a list by duplicating an existing list.
-	@Cpp template <class T> TCODList::TCODList(const TCODList &l)
-	@C TCOD_list_t TCOD_list_duplicate(TCOD_list_t l)
-	@Param l	Existing list to duplicate.
-	@CppEx 
-		TCODList<int> intList;
-		intList.push(3);
-		intList.push(5);
-		TCODList<int> intList2(intList); // intList2 contains two elements : 3 and 5
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)3);
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_t intList2 = TCOD_list_duplicate(intList); // intList2 contains two elements : 3 and 5
-	*/
-	TCODList(const TCOD_list_t l) {
-		array=NULL;
-		fillSize=allocSize=0;
-		for ( void **it=TCOD_list_begin(l); it != TCOD_list_end(l); it++ ) {
-			push(*((T *)(it)));
-		}
-	}
-	TCODList(const TCODList<T> &l2) {
-		array=NULL;
-		fillSize=allocSize=0;
-		*this = l2;
-	}
-
-	/**
-	@PageName list_create
-	@FuncTitle Preallocating memory
-	@FuncDesc You can also create an empty list and pre-allocate memory for elements. Use this if you know the list size and want the memory to fit it perfectly.
-	@Cpp template <class T> TCODList::TCODList(int nbElements)
-	@C TCOD_list_t TCOD_list_allocate(int nbElements)
-	@Param nbElements	Allocate memory for nbElements.
-	@CppEx TCODList<int> intList(5); // create an empty list, pre-allocate memory for 5 elements
-	@CEx TCOD_list_t intList = TCOD_list_allocate(5);
-	*/
-	TCODList(int nbElements) {
-		fillSize=0;
-		allocSize=nbElements;
-		array=new T[ nbElements ];
-	}
-
-	/**
-	@PageName list_create
-	@FuncTitle Deleting a list
-	@FuncDesc You can delete a list, freeing any allocated resources. Note that deleting the list does not delete it's elements. You have to use clearAndDelete before deleting the list if you want to destroy the elements too.
-	@Cpp virtual template <class T> TCODList::~TCODList()
-	@C void TCOD_list_delete(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> *intList = new TCODList<int>(); // allocate a new empty list
-		intList->push(5); // the list contains 1 element at position 0, value = 5
-		delete intList; // destroy the list
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_delete(intList);
-	*/
-	virtual ~TCODList() {
-		if ( array ) delete [] array;
-	}
-
-	/**
-	@PageName list_array
-	@PageTitle Basic array operations
-	@PageFather list
-	@FuncTitle Setting an element
-	@FuncDesc You can assign a value with set. If needed, the array will allocate new elements up to idx.
-	@Cpp template <class T> void TCODList::set(const T elt, int idx)
-	@C void TCOD_list_set(TCOD_list_t l,const void *elt, int idx)
-	@Param elt	Element to put in the array.
-	@Param idx	Index of the element.
-		0 <= idx
-	@Param l	In the C version, the handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the array is empty (contains 0 elements)
-		intList.set(5,0); // the array contains 1 element at position 0, value = 5
-		intList.set(7,2); // the array contains 3 elements : 5, 0, 7
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,(const void *)5,0);
-		TCOD_list_set(intList,(const void *)7,2);
-	*/
-	void set(const T elt, int idx) {
-		if ( idx < 0 ) return;
-		while ( allocSize < idx+1 ) allocate();
-		array[idx] = elt;
-		if ( idx+1 > fillSize ) fillSize = idx+1;
-	}
-
-	/**
-	@PageName list_array
-	@FuncTitle Getting an element value
-	@FuncDesc You can retrieve a value with get.
-	@Cpp template <class T> T TCODList::get(int idx) const
-	@C void * TCOD_list_get(TCOD_list_t l,int idx)
-	@Param idx	Index of the element.
-		0 <= idx < size of the array
-	@Param l	In the C version, the handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList;
-		intList.set(5,0);
-		int val = intList.get(0); // val == 5
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,(const void *)5,0);
-		int val = (int)TCOD_list_get(intList,0); // val == 5
-	*/
-	T get(int idx) const {
-		return array[idx];
-	}
-
-	/**
-	@PageName list_array
-	@FuncTitle Checking if a list is empty
-	@Cpp template <class T> bool TCODList::isEmpty() const
-	@C bool TCOD_list_is_empty(TCOD_list_t l)
-	@Param l	In the C version, the handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList;
-		bool empty=intList.isEmpty(); // empty == true
-		intList.set(3,0);
-		empty=intList.isEmpty(); // empty == false
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		bool empty=TCOD_list_is_empty(intList); // empty == true 
-		TCOD_list_set(intList,(const void *)5,0);
-		empty=TCOD_list_is_empty(intList); // empty == false 
-	*/
-	bool isEmpty() const {
-		return ( fillSize == 0 );
-	}
-
-	/**
-	@PageName list_array
-	@FuncTitle Getting the list size
-	@Cpp template <class T> int TCODList::size() const
-	@C int TCOD_list_size(TCOD_list_t l)
-	@Param l	In the C version, the handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList;
-		int size=intList.size(); // size == 0
-		intList.set(3,0);
-		size=intList.size(); // size == 1
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		int size=TCOD_list_size(intList); // size == 0 
-		TCOD_list_set(intList,(const void *)5,0);
-		size=TCOD_list_size(intList); // size == 1 
-	*/
-	int size() const {
-		return fillSize;
-	}
-
-	/**
-	@PageName list_array
-	@FuncTitle Checking if an element is in the list
-	@Cpp template <class T> bool TCODList::contains(const T elt) const
-	@C bool TCOD_list_contains(TCOD_list_t l,const void * elt)
-	@Param elt	The element.
-	@Param l	In the C version, the handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList;
-		intList.set(3,0);
-		bool has3 = intList.contains(3); // has3 == true
-		bool has4 = intList.contains(4); // has4 == false
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,(const void *)3,0);
-		bool has3 = TCOD_list_contains(intList,(const void *)3); // has3 == true 
-		bool has4 = TCOD_list_contains(intList,(const void *)4); // has4 == false 
-	*/
-	bool contains(const T elt) const {
-		for ( T* curElt = begin(); curElt != end(); curElt ++) {
-			if ( *curElt == elt ) return true;
-		}
-		return false;
-	}
-
-	/**
-	@PageName list_list
-	@PageFather list
-	@PageTitle Basic list operations
-	@FuncTitle Insert an element in the list
-	@Cpp template <class T> void TCODList::insertBefore(const T elt,int before)
-	@C void TCOD_list_insert_before(TCOD_list_t l,const void *elt,int before)
-	@Param elt	Element to insert in the list.
-	@Param idx	Index of the element after the insertion.
-		0 <= idx < list size
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.set(0,5); // the list contains 1 element at position 0, value = 5
-		intList.insertBefore(2,0); // the list contains 2 elements : 2,5
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,0,(const void *)5);
-		TCOD_list_insert_before(intList,(const void *)2,0);
-	*/
-	T * insertBefore(const T elt,int before) {
-		if ( fillSize+1 >= allocSize ) allocate();
-		for (int idx=fillSize; idx > before; idx--) {
-			array[idx]=array[idx-1];
-		}
-		array[before]=elt;
-		fillSize++;
-		return &array[before];
-	}
-
-	/**
-	@PageName list_list
-	@FuncTitle Removing an element from the list
-	@FuncDesc The _fast versions replace the element to remove with the last element of the list. They're faster, but do not preserve the list order.
-	@Cpp 
-		template <class T> void TCODList::remove(const T elt)
-		template <class T> void TCODList::removeFast(const T elt)
-	@C 
-		void TCOD_list_remove(TCOD_list_t l, const void * elt)
-		void TCOD_list_remove_fast(TCOD_list_t l, const void * elt)
-	@Param elt	The element to remove
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.set(0,5); // the list contains 1 element at position 0, value = 5
-		intList.remove(5); // the list is empty
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,0,(const void *)5);
-		TCOD_list_remove(intList,(const void *)5);
-	*/
-	void remove(const T elt) {
-		for ( T* curElt = begin(); curElt != end(); curElt ++) {
-			if ( *curElt == elt ) {
-				remove(curElt);
-				return;
-			}
-		}
-	}
-	void removeFast(const T elt) {
-		for ( T* curElt = begin(); curElt != end(); curElt ++) {
-			if ( *curElt == elt ) {
-				removeFast(curElt);
-				return;
-			}
-		}
-	}
-
-	/**
-	@PageName list_list
-	@FuncTitle Concatenating two lists
-	@FuncDesc You can concatenate two lists. Every element of l2 will be added to current list (or l in the C version) :
-	@Cpp template <class T> void TCODList::addAll(const TCODList &l2)
-	@C void TCOD_list_add_all(TCOD_list_t l, TCOD_list_t l2)
-	@Param l	The list inside which elements will be added.
-	@Param l2	the list handler containing elements to insert.
-	@CppEx 
-		TCODList<int> intList;
-		intList.set(1,3); // intList contains 2 elements : 0, 3
-		TCODList<int> intList2; // intList2 is empty
-		intList2.set(0,1); // intList2 contains 1 element : 1
-		intList2.addAll(intList); // intList2 contains 3 elements : 1, 0, 3
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,1,(const void *)3);
-		TCOD_list_t intList2 = TCOD_list_new();
-		TCOD_list_set(intList2,0,(const void *)1);
-		TCOD_list_add_all(intList2,intList);
-	*/
-	void addAll(const TCODList<T> &l2) {
-		for (T *t=l2.begin(); t!= l2.end(); t++) {
-			push(*t);
-		}
-	}
-
-	/**
-	@PageName list_list
-	@FuncTitle Emptying a list
-	@Cpp template <class T> void TCODList::clear()
-	@C void TCOD_list_clear(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList;
-		intList.set(0,3); // intList contains 1 element
-		intList.clear(); // intList is empty
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_set(intList,0,(const void *)5);
-		TCOD_list_clear(intList);
-	*/
-	void clear() {
-		fillSize=0;
-	}
-	/**
-	@PageName list_list
-	@FuncTitle Emptying a list and destroying its elements
-	@FuncDesc For lists containing pointers, you can clear the list and delete (or free for C) the elements :
-	@Cpp template <class T> void TCODList::clearAndDelete()
-	@C void TCOD_list_clear_and_delete(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<MyClass *> intList;
-		MyClass * cl=new MyClass(); // new instance of MyClass allocated here
-		intList.set(0,cl); 
-		intList.clear(); // the list is empty. cl is always valid
-		intList.set(0,cl); 
-		intList.clearAndDelete(); // the list is empty. delete cl has been called. The address cl is no longer valid.
-	@C 
-		TCOD_list_t intList = TCOD_list_new();
-		void *data=calloc(10,1); // some memory allocation here 
-		TCOD_list_set(intList,0,(const void *)data);
-		TCOD_list_clear(intList); // the list is empty, but data is always valid 
-		TCOD_list_set(intList,0,(const void *)data);
-		TCOD_list_clear_and_delete(intList); // the list is empty, free(data) has been called. The address data is no longer valid 
-	*/
-	void clearAndDelete() {
-		for ( T* curElt = begin(); curElt != end(); curElt ++ ) {
-			delete (*curElt);
-		}
-		fillSize=0;
-	}
-
-	/**
-	@PageName list_list
-	@FuncTitle Reversing a list
-	@FuncDesc This function reverses the order of the elements in the list.</b>
-	@Cpp 
-		void TCODList::reverse()
-	@C 
-		void TCOD_list_reverse(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.push(5); // the list contains 1 element at position 0, value = 5
-		intList.push(2); // the list contains 2 elements : 5,2
-		intList.reverse(); // now order is 2,5
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_push(intList,(const void *)2);
-		TCOD_list_reverse();
-	*/
-	void reverse() {
-		T* head = begin();
-		T* tail = end();
-		while ( head < tail ) {
-			T tmp = *head;
-			*head=*tail;
-			*tail=tmp;
-			head++;
-			tail--;
-		}
-	}
-
-	/**
-	@PageName list_stack
-	@PageTitle Basic stack operations
-	@PageFather list
-	@FuncTitle Pushing an element on the stack
-	@FuncDesc You can push an element on the stack (append it to the end of the list) :
-	@Cpp template <class T> void TCODList::push(const T elt) 
-	@C void TCOD_list_push(TCOD_list_t l, const void * elt)
-	@Param elt	Element to append to the list.
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.push(5); // the list contains 1 element at position 0, value = 5
-		intList.push(2); // the list contains 2 elements : 5,2
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_push(intList,(const void *)2);
-	*/
-	void push(const T elt) {
-		if ( fillSize+1 >= allocSize ) allocate();
-		array[fillSize++] = elt;
-	}
-
-	/**
-	@PageName list_stack
-	@FuncTitle Poping an element from the stack
-	@FuncDesc You can pop an element from the stack (remove the last element of the list).
-	@Cpp template <class T> T TCODList::pop()
-	@C void * TCOD_list_pop(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.push(5); // the list contains 1 element at position 0, value = 5
-		intList.push(2); // the list contains 2 elements : 5,2
-		int val = intList.pop(); // val == 2, the list contains 1 element : 5
-		val = intList.pop(); // val == 5, the list is empty
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_push(intList,(const void *)2);
-		int val = (int)TCOD_list_pop(intList);
-		val = (int)TCOD_list_pop(intList);
-	*/
-	T pop() {
-		if ( fillSize == 0 ) return (T)0;
-		return array[--fillSize];
-	}
-
-	/**
-	@PageName list_stack
-	@FuncTitle Peeking the last element of the stack
-	@FuncDesc You can read the last element of the stack without removing it :
-	@Cpp template <class T> T TCODList::peek() const
-	@C void * TCOD_list_peek(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList;
-		intList.push(3); // intList contains 1 elements : 3
-		int val = intList.peek(); // val == 3, inList contains 1 elements : 3
-		intList.push(2); // intList contains 2 elements : 3, 2
-		val = intList.peek(); // val == 2, inList contains 2 elements : 3, 2
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)3);
-		int val = (int)TCOD_list_peek(intList);
-		TCOD_list_push(intList,(const void *)2);
-		val = (int)TCOD_list_peek(intList);
-	*/
-	T peek() const {
-		if ( fillSize == 0 ) return (T)0;
-		return array[fillSize-1];
-	}
-
-	/**
-	@PageName list_iterator
-	@PageFather list
-	@PageTitle Iterators
-	@FuncDesc You can iterate through the elements of the list using an iterator. begin() returns the address of the first element of the list. You go to the next element using the increment operator ++. When the iterator's value is equal to end(), you've gone through all the elements. <b>Warning ! You cannot insert elements in the list while iterating through it. Inserting elements can result in reallocation of the list and your iterator will not longer be valid.</b>
-	@Cpp 
-		template <class T> T * TCODList::begin() const
-		template <class T> T * TCODList::end() const
-	@C 
-		void ** TCOD_list_begin(TCOD_list_t l)
-		void ** TCOD_list_end(TCOD_list_t l)
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.push(5); // the list contains 1 element at position 0, value = 5
-		intList.push(2); // the list contains 2 elements : 5,2
-		for ( int * iterator = intList.begin(); iterator != intList.end(); iterator ++ ) {
-			int currentValue=*iterator;
-			printf("value : %d\n", currentValue );
-		}
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_push(intList,(const void *)2);
-		for ( int * iterator = (int *)TCOD_list_begin(intList); iterator != (int *)TCOD_list_end(intList); iterator ++ ) {
-			int currentValue=*iterator;
-			printf("value : %d\n", currentValue );
-		}
-	*/
-	T * begin() const {
-		if ( fillSize == 0 ) return (T *)NULL;
-		return &array[0];
-	}
-	T * end() const {
-		if ( fillSize == 0 ) return (T *)NULL;
-		return &array[fillSize];
-	}
-
-	/**
-	@PageName list_iterator
-	@FuncDesc You can remove an element from the list while iterating. The element at the iterator position will be removed. The function returns the new iterator. The _fast versions replace the element to remove with the last element of the list. They're faster, but do not preserve the list order.
-	@Cpp 
-		template <class T> T *TCODList::remove(T *iterator)
-		template <class T> T *TCODList::removeFast(T *iterator)
-	@C 
-		void **TCOD_list_remove_iterator(TCOD_list_t l, void **iterator)
-		void **TCOD_list_remove_iterator_fast(TCOD_list_t l, void **iterator)
-	@Param iterator	The list iterator.
-	@Param l	In the C version, the list handler, returned by a constructor.
-	@CppEx 
-		TCODList<int> intList; // the list is empty (contains 0 elements)
-		intList.push(5); // the list contains 1 element at position 0, value = 5
-		intList.push(2); // the list contains 2 elements : 5,2
-		intList.push(3); // the list contains 3 elements : 5,2,3
-		for ( int * iterator = intList.begin(); iterator != intList.end(); iterator ++ ) {
-			int currentValue=*iterator;
-			if ( currentValue == 2 ) {
-				// remove this value from the list and keep iterating on next element (value == 3)
-				iterator = intList.remove(iterator);
-			}
-			printf("value : %d\n", currentValue ); // all 3 values will be printed : 5,2,3
-		}
-		// now the list contains only two elements : 5,3
-	@CEx 
-		TCOD_list_t intList = TCOD_list_new();
-		TCOD_list_push(intList,(const void *)5);
-		TCOD_list_push(intList,(const void *)2);
-		TCOD_list_push(intList,(const void *)3);
-		for ( int * iterator = (int *)TCOD_list_begin(intList); iterator != (int *)TCOD_list_end(intList); iterator ++ ) {
-			int currentValue=*iterator;
-			if ( currentValue == 2 ) {
-				iterator = (int *)TCOD_list_remove_iterator(intList,(void **)iterator);
-			}
-			printf("value : %d\n", currentValue );
-		}
-	*/
-	T *remove(T *elt) {
-		for ( T* curElt = elt; curElt < end()-1; curElt ++) {
-			*curElt = *(curElt+1);
-		}
-		fillSize--;
-		if ( fillSize == 0 ) return ((T *)NULL)-1;
-		else return elt-1;
-	}
-	T *removeFast(T *elt) {
-		*elt = array[fillSize-1];
-		fillSize--;
-		if ( fillSize == 0 ) return ((T *)NULL)-1;
-		else return elt-1;
-	}
-
-	TCODList<T> & operator = (TCODList<T> const & l2) {
-		while ( allocSize < l2.allocSize ) allocate();
-		fillSize=l2.fillSize;
-		int i=0;
-		for (T *t=l2.begin(); t != l2.end(); t++) {
-			array[i++]=*t;
-		}
-		return *this;
-	}  
-
-protected :
-	void allocate() {
-		int newSize = allocSize * 2;
-		if ( newSize == 0 ) newSize = 16;
-		T *newArray = new T[ newSize ];
-		if ( array ) {
-			if ( fillSize > 0 ) memcpy(newArray, array, sizeof(T)*fillSize);
-			delete [] array;
-		}
-		array=newArray;
-		allocSize=newSize;
-	}
-};
-
-#endif
--- a/include/mersenne.hpp
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_RANDOM_HPP
-#define _TCOD_RANDOM_HPP
-
-#include "mersenne_types.h"
-
-/**
- @PageName random
- @PageCategory Base toolkits
- @PageTitle Pseudorandom number generator
- @PageDesc This toolkit is an implementation of two fast and high quality pseudorandom number generators:
-* a Mersenne twister generator,
-* a Complementary-Multiply-With-Carry generator.
-CMWC is faster than MT (see table below) and has a much better period (1039460 vs. 106001). It is the default algo since libtcod 1.5.0.
-
-Relative performances in two independent tests (lower is better) :
-<table class="param">
-    <tr>
-      <th>Algorithm</th>
-      <th>Numbers generated</th>
-      <th>Perf (1)</th>
-      <th>Perf (2)</th>
-    </tr>
-    <tr class="hilite">
-      <td>MT</td>
-      <td>integer</td>
-      <td>62</td>
-      <td>50</td>
-    </tr>
-    <tr>
-      <td>MT</td>
-      <td>float</td>
-      <td>54</td>
-      <td>45</td>
-    </tr>
-    <tr class="hilite">
-      <td>CMWC</td>
-      <td>integer</td>
-      <td>21</td>
-      <td>34</td>
-    </tr>
-    <tr>
-      <td>CMWC</td>
-      <td>float</td>
-      <td>32</td>
-      <td>27</td>
-    </tr>
-</table>
-
-<h6>For python users:</h6>
-Python already has great builtin random generators. But some parts of the Doryen library (noise, heightmap, ...) uses RNG as parameters. If you intend to use those functions, you must provide a RNG created with the library.
-
-<h6>For C# users:</h6>
-.NET already has great builtin random generators. But some parts of the Doryen library (noise, heightmap, ...) uses RNG as parameters. If you intend to use those functions, you must provide a RNG created with the library.
- */
-
-class TCODLIB_API TCODRandom {
-	public :
-		/**
-		@PageName random_init
-		@PageFather random
-		@PageTitle Creating a generator
-		@FuncTitle Default generator
-		@FuncDesc The simplest way to get random number is to use the default generator. The first time you get this generator, it is initialized by calling TCOD_random_new. Then, on successive calls, this function returns the same generator (singleton pattern).
-		@Cpp static TCODRandom * TCODRandom::getInstance (void)
-		@C TCOD_random_t TCOD_random_get_instance (void)
-		@Py random_get_instance ()
-		@C# static TCODRandom TCODRandom::getInstance()
-		@Param algo	The PRNG algorithm the generator should be using. Possible values are:
-			* TCOD_RNG_MT for Mersenne Twister,
-			* TCOD_RNG_CMWC for Complementary Multiply-With-Carry.
-		*/
-		static TCODRandom * getInstance(void);
-
-		/**
-		@PageName random_init
-		@FuncTitle Generators with random seeds
-		@FuncDesc You can also create as many generators as you want with a random seed (the number of seconds since Jan 1 1970 at the time the constructor is called). Warning ! If you call this function several times in the same second, it will return the same generator.
-		@Cpp TCODRandom::TCODRandom (TCOD_random_algo_t algo = TCOD_RNG_CMWC)
-		@C TCOD_random_t TCOD_random_new (TCOD_random_algo_t algo)
-		@Py random_new (algo = RNG_CMWC)
-		@C#
-			TCODRandom::TCODRandom() // Defaults to ComplementaryMultiplyWithCarry
-			TCODRandom::TCODRandom(TCODRandomType algo)
-		@Param algo	The PRNG algorithm the generator should be using.
-		*/
-		TCODRandom(TCOD_random_algo_t algo = TCOD_RNG_CMWC, bool allocate = true);
-
-		/**
-		@PageName random_init
-		@FuncTitle Generators with user defined seeds
-		@FuncDesc Finally, you can create generators with a specific seed. Those allow you to get a reproducible set of random numbers. You can for example save a dungeon in a file by saving only the seed used for its generation (provided you have a determinist generation algorithm)
-		@Cpp TCODRandom::TCODRandom (uint32 seed, TCOD_random_algo_t algo = TCOD_RNG_CMWC);
-		@C TCOD_random_t TCOD_random_new_from_seed (TCOD_random_algo_t algo, uint32 seed);
-		@Py random_new_from_seed(seed, algo=RNG_CMWC)
-		@C#
-			TCODRandom::TCODRandom(uint32 seed) // Defaults to ComplementaryMultiplyWithCarry
-			TCODRandom::TCODRandom(uint32 seed, TCODRandomType algo)
-		@Param seed	The 32 bits seed used to initialize the generator. Two generators created with the same seed will generate the same set of pseudorandom numbers.
-		@Param algo	The PRNG algorithm the generator should be using.
-		@CppEx
-			// default generator
-			TCODRandom * default = TCODRandom::getInstance();
-			// another random generator
-			TCODRandom * myRandom = new TCODRandom();
-			// a random generator with a specific seed
-			TCODRandom * myDeterministRandom = new TCODRandom(0xdeadbeef);
-        @CEx
-			// default generator
-			TCOD_random_t default = TCOD_random_get_instance();
-			// another random generator
-			TCOD_random_t my_random = TCOD_random_new(TCOD_RNG_CMWC);
-			// a random generator with a specific seed
-			TCOD_random_t my_determinist_random = TCOD_random_new_from_seed(TCOD_RNG_CMWC,0xdeadbeef);
-		@PyEx
-			# default generator
-			default = libtcod.random_get_instance()
-			# another random generator
-			my_random = libtcod.random_new()
-			# a random generator with a specific seed
-			my_determinist_random = libtcod.random_new_from_seed(0xdeadbeef)
-		*/
-		TCODRandom(uint32 seed, TCOD_random_algo_t algo = TCOD_RNG_CMWC);
-
-		/**
-		@PageName random_init
-		@FuncTitle Destroying a RNG
-		@FuncDesc To release ressources used by a generator, use those functions :
-			NB : do not delete the default random generator !
-		@Cpp TCODRandom::~TCODRandom()
-		@C void TCOD_random_delete(TCOD_random_t mersenne)
-		@Py random_delete(mersenne)
-		@C# void TCODRandom::Dispose()
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions.
-		@CppEx
-			// create a generator
-			TCODRandom *rnd = new TCODRandom();
-			// use it
-			...
-			// destroy it
-			delete rnd;
-		@CEx
-			// create a generator
-			TCOD_random_t rnd = TCOD_random_new();
-			// use it
-			...
-			// destroy it
-			TCOD_random_delete(rnd);
-		@PyEx
-			# create a generator
-			rnd = libtcod.random_new()
-			# use it
-			...
-			# destroy it
-			libtcod.random_delete(rnd)
-		*/
-		virtual ~TCODRandom();
-
-		/**
-		@PageName random_distro
-		@PageFather random
-		@PageTitle Using a generator
-		@FuncTitle Setting the default RNG distribution
-		@FuncDesc Random numbers can be obtained using several different distributions. Linear is default, but if you wish to use one of the available Gaussian distributions, you can use this function to tell libtcod which is your preferred distribution. All random number getters will then use that distribution automatically to fetch your random numbers.
-The distributions available are as follows:
-1. TCOD_DISTRIBUTION_LINEAR
-This is the default distribution. It will return a number from a range min-max. The numbers will be evenly distributed, ie, each number from the range has the exact same chance of being selected.
-2. TCOD_DISTRIBUTION_GAUSSIAN
-This distribution does not have minimum and maximum values. Instead, a mean and a standard deviation are used. The mean is the central value. It will appear with the greatest frequency. The farther away from the mean, the less the probability of appearing the possible results have. Although extreme values are possible, 99.7% of the results will be within the radius of 3 standard deviations from the mean. So, if the mean is 0 and the standard deviation is 5, the numbers will mostly fall in the (-15,15) range.
-3. TCOD_DISTRIBUTION_GAUSSIAN_RANGE
-This one takes minimum and maximum values. Under the hood, it computes the mean (which falls right between the minimum and maximum) and the standard deviation and applies a standard Gaussian distribution to the values. The difference is that the result is always guaranteed to be in the min-max range.
-4. TCOD_DISTRIBUTION_GAUSSIAN_INVERSE
-Essentially, this is the same as TCOD_DISTRIBUTION_GAUSSIAN. The difference is that the values near +3 and -3 standard deviations from the mean have the highest possibility of appearing, while the mean has the lowest.
-5. TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE
-Essentially, this is the same as TCOD_DISTRIBUTION_GAUSSIAN_RANGE, but the min and max values have the greatest probability of appearing, while the values between them, the lowest.
-
-There exist functions to also specify both a min-max range AND a custom mean, which can be any value (possibly either min or max, but it can even be outside that range). In case such a function is used, the distributions will trigger a slihtly different behaviour:
-* TCOD_DISTRIBUTION_LINEAR
-* TCOD_DISTRIBUTION_GAUSSIAN
-* TCOD_DISTRIBUTION_GAUSSIAN_RANGE
-In these cases, the selected mean will have the highest probability of appearing.
-
-* TCOD_DISTRIBUTION_GAUSSIAN_INVERSE
-* TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE
-In these cases, the selected mean will appear with the lowest frequency.
-		@Cpp void TCODRandom::setDistribution(TCOD_distribution_t distribution)
-		@C void TCOD_random_set_distribution(TCOD_random_t mersenne, TCOD_distribution_t distribution)
-		@Py
-		@C#
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used..
-		@Param distribution The distribution constant from the available set:<ul><li>TCOD_DISTRIBUTION_LINEAR</li><li>TCOD_DISTRIBUTION_GAUSSIAN</li><li>TCOD_DISTRIBUTION_GAUSSIAN_RANGE</li><li>TCOD_DISTRIBUTION_GAUSSIAN_INVERSE</li><li>TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE</li></ul>
-		*/
-		inline void setDistribution (TCOD_distribution_t distribution) { TCOD_random_set_distribution(data,distribution); }
-
-		/**
-		@PageName random_use
-		@PageFather random
-		@PageTitle Using a generator
-		@FuncTitle Getting an integer
-		@FuncDesc Once you obtained a generator (using one of those methods), you can get random numbers using the following functions, using either the explicit or simplified API where applicable:
-		@Cpp
-			//explicit API:
-			int TCODRandom::getInt(int min, int max, int mean = 0)
-
-			//simplified API:
-			int TCODRandom::get(int min, int max, int mean = 0)
-		@C
-			int TCOD_random_get_int(TCOD_random_t mersenne, int min, int max)
-			int TCOD_random_get_int_mean(TCOD_random_t mersenne, int min, int max, int mean)
-		@Py
-		@C#
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used..
-		@Param min,max	Range of values returned. Each time you call this function, you get a number between (including) min and max
-		@Param mean This is used to set a custom mean, ie, not min+((max-min)/2). It can even be outside of the min-max range. Using a mean will force the use of a weighted (Gaussian) distribution, even if linear is set.
-		*/
-		inline int getInt (int min, int max, int mean = 0) { return (mean <= 0) ? TCOD_random_get_int(data,min,max) : TCOD_random_get_int_mean(data,min,max,mean); }
-		inline int get (int min, int max, int mean = 0) { return (mean <= 0) ? TCOD_random_get_int(data,min,max) : TCOD_random_get_int_mean(data,min,max,mean); }
-
-		/**
-		@PageName random_use
-		@FuncTitle Getting a float
-		@FuncDesc To get a random floating point number, using either the explicit or simplified API where applicable
-		@Cpp
-			//explicit API:
-			float TCODRandom::getFloat(float min, float max, float mean = 0.0f)
-
-			//simplified API:
-			float TCODRandom::get(float min, float max, float mean = 0.0f)
-		@C
-			float TCOD_random_get_float(TCOD_random_t mersenne, float min, float max)
-			float TCOD_random_get_float_mean(TCOD_random_t mersenne, float min, float max, float mean)
-		@Py random_get_float(mersenne, mi, ma)
-		@C# float TCODRandom::getFloat(float min, float max)
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
-		@Param min,max	Range of values returned. Each time you call this function, you get a number between (including) min and max
-		@Param mean This is used to set a custom mean, ie, not min+((max-min)/2). It can even be outside of the min-max range. Using a mean will force the use of a weighted (Gaussian) distribution, even if linear is set.
-		@CppEx
-			// default generator
-			TCODRandom * default = TCODRandom::getInstance();
-			int aRandomIntBetween0And1000 = default->getInt(0,1000);
-			int anotherRandomInt = default->get(0,1000);
-			// another random generator
-			TCODRandom *myRandom = new TCODRandom();
-			float aRandomFloatBetween0And1000 = myRandom->getFloat(0.0f,1000.0f);
-			float anotherRandomFloat = myRandom->get(0.0f,1000.0f);
-		@CEx
-			// default generator
-			int a_random_int_between_0_and_1000 = TCOD_random_get_float(NULL,0,1000);
-			// another random generator
-			TCOD_random_t my_random = TCOD_random_new();
-			float a_random_float_between_0_and_1000 = TCOD_random_get_float(my_random,0.0f,1000.0f);
-		@PyEx
-			# default generator
-			a_random_int_between_0_and_1000 = libtcod.random_get_float(0,0,1000)
-			# another random generator
-			my_random = libtcod.random_new()
-			a_random_float_between_0_and_1000 = libtcod.random_get_float(my_random,0.0,1000.0)
-		*/
-		inline float getFloat (float min, float max, float mean = 0.0f) { return (mean <= 0) ? TCOD_random_get_float(data,min,max) : TCOD_random_get_float_mean(data,min,max,mean); }
-		inline float get (float min, float max, float mean = 0.0f) { return (mean <= 0.0f) ? TCOD_random_get_float(data,min,max) : TCOD_random_get_float_mean(data,min,max,mean); }
-
-		/**
-		@PageName random_use
-		@FuncTitle Getting a double
-		@FuncDesc To get a random double precision floating point number, using either the explicit or simplified API where applicable
-		@Cpp
-			//explicit API:
-			double TCODRandom::getDouble(double min, double max, double mean = 0.0f)
-
-			//simplified API:
-			double TCODRandom::get(double min, double max, double mean = 0.0f)
-		@C
-			double TCOD_random_get_double(TCOD_random_t mersenne, double min, double max)
-			double TCOD_random_get_double_mean(TCOD_random_t mersenne, double min, double max, double mean)
-		@Py
-		@C#
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
-		@Param min,max	Range of values returned. Each time you call this function, you get a number between (including) min and max
-		@Param mean This is used to set a custom mean, ie, not min+((max-min)/2). It can even be outside of the min-max range. Using a mean will force the use of a weighted (Gaussian) distribution, even if linear is set.
-		@CppEx
-			// default generator
-			TCODRandom * default = TCODRandom::getInstance();
-			int aRandomIntBetween0And1000 = default->getInt(0,1000);
-			int anotherRandomInt = default->get(0,1000);
-			// another random generator
-			TCODRandom *myRandom = new TCODRandom();
-			float aRandomFloatBetween0And1000 = myRandom->getFloat(0.0f,1000.0f);
-			float anotherRandomFloat = myRandom->get(0.0f,1000.0f);
-		@CEx
-			// default generator
-			int a_random_int_between_0_and_1000 = TCOD_random_get_float(NULL,0,1000);
-			// another random generator
-			TCOD_random_t my_random = TCOD_random_new();
-			float a_random_float_between_0_and_1000 = TCOD_random_get_float(my_random,0.0f,1000.0f);
-		@PyEx
-			# default generator
-			a_random_int_between_0_and_1000 = libtcod.random_get_float(0,0,1000)
-			# another random generator
-			my_random = libtcod.random_new()
-			a_random_float_between_0_and_1000 = libtcod.random_get_float(my_random,0.0,1000.0)
-		*/
-		inline double getDouble (double min, double max, double mean = 0.0) { return (mean <= 0) ? TCOD_random_get_double(data,min,max) : TCOD_random_get_double_mean(data,min,max,mean); }
-		inline double get (double min, double max, double mean = 0.0f) { return (mean <= 0.0) ? TCOD_random_get_double(data,min,max) : TCOD_random_get_double_mean(data,min,max,mean); }
-
-		/**
-		@PageName random_use
-		@FuncTitle Saving a RNG state
-		@FuncDesc You can save the state of a generator with :
-		@Cpp TCODRandom *TCODRandom::save() const
-		@C TCOD_random_t TCOD_random_save(TCOD_random_t mersenne)
-		@Py random_save(mersenne)
-		@C# TCODRandom TCODRandom::save()
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
-		*/
-		TCODRandom * save() const;
-
-		/**
-		@PageName random_use
-		@FuncTitle Restoring a saved state
-		@FuncDesc And restore it later. This makes it possible to get the same serie of number several times with a single generator.
-		@Cpp void TCODRandom::restore(const TCODRandom *backup)
-		@C void TCOD_random_restore(TCOD_random_t mersenne, TCOD_random_t backup)
-		@Py random_restore(mersenne, backup)
-		@C# void TCODRandom::restore(TCODRandom backup)
-		@Param mersenne	In the C and Python versions, the generator handler, returned by the initialization functions. If NULL, the default generator is used.
-		@CppEx
-			// default generator
-			TCODRandom * default = TCODRandom::getInstance();
-			// save the state
-			TCODRandom *backup=default->save();
-			// get a random number (or several)
-			int number1 = default->getInt(0,1000);
-			// restore the state
-			default->restore(backup);
-			// get a random number
-			int number2 = default->getInt(0,1000);
-			// => number1 == number2
-		@CEx
-			// save default generator state
-			TCOD_random_t backup=TCOD_random_save(NULL);
-			// get a random number
-			int number1 = TCOD_random_get_float(NULL,0,1000);
-			// restore the state
-			TCOD_random_restore(NULL,backup);
-			// get a random number
-			int number2 = TCOD_random_get_float(NULL,0,1000);
-			// number1 == number2
-		@PyEx
-			# save default generator state
-			backup=libtcod.random_save(0)
-			# get a random number
-			number1 = libtcod.random_get_float(0,0,1000)
-			# restore the state
-			libtcod.random_restore(0,backup)
-			# get a random number
-			number2 = libtcod.random_get_float(0,0,1000)
-			# number1 == number2
-		*/
-		void restore(const TCODRandom *backup);
-
-		//dice
-		inline TCOD_dice_t dice (const char * s) { return TCOD_random_dice_new(s); }
-		inline int diceRoll (TCOD_dice_t dice) { return TCOD_random_dice_roll(data,dice); }
-		inline int diceRoll (const char * s) { return TCOD_random_dice_roll(data,TCOD_random_dice_new(s)); }
-
-	protected :
-		friend class TCODLIB_API TCODNoise;
-		friend class TCODLIB_API TCODHeightMap;
-		friend class TCODLIB_API TCODNamegen;
-		friend class TCODNameGenerator;	// Used for SWIG interface, does NOT need TCODLIB_API
-		TCOD_random_t data;
-};
-
-#endif
--- a/include/mouse.hpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_MOUSE_HPP
-#define _TCOD_MOUSE_HPP
-
-#include "mouse_types.h"
-
-class TCODLIB_API TCODMouse {
-public :
-	/**
-	@PageName mouse
-	@PageTitle Mouse support
-	@PageCategory Base toolkits
-	@FuncTitle Display and hide the mouse cursor
-	@FuncDesc By default, the mouse cursor in visible in windowed mode, hidden in fullscreen mode. You can change it with:
-	@Cpp static void TCODMouse::showCursor (bool visible)
-	@C void TCOD_mouse_show_cursor (bool visible)
-	@Py mouse_show_cursor (visible)
-	@C# void TCODMouse::showCursor(bool visible)
-	@Param visible	If true, this function turns the mouse cursor on. Else it turns the mouse cursor off.
-	*/
-	static void showCursor(bool visible);
-
-	/**
-	@PageName mouse
-	@FuncTitle Getting the cursor status
-	@FuncDesc You can get the current cursor status (hidden or visible) with:
-	@Cpp static bool TCODMouse::isCursorVisible (void)
-	@C bool TCOD_mouse_is_cursor_visible (void)
-	@Py mouse_is_cursor_visible ()
-	@C# bool TCODMouse::isCursorVisible()
-	*/
-	static bool isCursorVisible();
-
-	/**
-	@PageName mouse
-	@FuncTitle Setting the mouse cursor's position
-	@FuncDesc You can set the cursor position (in pixel coordinates, where [0,0] is the window's top left corner) with:
-	@Cpp static void TCODMouse::move (int x, int y)
-	@C void TCOD_mouse_move (int x, int y)
-	@Py mouse_move (x, y)
-	@C# void TCODMouse::moveMouse(int x, int y)
-	@Param x,y	New coordinates of the mouse cursor in pixels.
-	*/
-	static void move(int x, int y);
-
-	/**
-	@PageName mouse
-	@FuncTitle Getting the mouse status
-	@FuncDesc You can read the current mouse status with this function. Note that this function does not update the mouse status. You have to call either TCODSystem::checkForEvent or TCODSystem::waitForEvent for the mouse status to be updated.
-<div class="code"><pre>typedef struct {
-  int x,y;
-  int dx,dy;
-  int cx,cy;
-  int dcx,dcy;
-  bool lbutton; 
-  bool rbutton;
-  bool mbutton;
-  bool lbutton_pressed; 
-  bool rbutton_pressed; 
-  bool mbutton_pressed; 
-  bool wheel_up;
-  bool wheel_down;
-} TCOD_mouse_t;
-</pre></div>
-	@Cpp static TCOD_mouse_t TCODMouse::getStatus (void)
-	@C TCOD_mouse_t TCOD_mouse_get_status (void)
-	@Py mouse_get_status ()
-	@C# TCODMouseData TCODMouse::getStatus()
-	@Param x, y	Absolute position of the mouse cursor in pixels relative to the window top-left corner.
-	@Param dx, dy	Movement of the mouse cursor since the last call in pixels.
-	@Param cx, cy	Coordinates of the console cell under the mouse cursor (pixel coordinates divided by the font size).
-	@Param dcx, dcy	Movement of the mouse since the last call in console cells (pixel coordinates divided by the font size).
-	@Param lbutton	true if the left button is pressed.
-	@Param rbutton	true if the right button is pressed.
-	@Param mbutton	true if the middle button (or the wheel) is pressed.
-	@Param lbutton_pressed	true if the left button was pressed and released.
-	@Param rbutton_pressed	true if the right button was pressed and released.
-	@Param mbutton_pressed	true if the middle button was pressed and released.
-	@Param wheel_up	true if the wheel was rolled up.
-	@Param wheel_down	true if the wheel was rolled down.
-	*/
-	static TCOD_mouse_t getStatus();
-};
-
-#endif
--- a/include/namegen.hpp
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-/*
-* Mingos' NameGen
-* This file was written by Dominik "Mingos" Marczuk.
-*/
-
-#ifndef _TCOD_NAMEGEN_HPP
-#define _TCOD_NAMEGEN_HPP
-
-/**
- @PageName namegen
- @PageCategory Roguelike toolkits
- @PageTitle Name generator
- @PageDesc This tool allows to generate random names out of custom made syllable sets.
- */
-class TCODLIB_API TCODNamegen {
-	public:
-		/**
-		@PageName namegen_init
-		@PageFather namegen
-		@PageTitle Creating a generator
-		@FuncDesc In order to be able to generate names, the name generator needs to be fed proper data. It will then be ready to generate random names defined in the file(s) it is fed. Syllable set parsing is achieved via the following.
-			Note 1: Each file will be parsed once only. If, for some reason, you would like to parse the same file twice, you will need to destroy the generator first, which will empty the list of parsed files along with erasing all the data retrieved from those files.
-			
-			Note 2: The generator can be fed data multiple times if you have it in separate files. Just make sure the structure names in them aren't duplicated, otherwise they will be silently ignored.
-			
-			Note 3: In the C++ version, you are not obliged to specify the random number generator. If you skip it in the function call, the generator will assume you would like to use an instance of the default generator.
-
-		@Cpp static void TCODNamegen::parse (const char * filename, TCODRandom * random = NULL)
-		@C void TCOD_namegen_parse (const char * filename, TCOD_random_t random)
-		@Py namegen_parse (filename, random = 0)
-		@C#
-			static void TCODNameGenerator::parse(string filename)
-			static void TCODNameGenerator::parse(string filename, TCODRandom random)
-		@Param filename 	The file where the desired syllable set is saved, along with its relative parh, for instance, "data/names.txt".
-		@Param random 	A random number generator object. Use NULL for the default random number generator
-		@CppEx 
-			TCODNamegen::parse("data/names.txt",TCODRandom::getInstance());
-			TCODNamegen::parse("data/names2.txt");
-		@CEx TCOD_namegen_parse("data/names.txt",TCOD_random_get_instance());
-		@PyEx libtcod.namegen_parse('data/names.txt')
-		*/
-		static void parse (const char * filename, TCODRandom * random = NULL);
-
-		/**
-		@PageName namegen_init
-		@FuncTitle Destroying a generator
-		@FuncDesc To release the resources used by a name generator, you may call:
-			This will free all memory used by the generator. In order to generate a name again, you have to parse a file again. 
-		@Cpp static void TCODNamegen::destroy (void)
-		@C void TCOD_namegen_destroy (void)
-		@Py namegen_destroy ()
-		@C# static void TCODNameGenerator::destroy()
-		*/
-		static void destroy (void);
-
-		/**
-		@PageName namegen_generate
-		@PageTitle Generating a name
-		@PageFather namegen
-		@FuncTitle Generating a default name
-		@FuncDesc The following will output a random name generated using one of the generation rules specified in the syllable set:
-			Should you choose to allocate memory for the output, you need to remember to deallocate it once you don't need the name anymore using the free() function. This applies to C++ as well (delete won't work - you have to use free()).
-			
-			On the other hand, should you choose not to allocate memory, be aware that subsequent calls will overwrite the previously returned pointer, so make sure to copy the output using strcpy(), strdup() or other means of your choosing.
-			
-			The name you specify needs to be in one of the files the generator has previously parsed (see Creating a generator). If such a name doesn't exist, a warning will be displayed and NULL will be returned.
-		@Cpp static char * TCODNamegen::generate (char * name, bool allocate = false)
-		@C char * TCOD_namegen_generate (char * name, bool allocate)
-		@Py namegen_generate (name, allocate = 0)
-		@C# string TCODNameGenerator::generate (string name)
-		@Param name 	The structure name you wish to refer to, for instance, "celtic female".
-			For more about how structure names work, please refer to <a href="namegen_file.html">those</a> <a href="parser_format.html">chapters</a>.
-		@Param allocate 	Whether memory should be allocated for the output or not.
-		@CppEx 
-			TCODNamegen::parse("data/names.txt",TCODRandom::getInstance());
-			char * myName = TCODNamegen::generate("fantasy female");
-		@CEx 
-			TCOD_namegen_parse("data/names.txt",TCOD_random_get_instance());
-			char * my_name = TCOD_namegen_generate("Celtic male",false);
-		@PyEx 
-			libtcod.namegen_parse('data/names.txt')
-			name = libtcod.namegen_generate('Nordic female')
-		*/
-		static char * generate (char * name, bool allocate = false);
-
-		/**
-		@PageName namegen_generate
-		@FuncTitle Generating a custom name
-		@FuncDesc It is also possible to generate a name using custom generation rules. This overrides the random choice of a generation rule from the syllable set. Please refer to chapter 16.5 to learn about the name generation rules syntax.
-		@Cpp static char * TCODNamegen::generateCustom (char * name, char * rule, bool allocate = false)
-		@C char * TCOD_namegen_generate_custom (char * name, char * rule, bool allocate)
-		@Py namegen_generate_custom (name, rule, allocate = 0)
-		@C# string TCODNameGenerator::generateCustom (string name, string rule)
-		@Param name 	The structure name you wish to refer to, for instance, "celtic female".
-			For more about how structure names work, please refer to <a href="namegen_file.html">those</a> <a href="parser_format.html">chapters</a>.
-		@Param rule 	The name generation rule. See <a href="namegen_file.html">this chapter</a> for more details.
-		@Param allocate 	Whether memory should be allocated for the output or not.
-		@CppEx 
-			TCODNamegen::parse("data/names.txt",TCODRandom::getInstance());
-			char * myName = TCODNamegen::generateCustom("Nordic male","$s$e");
-		@CEx 
-			TCOD_namegen_parse("data/names.txt",TCOD_random_get_instance());
-			char * my_name = TCOD_namegen_generate_custom("Mesopotamian female","$s$e",false);
-		@PyEx 
-			libtcod.namegen_parse('data/names.txt')
-			name = libtcod.namegen_generate_custom('Nordic female','$s$e')
-		*/
-		static char * generateCustom (char * name, char * rule, bool allocate = false);
-
-		/**
-		@PageName namegen_generate
-		@FuncTitle Retrieving available set names
-		@FuncDesc If you wish to check the sylable set names that are currently available, you may call:
-		This will create a list with all the available syllable set names. Remember to delete that list after you don't need it anymore!
-		@Cpp static TCODList TCODNamegen::getSets ()
-		@C TCOD_list_t TCOD_namegen_get_sets ()
-		@Py namegen_get_sets ()
-		@C# static IEnumerable<string> TCODNameGenerator::getSets()
-		*/
-		static TCOD_list_t getSets (void);
-
-		/**
-		@PageName namegen_file
-		@PageFather namegen
-		@PageTitle Syllable set configuration
-		@PageDesc Configuring the syllable set is vital to obtaining high quality randomly generated names. Please refer to the following subchapters for detailed information:
-		*/
-
-		/**
-		@PageName namegen_file_1
-		@PageFather namegen_file
-		@PageTitle  Syllable set basic structure
-		@PageDesc The syllable sets need to be written in one or more text files that will be opened and parsed by the generator.
-
-The data uses a standard TCODParser file and data should be inserted according to the general rules of creating a configuration file. For more information, please refer to <a href="parser_format.html">The libtcod config file format</a>.
-
-The structure type that's defined in the generator is "name". This structure type must also be accompanied by a structure name. It will be used for identification purposes in the generator. For instance, if you use a structure name "fantasy female", you will be able to access this syllable set by creating a generator using "fantasy female" syllables. In the initialisation function, this is the "const char * name" argument.
-
-The structure contains different members, all of which must be of TCOD_TYPE_STRING type. The tokens inside the strings, be them phonemes or syllables, form a single string, but are separated with separator characters. Characters used for token separation are all characters that are not Latin upper- or lowercase characters, dashes or apostrophes. A comma, a space or a comma+space are all perfectly valid, human-readable separators. In order to use a character inside a string that would normally be considered a separator, precede it with a slash (eg. "/:", "/.", "/!", etc.). An exception to this rule is the space character, which can also be achieved by using an underscore (eg. "the_Great").
-
-The structure members that may thus be defined are:
-<div class="code"><p>phonemesVocals
-phonemesConsonants
-syllablesPre
-syllablesStart
-syllablesMiddle
-syllablesEnd
-syllablesPost
-</p></div>
-
-All of those strings are considered optional. However, if you don't define a string, but reference it in the name generation rules, you will see a warning displayed on stderr about missing data.
-		*/
-
-		/**
-		@PageName namegen_file_2
-		@PageFather namegen_file
-		@PageTitle  Illegal strings
-		@PageDesc Another optional property is
-<div class="code"><p>illegal</p></div>
-
-This property contains strings that are considered illegal and thus not desired in your names. Should a generated name contain any of the tokens specified in this string, it will be discarded and replaced by a new one. Illegal strings may be as short as single characters or as long as entire names. However, it is best to create a syllable set that generates very few names that sound bad. Otherwise, the illegal list might become very long.
-
-Be aware that the generator will automatically correct or reject certain words, so you don't need to place every undesired possibility in this string.
-
-The generator will correct the following:
-
-    * leading spaces ("_NAME")
-    * ending spaces ("NAME_")
-    * double spaces ("NAME1__NAME2")
-
-It will generate a new name in the following cases:
-
-    * triple characters ("Raaagnar")
-    * two-character adjacent repetitions ("Bobofur" is wrong, but "Bombofur" is OK)
-    * three-character (or more) repetitions, whether adjacent or not ("Bombombur", "Dagbjoerdag", "Gwaerdygwaern")
-
-Remember that all of this is case-insensitive, so you don't need to care about uppercase/lowercase distinction in your illegal strings.
-		*/
-
-		/**
-		@PageName namegen_file_3
-		@PageFather namegen_file
-		@PageTitle Rules
-		@PageDesc There's one last string that's contained within the structure:
-<div class="code"><p>rules</p></div>
-
-It is mandatory, so not defining it will trigger an error. It defines how the generator should join the supplied data in order to generate a name. This string uses a syntax of its own, which is also used when specifying a rule when generating a custom name (see chapter 16.2).
-
-The rules are parsed pretty much the same way as all other strings, so all rules regarding separators and special characters apply as well. However, you can additionally use a set of wildcards and frequency markers. Each wildcard is preceded by the dollar sign ('$'), while frequency markers are preceded by the per cent sign ('%'). Here's the complete wildcard list:
-<table class="param">
-<tbody><tr><th>Wildcard</th><th>Example</th><th>Description</th></tr>
-<tr class="hilite"><td>$[INT]P</td><td>$P, $25P</td><td>Use a random Pre syllable.<br>The optional integer value denotes the per cent chance of adding the syllable.</td></tr>
-<tr><td>$[INT]s</td><td>$s, $25s</td><td>Use a random Start syllable.</td></tr>
-<tr class="hilite"><td>$[INT]m</td><td>$m, $25m</td><td>Use a random Middle syllable.</td></tr>
-
-<tr><td>$[INT]e</td><td>$e, $25e</td><td>Use a random End syllable.</td></tr>
-<tr class="hilite"><td>$[INT]p</td><td>$p, $25p</td><td>Use a random Post syllable.</td></tr>
-<tr><td>$[INT]v</td><td>$v, $25v</td><td>Use a random vocal.</td></tr>
-<tr class="hilite"><td>$[INT]c</td><td>$c, $25c</td><td>Use a random consonant.</td></tr>
-<tr><td>$[INT]?</td><td>$?, $25?</td><td>Use a random phoneme (vocal or consonant).</td></tr>
-
-<tr class="hilite"><td>%INT</td><td>%50, %25</td><td>Frequency marker. Denotes the per cent chance for the rule to be accepted if it's picked.<br>If the rule is not accepted, another roll is made to choose a name generation rule.<br>It's used to reduce the frequency a given rule is chosen with.<br>This marker may only appear at the beginning of a rule.</td></tr>
-</tbody></table>
-		*/
-
-		/**
-		@PageName namegen_file_4
-		@PageFather namegen_file
-		@PageTitle Example structure
-		@PageDesc Consider this example structure. It does not contain syllables, but rather full names.
-<div class="code"><p>name "king" {
-  syllablesStart = "Alexander, Augustus, Casimir, Henry, John, Louis, Sigismund,"
-    "Stanislao, Stephen, Wenceslaus"
-  syllablesMiddle = "I, II, III, IV, V"
-  syllablesEnd = "Bathory, Herman, Jogaila, Lambert, of_Bohemia, of_France,"
-    "of_Hungary, of_Masovia, of_Poland, of_Valois, of_Varna, Probus,"
-    "Spindleshanks, Tanglefoot, the_Bearded, the_Black, the_Bold, the_Brave,"
-    "the_Chaste, the_Curly, the_Elbow-high, the_Exile, the_Great,"
-    "the_Jagiellonian, the_Just, the_Old, the_Pious, the_Restorer, the_Saxon,"
-    "the_Strong, the_Wheelwright, the_White, Vasa, Wrymouth"
-  rules = "%50$s, $s_$m, $s_$50m_$e"
-}</p></div>
-
-The above structure only uses three syllable lists and has three different rules. Let's analyse them one by one.
-
-%50$s - this will simply output a random Start syllable, but this rule is not intended to be picked with the same frequency as the others, so the frequency marker at the beginning ("%50") ensures that 50% of the time this syllable will be rejected and a different one will be picked.
-
-$s_$m - this will output a Start syllable and a Middle syllable, separated with a space.
-
-$s_$50m_$e - This will output a Start syllable, followed by a Middle syllable, followed by an End sylable, all separated with spaces. However, the Middle syllable has only 50% chance of appearing at all, so 50% of the time the rule will actually produce a Start syllable followed directly by an End syllable, separated with a space.
-
-As you may have noticed, the third rule may produce a double space if the Middle syllable is not chosen. You do not have to worry about such cases, as the generator will automatically reduce all double spaces to single spaces, and leading/ending spaces will be removed completely.
-
-Output from this example set would contain kings' names based on the names of real monarchs of Poland. Have a look at the sample:
-<div class="code"><p>Alexander IV
-Alexander
-Sigismund
-Stanislao V
-Stanislao
-Henry I of Poland
-Augustus V
-Stanislao I the Pious
-Sigismund IV the Brave
-John the Great
-Henry the Old
-John the Bold
-Stanislao II the Saxon
-Wenceslaus of France
-John Probus
-Louis V
-Wenceslaus Lambert
-Stanislao Spindleshanks
-Henry Herman
-Alexander the Old
-Louis V the Curly
-Wenceslaus II
-Augustus IV
-Alexander V
-Augustus Probus
-</p></div>
-		*/
-};
-
-#endif
--- a/include/noise.hpp
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_PERLIN_HPP
-#define _TCOD_PERLIN_HPP
-
-#include "noise_defaults.h"
-
-/**
- @PageName noise
- @PageCategory Base toolkits
- @PageTitle Noise generator
- @PageDesc This toolkit provides several functions to generate Perlin noise and other derived noises. It can handle noise functions from 1 to 4 dimensions.
- @FuncDesc
-	Usage example:
-	1D noise : the variation of a torch intensity
-	2D fbm : heightfield generation or clouds
-	3D fbm : animated smoke
-	If you don't know what is Perlin noise and derived functions, or what is the influence of the different fractal parameters, check the Perlin noise sample included with the library.
-	<table width="800px" class="none">
-		<tr><td align="center">Simplex noise, fbm, turbulence</td>
-		<td align="center"><img border="1" src="simplex.png"></td>
-		<td align="center"><img border="1" src="fbm_simplex.png"></td>
-		<td align="center"><img border="1" src="turbulence_simplex.png"></td></tr>
-		<tr><td align="center">Perlin noise, fbm, turbulence</td>
-		<td align="center"><img border="1" src="perlin.png"></td>
-		<td align="center"><img border="1" src="fbm_perlin.png"></td>
-		<td align="center"><img border="1" src="turbulence_perlin.png"></td></tr>
-		<tr><td align="center">Wavelet noise, fbm, turbulence</td>
-		<td align="center"><img border="1" src="wavelet.png"></td>
-		<td align="center"><img border="1" src="fbm_wavelet.png"></td>
-		<td align="center"><img border="1" src="turbulence_wavelet.png"></td></tr>
-	</table>
-	<h6>Noise functions relative times</h6>
-
-	For example, in 4D, Perlin noise is 17 times slower than simplex noise.
-	<table border="1">
-		<tr><td></td><td>1D</td><td>2D</td><td>3D</td><td>4D</td></tr>
-		<tr><td>simplex</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
-		<tr><td>Perlin</td><td>1.3</td><td>4</td><td>5</td><td>17</td></tr>
-		<tr><td>wavelet</td><td>53</td><td>32</td><td>14</td><td>X</td></tr>
-	</table>
- */
-class TCODLIB_API TCODNoise {
-	public :
-		/**
-		@PageName noise_init
-		@PageFather noise
-		@PageTitle Creating a noise generator
-		@FuncDesc Those functions initialize a noise generator from a number of dimensions (from 1 to 4), some fractal parameters and a random number generator.
-			The C++ version provides several constructors. When the hurst and lacunarity parameters are omitted, default values (TCOD_NOISE_DEFAULT_HURST = 0.5f and TCOD_NOISE_DEFAULT_LACUNARITY = 2.0f) are used.
-		@Cpp
-			TCODNoise::TCODNoise(int dimensions, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-			TCODNoise::TCODNoise(int dimensions, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-		@C TCOD_noise_t TCOD_noise_new(int dimensions, float hurst, float lacunarity, TCOD_random_t random)
-		@Py noise_new(dimensions, hurst=TCOD_NOISE_DEFAULT_HURST, lacunarity=TCOD_NOISE_DEFAULT_LACUNARITY, random=0)
-		@C#
-			TCODNoise::TCODNoise(int dimensions)
-			TCODNoise::TCODNoise(int dimensions, TCODRandom random)
-			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity)
-			TCODNoise::TCODNoise(int dimensions, float hurst, float lacunarity, TCODRandom random)
-		@Param dimensions	From 1 to 4.
-		@Param hurst	For fractional brownian motion and turbulence, the fractal Hurst exponent. You can use the default value TCOD_NOISE_DEFAULT_HURST = 0.5f.
-		@Param lacunarity	For fractional brownian motion and turbulence, the fractal lacunarity. You can use the default value TCOD_NOISE_DEFAULT_LACUNARITY = 2.0f.
-		@Param random	A random number generator obtained with the Mersenne twister toolkit or NULL to use the default random number generator.
-		@CppEx
-			// 1 dimension generator
-			TCODNoise * noise1d = new TCODNoise(1);
-			// 2D noise with a predefined random number generator
-			TCODRandom *myRandom = new TCODRandom();
-			TCODNoise *noise2d = new TCODNoise(2,myRandom);
-			// a 3D noise generator with a specific fractal parameters
-			TCODNoise *noise3d = new TCODNoise(3,0.7f,1.4f);
-		@CEx
-			// 1 dimension generator
-			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			// 2D noise with a predefined random number generator
-			TCOD_random_t my_random = TCOD_random_new();
-			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,my_random);
-			// a 3D noise generator with a specific fractal parameters
-			TCOD_noise_t noise3d = TCOD_noise_new(3,0.7f, 1.4f,NULL);
-		@PyEx
-			# 1 dimension generator
-			noise1d = libtcod.noise_new(1)
-			# 2D noise with a predefined random number generator
-			my_random = libtcod.random_new();
-			noise2d = libtcod.noise_new(2,libtcod.NOISE_DEFAULT_HURST, libtcod.NOISE_DEFAULT_LACUNARITY,my_random)
-			# a 3D noise generator with a specific fractal parameters
-			noise3d = libtcod.noise_new(3, 0.7, 1.4)
-		*/
-		TCODNoise(int dimensions, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-		TCODNoise(int dimensions, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-		TCODNoise(int dimensions, float hurst, float lacunarity, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-		TCODNoise(int dimensions, float hurst, float lacunarity, TCODRandom *random, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-
-		/**
-		@PageName noise_init
-		@FuncDesc To release ressources used by a generator, use those functions :
-		@Cpp TCODNoise::~TCODNoise()
-		@C void TCOD_noise_delete(TCOD_noise_t noise)
-		@Py noise_delete(noise)
-		@C# void TCODNoise::Dispose()
-		@Param noise	In the C and python versions, the generator handler, returned by the initialization function.
-		@CppEx
-			// create a generator
-			TCODNoise *noise = new TCODNoise(2);
-			// use it
-			...
-			// destroy it
-			delete noise;
-		@CEx
-			// create a generator
-			TCOD_noise_t noise = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAUT_LACUNARITY, NULL);
-			// use it
-			...
-			// destroy it
-			TCOD_noise_delete(noise);
-		@PyEx
-			# create a generator
-			noise = libtcod.noise_new(2,litbcod.NOISE_DEFAULT_HURST, litbcod.NOISE_DEFAUT_LACUNARITY, 0)
-			# use it
-			...
-			# destroy it
-			litbcod.noise_delete(noise)
-		*/
-		virtual ~TCODNoise();
-
-   		/**
-   		@PageName noise_setType
-		@PageFather noise
-		@PageTitle Choosing a noise type
-		@FuncTitle Choosing a noise type
-		@FuncDesc Use this function to define the default algorithm used by the noise functions. 
-			The default algorithm is simplex. It's much faster than Perlin, especially in 4 dimensions. It has a better contrast too.
-		@Cpp void TCODNoise::setType(TCOD_noise_type_t type)
-		@C void TCOD_noise_set_type(TCOD_noise_t noise, TCOD_noise_type_t type)
-		@Py noise_set_type(noise, type)
-		@C# void TCODNoise::setType(type)
-		@Param noise	In the C version, the generator handler, returned by the initialization function.
-		@Param type		The algorithm to use, either TCOD_NOISE_SIMPLEX, TCOD_NOISE_PERLIN or TCOD_NOISE_WAVELET.
-		@CppEx
-			TCODNoise * noise1d = new TCODNoise(1);
-			noise1d->setType(TCOD_NOISE_PERLIN);
-		@CEx
-			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			TCOD_noise_set_type(noise1d,TCOD_NOISE_PERLIN);
-		@PyEx
-			noise1d = libtcod.noise_new(1)
-			libtcod.noise_set_type(noise1d,libtcod.NOISE_PERLIN)
-   		*/
-		void setType (TCOD_noise_type_t type);
-   		/**
-   		@PageName noise_get
-		@PageFather noise
-		@PageTitle Getting flat noise
-		@FuncDesc This function returns the noise function value between -1.0 and 1.0 at given coordinates.
-		@Cpp float TCODNoise::get(float *f, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-		@C	float TCOD_noise_get(TCOD_noise_t noise, float *f)
-float TCOD_noise_get_ex(TCOD_noise_t noise, float *f, TCOD_noise_type_t type)
-		@Py noise_get(noise, f, type=NOISE_DEFAULT)
-		@C# float TCODNoise::get(float[] f, type=NoiseDefault)
-		@Param noise	In the C version, the generator handler, returned by the initialization function.
-		@Param f	An array of coordinates, depending on the generator dimensions (between 1 and 4). The same array of coordinates will always return the same value.
-		@Param type	The algorithm to use. If not defined, use the default one (set with setType or simplex if not set) 
-		@CppEx
-			// 1d noise
-			TCODNoise * noise1d = new TCODNoise(1);
-			float p=0.5f;
-			// get a 1d simplex value
-			float value = noise1d->get(&p);
-			// 2d noise
-			TCODNoise * noise2d = new TCODNoise(2);
-			float p[2]={0.5f,0.7f};
-			// get a 2D Perlin value
-			float value = noise2d->get(p, TCOD_NOISE_PERLIN);
-		@CEx
-			// 1d noise
-			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			float p=0.5f;
-			// get a 1d simplex value
-			float value = TCOD_noise_get(noise1d,&p);
-			// 2d noise
-			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			float p[2]={0.5f,0.7f};
-			// get a 2d perlin value
-			float value = TCOD_noise_get_ex(noise2d,p,TCOD_NOISE_PERLIN);
-		@PyEx
-			# 1d noise
-			noise1d = libtcod.noise_new(1)
-			# get a 1d simplex value
-			value = libtcod.noise_get(noise1d,[0.5])
-			# 2d noise
-			noise2d = libtcod.noise_new(2)
-			# get a 2d perlin value
-			value = libtcod.noise_get(noise2d,[0.5,0.7], libtcod.NOISE_PERLIN)
-   		*/
-		float get(float *f, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-		/**
-		@PageName noise_get_fbm
-		@PageFather noise
-		@PageTitle Getting fbm noise
-		@FuncDesc This function returns the fbm function value between -1.0 and 1.0 at given coordinates, using fractal hurst and lacunarity defined when the generator has been created.
-		@Cpp float TCODNoise::getFbm(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-		@C	float TCOD_noise_get_fbm(TCOD_noise_t noise, float *f, float octaves)
-float TCOD_noise_get_fbm(TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t type)
-		@Py noise_get_fbm(noise, f, octaves, type=NOISE_DEFAULT)
-		@C# float TCODNoise::getBrownianMotion(float[] f, float octaves, type=NoiseDefault)
-		@Param noise	In the C version, the generator handler, returned by the initialization function.
-		@Param f	An array of coordinates, depending on the generator dimensions (between 1 and 4). The same array of coordinates will always return the same value.
-		@Param octaves	Number of iterations. Must be < TCOD_NOISE_MAX_OCTAVES = 128
-		@Param type	The algorithm to use. If not defined, use the default one (set with setType or simplex if not set) 
-		@CppEx
-			// 1d fbm
-			TCODNoise * noise1d = new TCODNoise(1);
-			float p=0.5f;
-			// get a 1d simplex fbm
-			float value = noise1d->getFbm(&p,32.0f);
-			// 2d fbm
-			TCODNoise * noise2d = new TCODNoise(2);
-			float p[2]={0.5f,0.7f};
-			// get a 2d perlin fbm
-			float value = noise2d->getFbm(p,32.0f, TCOD_NOISE_PERLIN);
-		@CEx
-			// 1d fbm
-			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			float p=0.5f;
-			// get a 1d simplex fbm
-			float value = TCOD_noise_get_fbm(noise1d,&p,32.0f);
-			// 2d fbm
-			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			float p[2]={0.5f,0.7f};
-			// get a 2d perlin fbm
-			float value = TCOD_noise_get_fbm_ex(noise2d,p,32.0f,TCOD_NOISE_PERLIN);
-		@PyEx
-			# 1d noise
-			noise1d = libtcod.noise_new(1)
-			# 1d simplex fbm
-			value = libtcod.noise_get_fbm(noise1d,[0.5],32.0)
-			# 2d noise
-			noise2d = libtcod.noise_new(2)
-			# 2d perlin fbm
-			value = libtcod.noise_get_fbm(noise2d,[0.5,0.7],32.0, libtcod.NOISE_PERLIN)
-		*/
-		float getFbm(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-		/**
-		@PageName noise_get_turbulence
-		@PageFather noise
-		@PageTitle Getting turbulence
-		@FuncDesc This function returns the turbulence function value between -1.0 and 1.0 at given coordinates, using fractal hurst and lacunarity defined when the generator has been created.
-		@Cpp float TCODNoise::getTurbulence(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT)
-		@C	float TCOD_noise_get_turbulence(TCOD_noise_t noise, float *f, float octaves)
-float TCOD_noise_get_turbulence_ex(TCOD_noise_t noise, float *f, float octaves, TCOD_noise_type_t)
-		@Py noise_get_turbulence(noise, f, octaves, type=NOISE_DEFAULT)
-		@C# float TCODNoise::getTurbulence(float[] f, float octaves, type=NoiseDefault)
-		@Param noise	In the C version, the generator handler, returned by the initialization function.
-		@Param f	An array of coordinates, depending on the generator dimensions (between 1 and 4). The same array of coordinates will always return the same value.
-		@Param octaves	Number of iterations. Must be < TCOD_NOISE_MAX_OCTAVES = 128
-		@CppEx
-			// 1d fbm
-			TCODNoise * noise1d = new TCODNoise(1);
-			float p=0.5f;
-			// a 1d simplex turbulence
-			float value = noise1d->getTurbulence(&p,32.0f);
-			// 2d fbm
-			TCODNoise * noise2d = new TCODNoise(2);
-			float p[2]={0.5f,0.7f};
-			// a 2d perlin turbulence
-			float value = noise2d->getTurbulence(p,32.0f, TCOD_NOISE_PERLIN);
-		@CEx
-			// 1d fbm
-			TCOD_noise_t noise1d = TCOD_noise_new(1,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			float p=0.5f;
-			// a 1d simplex turbulence
-			float value = TCOD_noise_get_turbulence(noise1d,&p,32.0f);
-			// 2d fbm
-			TCOD_noise_t noise2d = TCOD_noise_new(2,TCOD_NOISE_DEFAULT_HURST, TCOD_NOISE_DEFAULT_LACUNARITY,NULL);
-			float p[2]={0.5f,0.7f};
-			// a 2d perlin turbulence
-			float value = TCOD_noise_get_turbulence_ex(noise2d,p,32.0f, TCOD_NOISE_PERLIN);
-		@PyEx
-			# 1d noise
-			noise1d = libtcod.noise_new(1)
-			# 1d simplex turbulence
-			value = libtcod.noise_get_turbulence(noise1d,[0.5],32.0)
-			# 2d noise
-			noise2d = libtcod.noise_new(2)
-			# 2d perlin turbulence
-			value = libtcod.noise_get_turbulence(noise2d,[0.5,0.7],32.0,libtcod.NOISE_PERLIN)
-		*/
-		float getTurbulence(float *f, float octaves, TCOD_noise_type_t type = TCOD_NOISE_DEFAULT);
-
-	protected :
-		friend class TCODLIB_API TCODHeightMap;
-		TCOD_noise_t data;
-};
-
-#endif
--- a/include/parser.hpp
+++ /dev/null
@@ -1,671 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_PARSER_HPP
-#define _TCOD_PARSER_HPP
-
-/**
-@PageName parser
-@PageTitle File parser
-@PageCategory Base toolkits
-@PageDesc This toolkit provides an easy way to parse complex text configuration files. It has two main advantages compared to a standard XML SAX parser:
-	* The configuration file format is more human readable than XML
-	* The parser knows some data types that it automatically converts to C variables (see <a href="parser_types.html">Standard data types</a>)
-*/
-
-/**
-@PageName parser_format
-@PageFather parser
-@PageTitle The libtcod config file format
-@FuncTitle Comments
-@FuncDesc Your file can contain single line or multi-line comments :
-<div class="code"><pre>// This is a single line comment
-/<span>*</span>
-   This is a
-   multi-line comment
-*<span>/</span>
-</pre></div>
-Multi-line comments can be nested :
-<div class="code"><pre>/<span>*</span>
-   This is a
-   multi-line comment containing another
-   /<span>*</span>
-&nbsp;&nbsp;&nbsp;&nbsp;multi-line
-&nbsp;&nbsp;&nbsp;&nbsp;comment
-   *<span>/</span>
-*<span>/</span>
-</pre></div>
-The parser is not sensible to space characters, tabulations or carriage return except inside strings.
-*/
-/**
-@PageName parser_format
-@FuncTitle Structures
-@FuncDesc The libtcod config file format is basically a list of structures. A structure has a type, an optional name and contains properties. The type of the structure defines which properties are allowed / mandatory.
-<div class="code"><pre>item_type "blade" {            // structure's type : 'item_type'. structure's name : 'blade'
-	cost=300                   // an integer property
-	weight=3.5                 // a float property
-	deal_damage=true           // a boolean property
-	damages="3d6+2"            // a dice property
-	col="#FF0000"              // a color property, using #RRGGBB syntax
-	damaged_color="128,96,96"  // another color property, using rrr,ggg,bbb syntax
-	damage_type="slash"        // a string property
-	description="This is a long"
-	            "description." // a multi-line string property
-	abstract                   // a flag (simplified boolean property)
-        intList= [ 1,2,3 ]         // a list of int values
-        floatList= [ 1.0,2,3.5 ]   // a list of float values
-        stringList= [ "string1","string2","string3" ]         // a list of string values
-}
-</pre></div>
-A structure can also contain other structures either of the same type, or structures of another type :
-<div class="code"><pre>item_type "blade" {
-	item_type "one-handed blades" {
-		// the item_type "blade" contains another item_type named "one-handed blades"
-	}
-	item_type "two-handed blades" {
-		// the item_type "blade" contains another item_type named "two-handed blades"
-	}
-	feature "damage" {
-		// the item_type "blade" contains another structure, type "feature", name "damage"
-	}
-}
-</pre></div>
-Sometimes, you don't know the list of properties at compile-time. Fortunately, since libtcod 1.5.1, you can add auto-declaring properties in the file, using one of the type keywords :
-<div class="code"><pre>item_type "blade" {
-	bool deal_damage=true
-	char character='D'
-	int cost=300
-	float weight=3.5
-	string damage_type="slash"
-	color col="#FF0000"
-	dice damages="3d6+2"
-	int[] intList= [ 1,2,3 ]
-	float[] floatList= [ 1.0,2,3.5 ]
-	string[] stringList= [ "string1","string2","string3" ]
-}
-</pre></div>
-The properties declared with this syntax were not previously declared for the structure item_type. But since the type is specified, the parser won't reject them. Instead, it will add the property declaration to the structure dynamically (when it parses the file).
-You can also dynamically create new structures and sub-structures with the struct keyword :
-<div class="code"><pre>item_type "blade" {
-    struct component {
-	    string name="blade"
-		float weight=1.0
-	}
-}
-</div>
-With this syntax, you don't need to declare the "component" structure at all in the parser. It will be dynamically registered as the file is parsed.
-*/
-
-class TCODLIB_API TCODParser;
-class TCODLIB_API TCODParserStruct;
-class TCODLIB_API ITCODParserListener;
-
-class TCODLIB_API TCODParser {
-public :
-	/**
-	@PageName parser_str
-	@PageTitle Defining the file syntax
-	@PageFather parser
-	@FuncTitle Creating a parser
-	@FuncDesc Use this function to create a generic parser. Then you'll specialize this parser by defining the structures it can read.
-	@Cpp TCODParser::TCODParser()
-	@C TCOD_parser_t TCOD_parser_new()
-	@Py parser_new()
-	*/
-	TCODParser();
-
-	/**
-	@PageName parser_str
-	@FuncTitle Registering a new structure type
-	@Cpp TCODParserStruct *TCODParser::newStructure(const char *name)
-	@C TCOD_parser_struct_t TCOD_parser_new_struct(TCOD_parser_t parser, char *name)
-	@Py parser_new_struct(parser, name)
-	@Param parser	In the C version, the parser handler, returned by TCOD_parser_new.
-	@Param name	The name of the structure type (in the example, this would be "item_type").
-	@CppEx
-		TCODParser parser();
-		TCODParserStruct *itemTypeStruct = parser.newStructrue("item_type");
-	@CEx
-		TCOD_parser_t parser = TCOD_parser_new();
-		TCOD_parser_struct_t item_type_struct = TCOD_parser_new_struct(parser, "item_type");
-	@PyEx
-		parser=libtcod.parser_new()
-		item_type_struct = libtcod.parser_new_struct(parser, "item_type")
-	*/
-	TCODParserStruct *newStructure(const char *name);
-
-	// register a new custom type
-	TCOD_value_type_t newCustomType(TCOD_parser_custom_t custom_type_parser);
-
-	/**
-	@PageName parser_run
-	@PageFather parser
-	@PageTitle Running the parser
-	@FuncTitle Running the parser
-	@FuncDesc Once you defined all the structure types and created your listener, you can start the actual parsing of the file :
-	@Cpp void TCODParser::run(const char *filename, ITCODParserListener *listener = NULL)
-	@C void TCOD_parser_run(TCOD_parser_t parser, const char *filename, TCOD_parser_listener_t *listener)
-	@Py parser_run(parser, filename, listener=0)
-	@Param parser	In the C version, the parser handler, returned by TCOD_parser_new.
-	@Param filename	The name of the text file to parse, absolute or relative to current directory.
-	@Param listener	The listener containing the callbacks. Use NULL for the default listener
-	@Cpp myParser.run("config.txt",new MyListener());
-	@C TCOD_parser_run(my_parser,"config.txt", my_listener);
-	@Py libtcod.parser_run(my_parser,"config.txt", MyListener())
-	*/
-	void run(const char *filename, ITCODParserListener *listener = NULL);
-
-	/**
-	@PageName parser_run
-	@FuncTitle Destroying the parser
-	@FuncDesc Once you've done with the file parsing, you can release the resources used by the parser :
-	@Cpp TCODParser::~TCODParser()
-	@C void TCOD_parser_delete(TCOD_parser_t parser)
-	@Py parser_delete(parser)
-	@Param parser	In the C version, the parser handler, returned by TCOD_parser_new.
-	*/
-
-	// error during parsing. can be called by the parser listener
-	void error(const char *msg, ...);
-#ifdef TCOD_VISUAL_STUDIO
-    // silly stuff to avoid VS warning
-	#pragma warning(disable: 4251)
-#endif
-	TCODList<TCODParserStruct *> defs;
-#ifdef TCOD_VISUAL_STUDIO
-	// restore warning again
-	#pragma warning(default: 4251)
-#endif
-
-	bool getBoolProperty(const char *name) const;
-	int getIntProperty(const char *name) const;
-	int getCharProperty(const char *name) const;
-	float getFloatProperty(const char *name) const;
-	TCODColor getColorProperty(const char *name) const;
-	TCOD_dice_t getDiceProperty(const char *name) const;
-	const char * getStringProperty(const char *name) const;
-	void * getCustomProperty(const char *name) const;
-	TCOD_list_t getListProperty(const char *name, TCOD_value_type_t type) const;
-private :
-	bool parseEntity(TCODParserStruct *def, ITCODParserListener *listener);
-	TCOD_parser_t data;
-};
-
-// a parser structure
-class TCODLIB_API TCODParserStruct {
-public :
-	/**
-	@PageName parser_str
-	@FuncTitle Adding a new flag
-	@FuncDesc Use this function to add a flag property to a structure type. A flag is a simplified boolean property. It cannot be mandatory: either it's present and it's true, or it's absent and it's false.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
-	@Cpp TCODParserStruct* TCODParserStruct::addFlag(const char *name)
-	@C void TCOD_struct_add_flag(TCOD_parser_struct_t str,char *name)
-	@Py struct_add_flag(str,name)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param name	The name of the flag (in the example, this would be "abstract").
-	@CppEx itemTypeStruct->addFlag("abstract")->addFlag("static");
-	@CEx TCOD_struct_add_flag(item_type_struct, "abstract");
-	@PyEx libtcod.struct_add_flag(item_type_struct, "abstract")
-	*/
-	TCODParserStruct* addFlag(const char *propname);
-
-	/**
-	@PageName parser_str
-	@FuncTitle Adding a new property
-	@FuncDesc Use this function to add a standard property to a structure type. Check standard property types here.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
-	@Cpp TCODParserStruct* TCODParserStruct::addProperty(const char *name, TCOD_value_type_t type, bool mandatory)
-	@C void TCOD_struct_add_property(TCOD_parser_struct_t str, char *name, TCOD_value_type_t type, bool mandatory)
-	@Py struct_add_property(str, name, type, mandatory)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param name	The name of the property (in the example, this would be "cost" or "damage" or ...).
-	@Param type	The type of the property. It can be a standard type (see <a href="parser_types.html">this</a>).
-	@Param mandatory	Is this property mandatory? If true and the property is not defined in the file, the parser will raise an error.
-	@CppEx
-		itemTypeStruct->addProperty("cost",TCOD_TYPE_INT,true)
-		    ->addProperty("weight",TCOD_TYPE_FLOAT,true)
-		    ->addProperty("deal_damage",TCOD_TYPE_BOOL,true)
-		    ->addProperty("damaged_color",TCOD_TYPE_COLOR,true);
-	@CEx
-		TCOD_struct_add_property(item_type_struct, "cost", TCOD_TYPE_INT, true);
-		TCOD_struct_add_property(item_type_struct, "damages", TCOD_TYPE_DICE, true);
-		TCOD_struct_add_property(item_type_struct, "color", TCOD_TYPE_COLOR, true);
-		TCOD_struct_add_property(item_type_struct, "damaged_color", TCOD_TYPE_COLOR, true);
-	@PyEx
-		libtcod.struct_add_property(item_type_struct, "cost", libtcod.TYPE_INT, True)
-		libtcod.struct_add_property(item_type_struct, "damages", libtcod.TYPE_DICE, True)
-		libtcod.struct_add_property(item_type_struct, "color", libtcod.TYPE_COLOR, True)
-		libtcod.struct_add_property(item_type_struct, "damaged_color", libtcod.TYPE_COLOR, True)
-	*/
-	TCODParserStruct* addProperty(const char *propname, TCOD_value_type_t type, bool mandatory);
-
-	/**
-	@PageName parser_str
-	@FuncTitle Adding a new value-list property
-	@FuncDesc A value-list property is a string property for which we define the list of allowed values. The parser will raise an error if the file contains an unauthorized value for this property.
-		The first value-list property that you add to a structure type will have the TCOD_TYPE_VALUELIST00 type. The next TCOD_TYPE_VALUELIST01. You can define up to 16 value list property for each structure type. The last one has the type TCOD_TYPE_VALUELIST15.
-		You must provide a value list as a NULL terminated array of strings.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
-	@Cpp TCODParserStruct* TCODParserStruct::addValueList(const char *name, const char **value_list, bool mandatory)
-	@C void TCOD_struct_add_value_list(TCOD_parser_struct_t str, char *name, char **value_list, bool mandatory)
-	@Py struct_add_value_list(str, name, value_list, mandatory)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param name	The name of the property (in the example, this would be "damage_type").
-	@Param value_list	The list of allowed strings.
-	@Param mandatory	Is this property mandatory ? If true and the property is not defined in the file, the parser will raise an error.
-	@CppEx
-		static const char *damageTypes[] = { "slash", "pierce", "bludgeon", NULL }; // note the ending NULL
-		itemTypeStruct->addValueList("damage_type", damageTypes, true);
-	@CEx
-		static const char *damage_types[] = { "slash", "pierce", "bludgeon", NULL };
-		TCOD_struct_add_value_list(item_type_struct, "damage_type", damage_types, true);
-	@PyEx
-		damage_types = [ "slash", "pierce", "bludgeon" ]
-		litbcod.struct_add_value_list(item_type_struct, "damage_type", damage_types, True)
-	*/
-	TCODParserStruct* addValueList(const char *propname, const char **value_list, bool mandatory);
-
-	/**
-	@PageName parser_str
-	@FuncTitle Adding a new list property
-	@FuncDesc Use this function to add a list property to a structure type.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
-	@Cpp TCODParserStruct* TCODParserStruct::addListProperty(const char *name, TCOD_value_type_t type, bool mandatory)
-	@C void TCOD_struct_add_list_property(TCOD_parser_struct_t str, char *name, TCOD_value_type_t type, bool mandatory)
-	@Py struct_add_list_property(str, name, type, mandatory)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param name	The name of the property (in the example, this would be "cost" or "damages" or ...).
-	@Param type	The type of the list elements. It must be a standard type (see <a href="parser_types.html">this</a>). It cannot be TCOD_TYPE_LIST.
-	@Param mandatory	Is this property mandatory ? If true and the property is not defined in the file, the parser will raise an error.
-	@CppEx
-		itemTypeStruct->addListProperty("intList",TCOD_TYPE_INT,true)
-		    ->addListProperty("floatList",TCOD_TYPE_FLOAT,true)
-		    ->addListProperty("stringList",TCOD_TYPE_STRING,true);
-	@CEx
-		TCOD_struct_add_list_property(item_type_struct, "intList", TCOD_TYPE_INT, true);
-		TCOD_struct_add_list_property(item_type_struct, "floatList", TCOD_TYPE_FLOAT, true);
-		TCOD_struct_add_list_property(item_type_struct, "stringList", TCOD_TYPE_STRING, true);
-	@PyEx
-		libtcod.struct_add_list_property(item_type_struct, "intList", libtcod.TYPE_INT, True)
-		libtcod.struct_add_list_property(item_type_struct, "floatList", libtcod.TYPE_FLOAT, True)
-		libtcod.struct_add_list_property(item_type_struct, "stringList", libtcod.TYPE_STRING, True)
-	*/
-	TCODParserStruct* addListProperty(const char *propname, TCOD_value_type_t type, bool mandatory);
-
-	/**
-	@PageName parser_str
-	@FuncTitle Adding a sub-structure
-	@FuncDesc A structure can contain others structures. You can tell the parser which structures are allowed inside one structure type with this function.<br />Note that in the C++ version, the function returns its parent object, allowing for chaining.
-	@Cpp TCODParserStruct* TCODParserStruct::addStructure(TCODParserStruct *sub_structure)
-	@C void TCOD_struct_add_structure(TCOD_parser_struct_t str, TCOD_parser_struct_t sub_structure)
-	@Py struct_add_structure(str, sub_structure)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param sub_structure	The structure type that can be embedded.
-	@CppEx
-		// The item_type structure can contain itself
-		itemTypeStruct->addStructure(itemTypeStruct);
-	@CEx TCOD_struct_add_value_list(item_type_struct, item_type_struct);
-	@PyEx libtcod.struct_add_value_list(item_type_struct, item_type_struct)
-	*/
-	TCODParserStruct* addStructure(TCODParserStruct *sub_entity);
-
-	/**
-	@PageName parser_str
-	@FuncTitle Getting a structure type's name
-	@FuncDesc You can retrieve the name of the structure type with these functions. Warning ! Do not confuse the structure type's name with the structure's name :
-		<div class="code"><p>item_type "sword" { ... }</p></div>
-		Here, the structure type's name is "item_type", the structure name is "sword". Obviously, the structure name cannot be retrieved from the TCODParserStruct object because it's only known at "runtime" (while parsing the file).
-	@Cpp const char *TCODParserStruct::getName() const
-	@C const char *TCOD_struct_get_name(TCOD_parser_struct_t str)
-	@Py struct_get_name(str)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@CppEx const char *structName = itemTypeStruct->getName(); // returns "item_type"
-	@CEx const char *struct_name = TCOD_struct_get_name(item_type_struct);
-	@PyEx struct_name = libtcod.struct_get_name(item_type_struct)
-	*/
-	const char *getName() const;
-
-	/**
-	@PageName parser_str
-	@FuncTitle Checking if a property is mandatory
-	@FuncDesc You can know if a property is mandatory :
-	@Cpp bool TCODParserStruct::isPropertyMandatory(const char *name) const
-	@C bool TCOD_struct_is_mandatory(TCOD_parser_struct_t str,const char *name)
-	@Py struct_is_mandatory(str,name)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param name	The name of the property, as defined when you called addProperty or addValueList or addListProperty.
-	@CppEx bool costMandatory = itemTypeStruct->isPropertyMandatory("cost");
-	@CEx bool cost_mandatory = TCOD_struct_is_mandatory(item_type_struct, "cost");
-	@PyEx cost_mandatory = libtcod.struct_is_mandatory(item_type_struct, "cost")
-	*/
-	bool isPropertyMandatory(const char *propname) const;
-
-	/**
-	@PageName parser_str
-	@FuncTitle Retrieving the type of a property
-	@FuncDesc You get the type of a property :
-		In the case of a list property, the value returned is a bitwise or of TCOD_TYPE_LIST and the list element's type. For example, for a list of int, it will return TCOD_TYPE_LIST | TCOD_TYPE_INT.
-	@Cpp TCOD_value_type_t TCODParserStruct::getPropertyType(const char *name) const
-	@C TCOD_value_type_t TCOD_struct_get_type(TCOD_parser_struct_t str, const char *name)
-	@Py struct_get_type(str, name)
-	@Param str	In the C version, the structure handler, returned by TCOD_parser_new_struct.
-	@Param name	The name of the property, as defined when you called addProperty or addValueList or addListProperty.
-	@CppEx
-		TCOD_value_type_t costType = itemTypeStruct->getPropertyType("cost"); // returns TCOD_TYPE_INT
-		TCOD_value_type_t intListType = itemTypeStruct->getPropertyType("intList"); // returns TCOD_TYPE_LIST|TCOD_TYPE_INT
-	@CEx TCOD_value_type_t cost_type = TCOD_struct_get_type(item_type_struct, "cost");
-	@PyEx cost_type = libtcod.struct_get_type(item_type_struct, "cost")
-	*/
-	TCOD_value_type_t getPropertyType(const char *propname) const;
-
-// private stuff
-	TCOD_parser_struct_t data;
-};
-
-/**
- @PageName parser_run
- @FuncTitle Creating a listener
- @FuncDesc For basic config files, you don't have to write a listener. Instead, use the default listener. The parser uses a SAX-like approach during the parsing of the file. This means that the whole file is not stored in memory in a tree structure. Instead, it works like a stream parser and raises events. Each event has an associated callback that is provided by a listener :
- @Cpp
-	class ITCODParserListener {
-	public :
-		virtual bool parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)=0;
-		virtual bool parserFlag(TCODParser *parser,const char *name)=0;
-		virtual bool parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)=0;
-		virtual bool parserEndStruct(TCODParser *parser,const TCODParserStruct *str, const char *name)=0;
-		virtual void error(const char *msg) = 0;
-	};
- @C
-	typedef struct {
-		bool (*new_struct)(TCOD_parser_struct_t str,const char *name);
-		bool (*new_flag)(const char *name);
-		bool (*new_property)(const char *name, TCOD_value_type_t type, TCOD_value_t value);
-		bool (*end_struct)(TCOD_parser_struct_t str, const char *name);
-		void (*error)(const char *msg);
-	} TCOD_parser_listener_t;
- @Py
-	class ParserListener :
-		def new_struct(str,name) : ...
-		def new_flag(name) : ...
-		def new_property(name,type,value) : ...
-		def end_struct(self, struct, name) : ...
-		def error(msg) : ...
-*/
-/**
- @PageName parser_run
- @FuncDesc Before running the parser, you have to build a listener :
- @Cpp
-	class MyListener : public ITCODParserListener {
-		bool parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name) {
-			printf ("new structure type '%s' with name '%s'\n",str->getname(),name ? name : "NULL");
-			return true;
-		}
-		bool parserFlag(TCODParser *parser,const char *name) {
-			printf ("found new flag '%s'\n",name);
-			return true;
-		}
-		bool parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value) {
-			printf ("found new property '%s'\n",name);
-			return true;
-		}
-		bool parserEndStruct(TCODParser *parser,const TCODParserStruct *str,const char *name) {
-			printf ("end of structure type '%s'\n",name);
-			return true;
-		}
-		void error(char *msg) {
-			fprintf(stderr,msg);
-			exit(1);
-		}
-	};
- @C
-	bool my_parser_new_struct(TCOD_parser_struct_t str, const char *name) {
-		printf ("new structure type '%s' with name '%s'\n",TCOD_struct_get_name(str),name ? name : "NULL");
-		return true;
-	}
-	bool my_parser_flag(const char *name) {
-		printf ("found new flag '%s'\n",name);
-		return true;
-	}
-	bool my_parser_property(const char *name, TCOD_value_type_t type, TCOD_value_t value) {
-		printf ("found new property '%s'\n",name);
-		return true;
-	}
-	bool my_parser_end_struct(TCOD_parser_struct_t str, const char *name) {
-		printf ("end of structure type '%s'\n",name);
-		return true;
-	}
-	void my_parser_error(const char *msg) {
-		fprintf(stderr,msg);
-		exit(1);
-	}
-	TCOD_parser_listener_t my_listener = {
-		my_parser_new_struct,
-		my_parser_flag,
-		my_parser_property,
-		my_parser_end_struct,
-		my_parser_error
-	};
- @Py
-    class MyListener:
-        def new_struct(self, struct, name):
-            print 'new structure type', libtcod.struct_get_name(struct),
-                  ' named ', name
-            return True
-        def new_flag(self, name):
-            print 'new flag named ', name
-            return True
-        def new_property(self,name, typ, value):
-            type_names = ['NONE', 'BOOL', 'CHAR', 'INT', 'FLOAT', 'STRING',
-                          'COLOR', 'DICE']
-            if typ == libtcod.TYPE_COLOR :
-                print 'new property named ', name,' type ',type_names[typ],
-                      ' value ', value.r, value.g, value.b
-            elif typ == libtcod.TYPE_DICE :
-                print 'new property named ', name,' type ',type_names[typ],
-                      ' value ', value.nb_rolls, value.nb_faces,
-                      value.multiplier, value.addsub
-            else:
-                print 'new property named ', name,' type ',type_names[typ],
-                      ' value ', value
-            return True
-        def end_struct(self, struct, name):
-            print 'end structure type', libtcod.struct_get_name(struct),
-                  ' named ', name
-            return True
-        def error(self,msg):
-            print 'error : ', msg
-            return True
- */
-
-// sax event listener
-class TCODLIB_API ITCODParserListener {
-public :
-	virtual ~ITCODParserListener(){}
-	/**
-	@PageName parser_run
-	@FuncTitle Handling 'newStruct' events
-	@FuncDesc This callback is called each time the parser find a new structure declaration in the file. Example :
-<div class="code"><pre>item_type "blade" { // <= newStruct event here
-	...
-}
-</pre></div>
-It must return true if everything is right, false if there is an error and the parser must exit.
-	@Cpp bool ITCODParserListener::parserNewStruct(TCODParser *parser,TCODParserStruct *str,const char *name)
-	@C bool new_struct(TCOD_parser_struct_t str,const char *name)
-	@Py new_struct(str,name)
-	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
-	@Param str	The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type".
-	@Param name	The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade".
-	*/
-	virtual bool parserNewStruct(TCODParser *parser,const TCODParserStruct *str,const char *name)=0;
-
-	/**
-	@PageName parser_run
-	@FuncTitle Handling 'newFlag' events
-	@FuncDesc This callback is called each time the parser find a new flag in the file. Example :
-<div class="code"><pre>item_type "blade" {
-	abstract  // <= newFlag event here
-}
-</pre></div>
-It must return true if everything is right, false if there is an error and the parser must exit.
-	@Cpp bool ITCODParserListener::parserFlag(TCODParser *parser,const char *name)
-	@C bool new_flag(const char *name)
-	@Py new_flag(name)
-	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
-	@Param name	The name of the flag. In the example, this would be "abstract".
-	*/
-	virtual bool parserFlag(TCODParser *parser,const char *name)=0;
-
-	/**
-	@PageName parser_run
-	@FuncTitle Handling 'newProperty' events
-	@FuncDesc This callback is called each time the parser find a new property in the file. Example :
-<div class="code"><pre>item_type "blade" {
-	abstract
-	cost=300 // <= newProperty event here
-}
-</pre></div>
-It must return true if everything is right, false if there is an error and the parser must exit.
-	@Cpp bool ITCODParserListener::parserProperty(TCODParser *parser,const char *name, TCOD_value_type_t type, TCOD_value_t value)
-	@C bool new_property(const char *name, TCOD_value_type_t type, TCOD_value_t value)
-	@Py new_property(name,type,value)
-	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
-	@Param name	The name of the property. In the example, this would be "cost".
-	@Param type	The type of the property as defined when you called addProperty or addValueList. In the example, this would be TCOD_TYPE_INT.
-	@Param value	The value of the property, stored in a generic value structure. In the example, we would have value.i == 300.
-In the case of a value-list property, the type would reflect the list id (between TCOD_TYPE_VALUELIST00 and TCOD_TYPE_VALUELIST15) and value.s would contain the actual string.
-	*/
-	virtual bool parserProperty(TCODParser *parser,const char *propname, TCOD_value_type_t type, TCOD_value_t value)=0;
-
-	/**
-	@PageName parser_run
-	@FuncTitle Handling 'endStruct' events
-	@FuncDesc This callback is called each time the parser find the end of a structure declaration in the file. Example :
-<div class="code"><pre>item_type "blade" {
-	...
-} // <= endStruct event here
-</pre></div>
-It must return true if everything is right, false if there is an error and the parser must exit.
-	@Cpp bool ITCODParserListener::parserEndStruct(TCODParser *parser,TCODParserStruct *str,const char *name)
-	@C bool end_struct(TCOD_parser_struct_t str,const char *name)
-	@Py end_struct(str,name)
-	@Param parser	In the C++ version, the parser object, returned by TCODParser constructor. It's used for error handling.
-	@Param str	The structure type. Can be used to retrieve the type's name with getName. In the example above, this would be "item_type".
-	@Param name	The name of the structure or NULL if no name is present in the file. In the example above, this would be "blade".
-	*/
-	virtual bool parserEndStruct(TCODParser *parser,const TCODParserStruct *str, const char *name)=0;
-
-	/**
-	@PageName parser_run
-	@FuncTitle Handling errors
-	@FuncDesc There are two kind of errors :
-    * Errors that are detected by the parser itself (malformed file, bad value syntax for a property, missing mandatory property in a structure, ...).
-    * Errors that you detect in your callbacks.
-	When the parser finds an error in the file, it will call the error callback and stop :
-	@Cpp void ITCODParserListener::error(const char *msg)
-	@C void error(const char *msg)
-	@Py error(msg)
-	@Param msg	The error message from the parser with the file name and the line number.
-	*/
-
-	/**
-	@PageName parser_run
-	@FuncDesc If you find an error in your callback, you have to call the parser error function. It will add the file name and line number to your error message, and then call your error callback :
-The code in the example below will result in your error callback called with the following string :
-"error in &lt;filename&gt; line &lt;line_number&gt; : Bad cost value %d. Cost must be between 0 and 1000"
-	@Cpp void TCODParser::error(const char *msg, ...)
-	@C void TCOD_parser_error(const char *msg, ...)
-	@Py parser_error(msg)
-	@Param msg	printf-like format string for your error message.
-	@CppEx parser->error("Bad cost value %d. Cost must be between 0 and 1000", value.i);
-	@CEx TCOD_parser_error("Bad cost value %d. Cost must be between 0 and 1000", value.i);
-	@PyEx libtcod.parser_error("Bad cost value %d. Cost must be between 0 and 1000"%( value ))
-	*/
-	virtual void error(const char *msg) = 0;
-};
-
-/**
- @PageName parser_types
- @PageFather parser
- @PageTitle Standard types
- @FuncDesc The parser can parse natively several data types. It stores them in a generic union :
- @C
-	typedef struct {
-		int nb_rolls;
-		int nb_faces;
-		float multiplier;
-		float addsub;
-	} TCOD_dice_t;
-
-	typedef union {
-		bool b;
-		char c;
-		int32 i;
-		float f;
-		char *s;
-		TCOD_color_t col;
-		TCOD_dice_t dice;
-		TCOD_list_t list;
-		void *custom;
-	} TCOD_value_t;
-*/
-/**
- @PageName parser_types
- @FuncDesc Possible types are defined by the TCOD_value_type_t enumeration :
-For python, remove TCOD_ : libtcod.TYPE_BOOL
-<table class="param">
-<tbody><tr><th>TCOD_value_type_t</th><th>Value in file</th><th>TCOD_value_t</th></tr>
-
-<tr><td>TCOD_TYPE_BOOL</td><td>true<br>false</td><td>value.b == true/false</td></tr>
-<tr><td>TCOD_TYPE_CHAR</td><td>decimal notation : 0 .. 255<br>
-hexadecimal notation : 0x00 .. 0xff <br>
-char notation : 'a' ';' ...<br>
-Special characters :<br>
-'\n' : carriage return (ascii 13)<br>
-'\t' : tabulation (ascii 9)<br>
-
-'\r' : line feed (ascii 10)<br>
-'\\' : antislash (ascii 92)<br>
-'\"' : double-quote (ascii 34)<br>
-'\'' : simple quote (ascii 39)<br>
-'\xHH' : hexadecimal value, same as 0xHH, HH between 0 and FF<br>
-'\NNN' : octal value, NNN between 0 and 377<br>
-</td><td>value.c == The corresponding ascii code</td></tr>
-<tr><td>TCOD_TYPE_INT</td><td>decimal notation : -2147483648 .. 2147483647<br>hexadecimal notation : 0x0 .. 0xFFFFFFFF</td><td>value.i == the integer value</td></tr>
-
-<tr><td>TCOD_TYPE_FLOAT</td><td>Any format parsable by atof. Examples:<br>3.14159<br>1.25E-3</td><td>value.f == the float value</td></tr>
-<tr><td>TCOD_TYPE_STRING</td><td>A double-quote delimited string :<br>"This is a string"<br>Support the same special characters as TCOD_TYPE_CHAR.</td><td>value.s == the corresponding string.<br>Warning ! If you want to store this string, you have to duplicate it (with strdup) as it will be overwritten by the parser</td></tr>
-<tr><td>TCOD_TYPE_COLOR</td><td>decimal notation : "16,32,64"<br>hexadecimal notation : "#102040"</td><td>value.col == the color.</td></tr>
-
-<tr><td>TCOD_TYPE_DICE</td><td>[multiplier (x|*)] nb_rolls (d|D) nb_faces [(+|-) addsub] :<br>"3d6"<br>"3D6+2"<br>"0.5x3d6-2"<br>"2*3d8"</td><td>value.dice == the dice components</td></tr>
-<tr><td>TCOD_TYPE_VALUELISTxx</td><td>Same as TCOD_TYPE_STRING</td><td>value.s == the string value from the value list</td></tr>
-<tr><td>TCOD_TYPE_LIST</td><td>[ &lt;value1&gt;,&lt;value2&gt;,... ]</td><td>value.list == the TCOD_list_t containing the elements</td></tr>
-
-</tbody></table>
-
-To define a list type, use the appropriate function (TCODParserStruct::addListProperty / TCOD_parser_add_list_property) and specify the type of the elements in the list. Lists of list are not supported.
- */
-
-
-#endif
--- a/include/path.hpp
+++ /dev/null
@@ -1,552 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_PATH_HPP
-#define _TCOD_PATH_HPP
-
-class TCODLIB_API ITCODPathCallback {
-public :
-	virtual ~ITCODPathCallback() {}
-	virtual float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void *userData ) const = 0;
-};
-
-/**
- @PageName path
- @PageTitle Path finding
- @PageCategory Roguelike toolkits
- @PageDesc This toolkit allows to easily calculate the optimal path between two points in your dungeon by using either the <a href="http://en.wikipedia.org/wiki/A*">A* algorithm</a> or <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a>.
-Please note that the paths generated with the two algorithms may differ slightly. Due to how they're implemented, A* will usually prefer diagonal moves over orthogonal, while Dijkstra will have the opposite preference. In other words, paths from point X to point Y will look like this:
-<div class="code"><pre>
-Dijkstra:      A*:
-..........   ..........
-.X........   .X*.......
-..*.......   ...**.....
-...*......   .....**...
-....****Y.   .......*Y.
-..........   ..........
-</pre></div>
- */
-class TCODLIB_API TCODPath {
-public :
-	/**
-	@PageName path_init
-	@PageFather path
-	@PageTitle Creating a path
-	@FuncTitle Allocating a pathfinder from a map
-	@FuncDesc First, you have to allocate a path using a map from <a href="fov.html">the Field of view module</a>.
-	@Cpp
-		TCODPath::TCODPath(const TCODMap *map, float diagonalCost=1.41f)
-		TCODDijkstra::TCODDijkstra(const TCODMap *map, float diagonalCost=1.41f)
-	@C 
-		TCOD_path_t TCOD_path_new_using_map(TCOD_map_t map, float diagonalCost)
-		TCOD_dijkstra_t TCOD_dijkstra_new(TCOD_map_t map, float diagonalCost)
-	@Py 
-		path_new_using_map(map, diagonalCost=1.41)
-		dijkstra_new(map, diagonalCost=1.41)
-	@C#
-		TCODPath(TCODMap map, float diagonalCost)
-		TCODPath(TCODMap map)
-		TCODDijkstra(TCODMap map, float diagonalCost)
-		TCODDijkstra(TCODMap map)
-	@Param map	The map. The path finder will use the 'walkable' property of the cells to find a path.
-	@Param diagonalCost	Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f).
-		It you want the same cost for all movements, use 1.0f.
-		If you don't want the path finder to use diagonal movements, use 0.0f.
-	@CppEx 
-		// A* :
-		TCODMap *myMap = new TCODMap(50,50);
-		TCODPath *path = new TCODPath(myMap); // allocate the path
-		// Dijkstra:
-		TCODMap *myMap = new TCODMap(50,50);
-		TCODDijkstra *dijkstra = new TCODDijkstra(myMap); // allocate the path
-	@CEx 
-		// A* :
-		TCOD_map_t my_map=TCOD_map_new(50,50,true);
-		TCOD_path_t path = TCOD_path_new_using_map(my_map,1.41f);
-		// Dijkstra :
-		TCOD_map_t my_map=TCOD_map_new(50,50,true);
-		TCOD_dijkstra_t dijk = TCOD_dijkstra_new(my_map,1.41f);
-	@PyEx 
-		# A* :
-		my_map=libtcod.map_new(50,50,True)
-		path = libtcod.path_new_using_map(my_map)
-		# Dijkstra
-		my_map=libtcod.map_new(50,50,True)
-		dijk = libtcod.dijkstra_new(my_map) 	
-	*/	
-	TCODPath(const TCODMap *map, float diagonalCost=1.41f);
-	/**
-	@PageName path_init
-	@FuncTitle Allocating a pathfinder using a callback
-	@FuncDesc Since the walkable status of a cell may depend on a lot of parameters (the creature type, the weather, the terrain type...), you can also create a path by providing a function rather than relying on a TCODMap.
-	@Cpp 
-		// Callback :
-		class ITCODPathCallback {
-			public: virtual float getWalkCost( int xFrom, int yFrom, int xTo, int yTo, void *userData ) const = 0;
-		};
-		// A* constructor:
-		TCODPath::TCODPath(int width, int height, const ITCODPathCallback *callback, void *userData, float diagonalCost=1.41f)
-		// Dijkstra constructor
-		TCODDijkstra::TCODDijkstra(int width, int height, const ITCODPathCallback *callback, void *userData, float diagonalCost=1.41f)
-	@C 
-		typedef float (*TCOD_path_func_t)( int xFrom, int yFrom, int xTo, int yTo, void *user_data )
-		TCOD_path_t TCOD_path_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost)
-		TCOD_dijkstra_t TCOD_dijkstra_new_using_function(int width, int height, TCOD_path_func_t callback, void *user_data, float diagonalCost)
-	@Py 
-		def path_func(xFrom,yFrom,xTo,yTo,userData) : ...
-		path_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41)
-		dijkstra_new_using_function(width, height, path_func, user_data=0, diagonalCost=1.41)
-	@C#
-		TCODPath(int width, int height, ITCODPathCallback listener, float diagonalCost)
-		TCODPath(int width, int height, ITCODPathCallback listener)
-		TCODDijkstra(int width, int height, ITCODPathCallback listener, float diagonalCost)
-		TCODDijkstra(int width, int height, ITCODPathCallback listener)
-	@Param width,height	The size of the map (in map cells).
-	@Param callback	A custom function that must return the walk cost from coordinates xFrom,yFrom to coordinates xTo,yTo.
-		The cost must be > 0.0f if the cell xTo,yTo is walkable.
-		It must be equal to 0.0f if it's not.
-		You must not take additional cost due to diagonal movements into account as it's already done by the pathfinder.
-	@Param userData	Custom data that will be passed to the function.
-	@Param diagonalCost	Cost of a diagonal movement compared to an horizontal or vertical movement. On a standard cartesian map, it should be sqrt(2) (1.41f).
-		It you want the same cost for all movements, use 1.0f.
-		If you don't want the path finder to use diagonal movements, use 0.0f.
-	@CppEx 
-		class MyCallback : public ITCODPathCallback {
-		public :
-			float getWalkCost(int xFrom, int yFrom, int xTo, int yTo, void *userData ) const { ... }
-		};
-		TCODPath *path = new TCODPath(50,50,new MyCallback(),NULL); // allocate the path
-		TCODDijkstra *dijkstra = new TCODDijkstra(50,50,new MyCallback(),NULL); // allocate Dijkstra
-	@CEx 
-		float my_func(int xFrom, int yFrom, int xTo, int yTo, void *user_data) { ... }
-		TCOD_path_t path = TCOD_path_new_using_function(50,50,my_func,NULL,1.41f);
-		TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new_using_function(50,50,my_func,NULL,1.41f);
-	@PyEx 
-		def my_func(xFrom, yFrom, xTo, yTo, user_data) :
-			# return a float cost for this movement
-			return 1.0
-		path = libtcod.path_new_using_function(50,50,my_func)
-		dijkstra = libtcod.dijkstra_new_using_function(50,50,my_func)
-	*/	
-	TCODPath(int width, int height, const ITCODPathCallback *listener, void *userData, float diagonalCost=1.41f);
-	
-	/**
-	@PageName path_init
-	@FuncTitle Destroying a path
-	@FuncDesc To release the resources used by a path, destroy it with :
-	@Cpp 
-		TCODPath::~TCODPath()
-		TCODDijkstra::~TCODDijkstra()
-	@C 
-		void TCOD_path_delete(TCOD_path_t path)
-		void TCOD_dijkstra_delete(TCOD_dijkstra_t dijkstra)
-	@Py 
-		path_delete(path)
-		dijkstra_delete(dijkstra)
-	@C#
-		void TCODPath::Dispose()
-		void TCODDijkstra::Dispose()
-	@Param path	In the C version, the path handler returned by one of the TCOD_path_new_* function.
-	@Param dijkstra	In the C version, the path handler returned by one of the TCOD_dijkstra_new* function.
-	@CppEx 
-		TCODPath *path = new TCODPath(myMap); // allocate the path
-		// use the path...
-		delete path; // destroy the path
-		
-		TCODDijkstra *dijkstra = new TCODDijkstra(myMap); // allocate the path
-		// use the path...
-		delete dijkstra; // destroy the path
-	@CEx 
-		TCOD_path_t path = TCOD_path_new_using_map(my_map);
-		// use the path ... 
-		TCOD_path_delete(path);
-		
-		TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map);
-		// use the path ... 
-		TCOD_dijkstra_delete(dijkstra);
-	@PyEx 
-		path = libtcod.path_new_using_map(my_map)
-		# use the path ... 
-		libtcod.path_delete(path)
-		
-		dijkstra = libtcod.dijkstra_new(my_map)
-		# use the path ... 
-		libtcod.dijkstra_delete(dijkstra)	
-	*/	
-	virtual ~TCODPath();
-
-	/**
-	@PageName path_compute
-	@PageFather path
-	@PageTitle Computing the path
-	@FuncTitle Computing an A* path
-	@FuncDesc Once you created a TCODPath object, you can compute the path between two points:
-	@Cpp bool TCODPath::compute(int ox, int oy, int dx, int dy)     
-	@C bool TCOD_path_compute(TCOD_path_t path, int ox,int oy, int dx, int dy)
-	@Py path_compute(path, ox, oy, dx, dy)
-	@C#	void TCODPath::compute(int ox, int oy, int dx, int dy)
-	@Param path	In the C version, the path handler returned by a creation function.
-	@Param ox,oy	Coordinates of the origin of the path.
-	@Param dx,dy	Coordinates of the destination of the path.
-		Both points should be inside the map, and at a walkable position. The function returns false if there is no possible path.
-	@CppEx 
-		TCODMap *myMap = new TCODMap(50,50);
-		TCODPath *path = new TCODPath(myMap); // allocate the path
-		path->compute(5,5,25,25); // calculate path from 5,5 to 25,25
-	@CEx 
-		TCOD_map_t my_map=TCOD_map_new(50,50);
-		TCOD_path_t path = TCOD_path_new_using_map(my_map);
-		TCOD_path_compute(path,5,5,25,25);
-	@PyEx 
-		my_map=libtcod.map_new(50,50)
-		path = libtcod.path_new_using_map(my_map)
-		libtcod.path_compute(path,5,5,25,25)	
-	*/	
-	bool compute(int ox, int oy, int dx, int dy);
-
-	/**
-	@PageName path_compute
-	@FuncTitle Reversing a path
-	@FuncDesc Once you computed a path, you can exchange origin and destination :
-	@Cpp 
-		void TCODPath::reverse()     
-		void TCODDijkstra::reverse()
-	@C 
-		void TCOD_path_reverse(TCOD_path_t path)
-		void TCOD_dijkstra_reverse(TCOD_dijkstra_t dijkstra)
-	@Py 
-		path_reverse(path)
-		dijkstra_reverse(dijkstra)
-	@C#	
-		void TCODPath::reverse()
-		void TCODDijkstra::reverse()
-	@Param path	In the C version, the path handler returned by a creation function.
-	@CppEx 
-		TCODMap *myMap = new TCODMap(50,50);
-		TCODPath *path = new TCODPath(myMap); // allocate the path
-		path->compute(5,5,25,25); // calculate path from 5,5 to 25,25
-		path->reverse(); // now the path goes from 25,25 to 5,5
-	@CEx 
-		TCOD_map_t my_map=TCOD_map_new(50,50);
-		TCOD_path_t path = TCOD_path_new_using_map(my_map);
-		TCOD_path_compute(path,5,5,25,25); // calculate path from 5,5 to 25,25
-		TCOD_path_reverse(path); // now the path goes from 25,25 to 5,5
-	@PyEx 
-		my_map=libtcod.map_new(50,50)
-		path = libtcod.path_new_using_map(my_map)
-		libtcod.path_compute(path,5,5,25,25) # calculate path from 5,5 to 25,25
-		libtcod.path_reverse(path) # now the path goes from 25,25 to 5,5
-	*/
-	void reverse();
-	
-
-	/**
-	@PageName path_read
-	@PageTitle Reading path information
-	@PageFather path
-	@PageDescDesc Once the path has been computed, you can get information about it using of one those functions.
-	@FuncTitle Getting the path origin and destination
-	@FuncDesc 	
-		You can read the current origin and destination cells with getOrigin/getDestination.
-		Note that when you walk the path, the origin changes at each step.
-	@Cpp 
-		void TCODPath::getOrigin(int *x,int *y) const
-		void TCODPath::getDestination(int *x,int *y) const
-	@C 
-		void TCOD_path_get_origin(TCOD_path_t path, int *x, int *y)
-		void TCOD_path_get_destination(TCOD_path_t path, int *x, int *y)
-	@Py 
-		path_get_origin(path) # returns x,y
-		path_get_destination(path) # returns x,y
-	@C#
-		void TCODPath::getOrigin(out int x, out int y)
-		void TCODPath::getDestination(out int x, out int y)
-	@Param path	In the C version, the path handler returned by a creation function.
-	@Param x,y	The function returns the cell coordinates in these variables
-	*/	
-	void getOrigin(int *x,int *y) const;
-	void getDestination(int *x,int *y) const;
-
-	/**
-	@PageName path_read
-	@FuncTitle Getting the path length
-	@FuncDesc You can get the number of steps needed to reach destination :
-	@Cpp 
-		int TCODPath::size() const
-		int TCODDijkstra::size() const
-	@C 
-		int TCOD_path_size(TCOD_path_t path)
-		int TCOD_dijkstra_size(TCOD_dijkstra_t dijkstra)
-	@Py 
-		path_size(path)
-		dijkstra_size(dijkstra)
-	@C#
-		int TCODPath::size()
-		int TCODDijkstra::size()
-	@Param path, dijkstra	In the C version, the path handler returned by a creation function.
-	*/		
-	int size() const;
-	
-	/**
-	@PageName path_read
-	@FuncTitle Read the path cells' coordinates	
-	@FuncDesc You can get the coordinates of each point along the path :
-	@Cpp 
-		void TCODPath::get(int index, int *x, int *y) const
-		void TCODDijkstra::get(int index, int *x, int *y) const
-	@C 
-		void TCOD_path_get(TCOD_path_t path, int index, int *x, int *y)
-		void TCOD_dijkstra_get(TCOD_dijkstra_t dijkstra, int index, int *x, int *y)
-	@Py 
-		path_get(path, index) # returns x,y
-		dijkstra_get(dijkstra, index) # returns x,y
-	@C#
-		int TCODPath::size()
-		int TCODDijkstra::size()
-	@Param path, dijkstra	In the C version, the path handler returned by a creation function.
-	@Param index	Step number.
-		0 <= index < path size
-	@Param x,y	Address of the variables receiving the coordinates of the point.
-	@CppEx 
-		for (int i=0; i < path->size(); i++ ) {
-			int x,y;
-			path->get(i,&x,&y);
-			printf ("Astar coord : %d %d\n", x,y );
-		}
-		for (int i=0; i < dijkstra->size(); i++ ) {
-			int x,y;
-			dijkstra->get(i,&x,&y);
-			printf ("Dijkstra coord : %d %d\n", x,y );
-		}
-	@CEx 
-		int i;
-		for (i=0; i < TCOD_path_size(path); i++ ) {
-			int x,y;
-			TCOD_path_get(path,i,&x,&y);
-			printf ("Astar coord : %d %d\n", x,y );
-		}
-		for (i=0; i < TCOD_dijkstra_size(dijkstra); i++ ) {
-			int x,y;
-			TCOD_dijkstra_get(dijkstra,i,&x,&y);
-			printf ("Dijsktra coord : %d %d\n", x,y );
-		}
-	@PyEx 
-		for i in range (libtcod.path_size(path)) :
-			x,y=libtcod.path_get(path,i)
-			print 'Astar coord : ',x,y
-		for i in range (libtcod.dijkstra_size(dijkstra)) :
-			x,y=libtcod.dijkstra_get(dijkstra,i)
-			print 'Dijkstra coord : ',x,y
-	*/	
-	void get(int index, int *x, int *y) const;
-
-	/**
-	@PageName path_read
-	@FuncTitle Checking if the path is empty
-	@FuncDesc If you want a creature to follow the path, a more convenient way is to walk the path :
-		You know when you reached destination when the path is empty :
-	@Cpp 
-		bool TCODPath::isEmpty() const
-		bool TCODDijkstra::isEmpty() const
-	@C 
-		bool TCOD_path_is_empty(TCOD_path_t path)
-		bool TCOD_dijkstra_is_empty(TCOD_dijkstra_t dijkstra)
-	@Py 
-		path_is_empty(path)
-		dijkstra_is_empty(dijkstra)
-	@C#
-		bool TCODPath::isEmpty()
-		bool TCODDijkstra::isEmpty()
-	@Param path, dijkstra	In the C version, the path handler returned by a creation function.	
-	*/
-	bool isEmpty() const;
-
-	/**
-	@PageName path_read
-	@FuncTitle Walking the path
-	@FuncDesc You can walk the path and go to the next step with :
-		Note that walking the path consume one step (and decrease the path size by one). The function returns false if recalculateWhenNeeded is false and the next cell on the path is no longer walkable, or if recalculateWhenNeeded is true, the next cell on the path is no longer walkable and no other path has been found. Also note that recalculateWhenNeeded only applies to A*.
-	@Cpp 
-		bool TCODPath::walk(int *x, int *y, bool recalculateWhenNeeded)
-		bool TCODDijkstra::walk(int *x, int *y)
-	@C 
-		bool TCOD_path_walk(TCOD_path_t path, int *x, int *y, bool recalculate_when_needed)
-		bool TCOD_dijkstra_walk(TCOD_dijkstra_t dijkstra, int *x, int *y)
-	@Py 
-		path_walk(TCOD_path_t path, recalculate_when_needed) # returns x,y or None,None if no path
-		dijkstra_walk(TCOD_dijkstra_t dijkstra)
-	@C#
-		bool TCODPath::walk(ref int x, ref int y, bool recalculateWhenNeeded)
-		bool TCODDijkstra::walk(ref int x, ref int y)
-	@Param path, dijkstra	In the C version, the path handler returned by a creation function.
-	@Param x,y	Address of the variables receiving the coordinates of the next point.
-	@Param recalculateWhenNeeded	If the next point is no longer walkable (another creature may be in the way), recalculate a new path and walk it.
-	@CppEx 
-		while (! path->isEmpty()) {
-			int x,y;
-			if (path->walk(&x,&y,true)) {
-				printf ("Astar coord: %d %d\n",x,y );
-			} else {
-				printf ("I'm stuck!\n" );
-				break;
-			}
-		}
-		while (! dijkstra->isEmpty()) {
-			int x,y;
-			if (dijkstra->walk(&x,&y)) {
-				printf ("Dijkstra coord: %d %d\n",x,y );
-			} else {
-				printf ("I'm stuck!\n" );
-				break;
-			}
-		}
-	@CEx 
-		while (! TCOD_path_is_empty(path)) {
-			int x,y;
-			if (TCOD_path_walk(path,&x,&y,true)) {
-				printf ("Astar coord: %d %d\n",x,y );
-			} else {
-				printf ("I'm stuck!\n" );
-				break;
-			}
-		}
-		while (! TCOD_dijkstra_is_empty(dijkstra)) {
-			int x,y;
-			if (TCOD_dijkstra_walk(dijkstra,&x,&y)) {
-				printf ("Dijkstra coord: %d %d\n",x,y );
-			} else {
-				printf ("I'm stuck!\n" );
-				break;
-			}
-		}
-	@PyEx 
-		while not libtcod.path_is_empty(path)) :
-			x,y=libtcod.path_walk(path,True)
-			if not x is None :
-				print 'Astar coord: ',x,y
-			else :
-				print "I'm stuck!"
-				break
-		while not libtcod.dijkstra_is_empty(dijkstra)) :
-			x,y=libtcod.dijkstra_walk(dijkstra,True)
-			if not x is None :
-				print 'Dijkstra coord: ',x,y
-			else :
-				print "I'm stuck!"
-				break	
-	*/	
-	bool walk(int *x, int *y, bool recalculateWhenNeeded);
-
-protected :
-	friend float TCOD_path_func(int xFrom, int yFrom, int xTo,int yTo, void *data);
-	TCOD_path_t data;
-	struct WrapperData {
-		void *userData;
-		const ITCODPathCallback *listener;
-	} cppData;
-};
-
-//Dijkstra kit
-class TCODLIB_API TCODDijkstra {
-    public:
-        TCODDijkstra (TCODMap *map, float diagonalCost=1.41f);
-        TCODDijkstra (int width, int height, const ITCODPathCallback *listener, void *userData, float diagonalCost=1.41f);
-        ~TCODDijkstra (void);
-        /**
-        @PageName path_compute
-		@FuncTitle Computing a Dijkstra grid
-		@FuncDesc In case of Dijkstra, this works in a slightly different way. In order to be able to compute a path, Dijkstra must first analyse the distances from the selected root (origin) node to all other nodes:
-		@Cpp void TCODDijkstra::compute(int rootX, int rootY)     
-		@C void TCOD_dijkstra_compute(TCOD_dijkstra_t dijkstra, int root_x, int root_y)
-		@Py dijkstra_compute(dijkstra, root_x, root_y)
-		@C# void TCODDijkstra::compute(int rootX, int rootY)
-		@Param dijkstra	In the C version, the path handler returned by a creation function.
-		@Param root_x,root_y	Coordinates of the root node (origin) of the path.
-			The coordinates should be inside the map, at a walkable position. Otherwise, the function's behaviour will be undefined.        
-        */        
-        void compute (int rootX, int rootY);
-
-        /**
-        @PageName path_compute
-		@FuncTitle Computing a path from a Dijkstra grid
-		@FuncDesc After the map is analysed and all the distances from the root node are known, an unlimited number of paths can be set, all originating at the root node, using:
-			The path setting function will return true if there's a path from the root node to the destination node. Otherwise, it will return false.
-		@Cpp bool TCODDijkstra::setPath(int toX, int toY)     
-		@C bool TCOD_dijkstra_path_set(TCOD_dijkstra_t dijkstra, int to_x, int to_y)
-		@Py dijkstra_path_set(dijkstra, to_x, to_y)
-		@C# bool TCODDijkstra::setPath(int toX, int toY)
-		@Param dijkstra	In the C version, the path handler returned by a creation function.
-		@Param to_x,to_y	Coordinates of the destination node of the path.
-		@CppEx 
-			TCODMap *myMap = new TCODMap(50,50);
-			TCODDijkstra *dijkstra = new TCODDijkstra(myMap); // allocate the path
-			dijkstra->compute(25,25); // calculate distance from 25,25 to all other nodes
-			dijkstra->setPath(5,5); // calculate a path to node 5,5
-			dijkstra->setPath(45,45); //calculate another path from the same origin
-		@CEx 
-			TCOD_map_t my_map=TCOD_map_new(50,50);
-			TCOD_dijkstra_t dijkstra = TCOD_dijkstra_new(my_map);
-			TCOD_dijkstra_compute(dijkstra,25,25);
-			TCOD_dijkstra_path_set(dijkstra,5,5);
-			TCOD_dijkstra_path_set(dijkstra,45,45);
-		@PyEx 
-			my_map=libtcod.map_new(50,50)
-			dijkstra = libtcod.dijkstra_new(my_map)
-			libtcod.dijkstra_compute(dijkstra,25,25)
-			libtcod.dijkstra_path_set(dijkstra,5,5)
-			libtcod.dijkstra_path_set(dijkstra,45,45)        
-        */        
-        bool setPath (int toX, int toY);
-
-        /**
-        @PageName path_read
-		@FuncTitle Getting the distance from a cell to the root node
-		@FuncDesc You can get the distance of any set of coordinates from the root node:
-			Note that if the coordinates x,y are outside of the map or are a non-walkable position, the function will return -1.0f. This functionality is only available for Dijkstra's algorithm.        
-		@Cpp float TCODDijkstra::getDistance(int x, int y)
-		@C float TCOD_dijkstra_get_distance(TCOD_dijkstra_t dijkstra, int x, int y)
-		@Py dijkstra_get_distance(dijkstra, x, y)
-		@C# float TCODDijkstra::getDistance(int x, int y)
-		@Param dijkstra	In the C version, the path handler returned by a creation function.
-		@Param x,y	The coordinates whose distance from the root node are to be checked
-        */        
-        float getDistance (int x, int y);
-        bool walk (int *x, int *y);
-		bool isEmpty() const;
-		void reverse();
-		int size() const;
-		void get(int index, int *x, int *y) const;
-    private:
-        TCOD_dijkstra_t data;
-        struct WrapperData {
-            void *userData;
-            const ITCODPathCallback *listener;
-        } cppData;
-};
-
-#endif
-
--- a/include/sys.hpp
+++ /dev/null
@@ -1,540 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_SYS_HPP
-#define _TCOD_SYS_HPP
-
-/**
-	@PageName system
-	@PageCategory Core
-	@PageTitle System layer
-	@PageDesc This toolkit contains some system specific miscellaneous utilities. Use them is you want your code to be easily portable.
- */
-
-class TCODLIB_API ITCODSDLRenderer {
-public :
-	virtual ~ITCODSDLRenderer() {}
-	virtual void render(void *sdlSurface) = 0;
-};
-
-class TCODLIB_API TCODSystem {
-public :
-	/**
-	@PageName system_time
-	@PageFather system
-	@PageTitle High precision time functions
-	@PageDesc These are functions specifically aimed at real time game development.
-	@FuncTitle Limit the frames per second
-	@FuncDesc The setFps function allows you to limit the number of frames per second.
-		If a frame is rendered faster than expected, the TCOD_console_flush function will wait so that the frame rate never exceed this value.
-		You can call this function during your game initialization.
-		You can dynamically change the frame rate. Just call this function once again.
-		<b>You should always limit the frame rate, except during benchmarks, else your game will use 100% of the CPU power</b>
-	@Cpp static void TCODSystem::setFps(int val)
-	@C void TCOD_sys_set_fps(int val)
-	@Py sys_set_fps(val)
-	@C# static void TCODSystem::setFps(int val)
-	@Lua tcod.system.setFps(val)
-	@Param val Maximum number of frames per second. 0 means unlimited frame rate.
-	*/
-	static void setFps(int val);
-
-	/**
-	@PageName system_time
-	@FuncTitle Get the number of frames rendered during the last second
-	@FuncDesc The value returned by this function is updated every second.
-	@Cpp static int TCODSystem::getFps()
-	@C int TCOD_sys_get_fps()
-	@Py sys_get_fps()
-	@C# static int TCODSystem::getFps()
-	@Lua tcod.system.getFps()
-	*/
-	static int getFps();
-
-	/**
-	@PageName system_time
-	@FuncTitle Get the duration of the last frame
-	@FuncDesc This function returns the length in seconds of the last rendered frame.
-		You can use this value to update every time dependent object in the world.
-	@Cpp static float TCODSystem::getLastFrameLength()
-	@C float TCOD_sys_get_last_frame_length()
-	@Py sys_get_last_frame_length()
-	@C# static float TCODSystem::getLastFrameLength()
-	@Lua tcod.system.getLastFrameLength()
-	@CppEx
-		// moving an objet at 5 console cells per second
-		float x=0,y=0; // object coordinates
-		x += 5 * TCODSystem::getLastFrameLength();
-		TCODConsole::root->putChar((int)(x),(int)(y),'X');
-	@CEx
-		float x=0,y=0;
-		x += 5 * TCOD_sys_get_last_frame_length();
-		TCOD_console_put_char(NULL,(int)(x),(int)(y),'X');
-	@PyEx
-		x=0.0
-		y=0.0
-		x += 5 * libtcod.sys_get_last_frame_length()
-		libtcod.console_put_char(0,int(x),int(y),'X')
-	@LuaEx
-		-- moving an objet at 5 console cells per second
-		x=0
-		y=0 -- object coordinates
-		x = x + 5 * tcod.system.getLastFrameLength()
-		libtcod.TCODConsole_root:putChar(x,y,'X')
-	*/
-	static float getLastFrameLength();
-
-	/**
-	@PageName system_time
-	@FuncTitle Pause the program
-	@FuncDesc Use this function to stop the program execution for a specified number of milliseconds.
-	@Cpp static void TCODSystem::sleepMilli(uint32 val)
-	@C void TCOD_sys_sleep_milli(uint32 val)
-	@Py sys_sleep_milli(val)
-	@C# static void TCODSystem::sleepMilli(uint val)
-	@Lua tcod.system.sleepMilli(val)
-	@Param val number of milliseconds before the function returns
-	*/
-	static void sleepMilli(uint32 val);
-
-	/**
-	@PageName system_time
-	@FuncTitle Get global timer in milliseconds
-	@FuncDesc This function returns the number of milliseconds since the program has started.
-	@Cpp static uint32 TCODSystem::getElapsedMilli()
-	@C uint32 TCOD_sys_elapsed_milli()
-	@Py sys_elapsed_milli()
-	@C# static uint TCODSystem::getElapsedMilli()
-	@Lua tcod.system.getElapsedMilli()
-	*/
-	static uint32 getElapsedMilli();
-
-	/**
-	@PageName system_time
-	@FuncTitle Get global timer in seconds
-	@FuncDesc This function returns the number of seconds since the program has started.
-	@Cpp static float TCODSystem::getElapsedSeconds()
-	@C float TCOD_sys_elapsed_seconds()
-	@Py sys_elapsed_seconds()
-	@C# static float TCODSystem::getElapsedSeconds()
-	@Lua tcod.system.getElapsedSeconds()
-	*/
-	static float getElapsedSeconds();
-
-	/**
-	@PageName console_blocking_input
-	@FuncTitle Waiting for any event (mouse or keyboard)
-	@FuncDesc There's a more generic function that waits for an event from the user. The eventMask shows what events we're waiting for.
-		The return value indicate what event was actually triggered. Values in key and mouse structures are updated accordingly.
-		If flush is false, the function waits only if there are no pending events, else it returns the first event in the buffer.
-	@Cpp typedef enum {
-		TCOD_EVENT_KEY_PRESS=1,
-		TCOD_EVENT_KEY_RELEASE=2,
-		TCOD_EVENT_KEY=TCOD_EVENT_KEY_PRESS|TCOD_EVENT_KEY_RELEASE,
-		TCOD_EVENT_MOUSE_MOVE=4,
-		TCOD_EVENT_MOUSE_PRESS=8,
-		TCOD_EVENT_MOUSE_RELEASE=16,
-		TCOD_EVENT_MOUSE=TCOD_EVENT_MOUSE_MOVE|TCOD_EVENT_MOUSE_PRESS|TCOD_EVENT_MOUSE_RELEASE,
-		TCOD_EVENT_ANY=TCOD_EVENT_KEY|TCOD_EVENT_MOUSE,		
-	} TCOD_event_t; 
-	static TCOD_event_t TCODSystem::waitForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush)
-	@C TCOD_event_t TCOD_sys_wait_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush)
-	@Py sys_wait_for_event(eventMask,key,mouse,flush)
-	@Param eventMask event types to wait for (other types are discarded)
-	@Param key updated in case of a key event. Can be null if eventMask contains no key event type
-	@Param mouse updated in case of a mouse event. Can be null if eventMask contains no mouse event type
-	@Param flush if true, all pending events are flushed from the buffer. Else, return the first available event
-	@CppEx
-		TCOD_key_t key;
-		TCOD_mouse_t mouse;
-		TCOD_event_t ev = TCODSystem::waitForEvent(TCOD_EVENT_ANY,&key,&mouse,true);
-		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }
-	@CEx
-		TCOD_key_t key;
-		TCOD_mouse_t mouse;
-		TCOD_event_t ev = TCOD_sys_wait_for_event(TCOD_EVENT_ANY,&key,&mouse,true);
-		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }	
-	*/
-	static TCOD_event_t waitForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse, bool flush);
-
-	/**
-	@PageName console_non_blocking_input
-	@FuncTitle Checking for any event (mouse or keyboard)
-	@FuncDesc There's a more generic function that checks if an event from the user is in the buffer. The eventMask shows what events we're waiting for.
-		The return value indicate what event was actually found. Values in key and mouse structures are updated accordingly.
-	@Cpp typedef enum {
-		TCOD_EVENT_KEY_PRESS=1,
-		TCOD_EVENT_KEY_RELEASE=2,
-		TCOD_EVENT_KEY=TCOD_EVENT_KEY_PRESS|TCOD_EVENT_KEY_RELEASE,
-		TCOD_EVENT_MOUSE_MOVE=4,
-		TCOD_EVENT_MOUSE_PRESS=8,
-		TCOD_EVENT_MOUSE_RELEASE=16,
-		TCOD_EVENT_MOUSE=TCOD_EVENT_MOUSE_MOVE|TCOD_EVENT_MOUSE_PRESS|TCOD_EVENT_MOUSE_RELEASE,
-		TCOD_EVENT_ANY=TCOD_EVENT_KEY|TCOD_EVENT_MOUSE,		
-	} TCOD_event_t; 
-	static TCOD_event_t TCODSystem::checkForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse)
-	@C TCOD_event_t TCOD_sys_check_for_event(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse)
-	@Py sys_check_for_event(eventMask,key,mouse)
-	@Param eventMask event types to wait for (other types are discarded)
-	@Param key updated in case of a key event. Can be null if eventMask contains no key event type
-	@Param mouse updated in case of a mouse event. Can be null if eventMask contains no mouse event type
-	@CppEx
-		TCOD_key_t key;
-		TCOD_mouse_t mouse;
-		TCOD_event_t ev = TCODSystem::checkForEvent(TCOD_EVENT_ANY,&key,&mouse);
-		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }
-	@CEx
-		TCOD_key_t key;
-		TCOD_mouse_t mouse;
-		TCOD_event_t ev = TCOD_sys_check_for_event(TCOD_EVENT_ANY,&key,&mouse);
-		if ( ev == TCOD_EVENT_KEY_PRESS && key.c == 'i' ) { ... open inventory ... }	
-	*/
-	static TCOD_event_t checkForEvent(int eventMask, TCOD_key_t *key, TCOD_mouse_t *mouse);
-	/**
-	@PageName system_screenshots
-	@PageFather system
-	@PageTitle Easy screenshots
-	@FuncDesc This function allows you to save the current game screen in a png file, or possibly a bmp file if you provide a filename ending with .bmp.
-	@Cpp static void TCODSystem::saveScreenshot(const char *filename)
-	@C void TCOD_sys_save_screenshot(const char *filename)
-	@Py sys_save_screenshot(filename)
-	@C# static void TCODSystem::saveScreenshot(string filename);
-	@Lua tcod.system.saveScreenshot(filename)
-	@Param filename Name of the file. If NULL, a filename is automatically generated with the form "./screenshotNNN.png", NNN being the first free number (if a file named screenshot000.png already exist, screenshot001.png will be used, and so on...).
-	*/
-	static void saveScreenshot(const char *filename);
-
-	/**
-	@PageName system_filesystem
-	@PageFather system
-	@PageTitle Filesystem utilities
-	@PageDesc Those are a few function that cannot be easily implemented in a portable way in C/C++. They have no python wrapper since python provides its own builtin functions. All those functions return false if an error occured.
-	@FuncTitle Create a directory
-	@Cpp static bool TCODSystem::createDirectory(const char *path)
-	@C bool TCOD_sys_create_directory(const char *path)
-	@Param path Directory path. The immediate father directory (<path>/..) must exist and be writable.
-	*/
-	static bool createDirectory(const char *path);
-
-	/**
-	@PageName system_filesystem
-	@FuncTitle Delete an empty directory
-	@Cpp static bool TCODSystem::deleteDirectory(const char *path)
-	@C bool TCOD_sys_delete_directory(const char *path)
-	@Param path directory path. This directory must exist, be writable and empty
-	*/
-	static bool deleteDirectory(const char *path);
-
-	/**
-	@PageName system_filesystem
-	@FuncTitle Delete a file
-	@Cpp static bool TCODSystem::deleteFile(const char *path)
-	@C bool TCOD_sys_delete_file(const char *path)
-	@Param path File path. This file must exist and be writable.
-	*/
-	static bool deleteFile(const char *path);
-
-	/**
-	@PageName system_filesystem
-	@FuncTitle Check if a path is a directory
-	@Cpp static bool TCODSystem::isDirectory(const char *path)
-	@C bool TCOD_sys_is_directory(const char *path)
-	@Param path a path to check
-	*/
-	static bool isDirectory(const char *path);
-
-	/**
-	@PageName system_filesystem
-	@FuncTitle List files in a directory
-	@FuncDesc To get the list of entries in a directory (including sub-directories, except . and ..).
-		The returned list is allocated by the function and must be deleted by you. All the const char * inside must be also freed with TCODList::clearAndDelete.
-	@Cpp static TCODList TCODSystem::getDirectoryContent(const char *path, const char *pattern)
-	@C TCOD_list_t TCOD_sys_get_directory_content(const char *path)
-	@Param path a directory
-	@Param pattern If NULL or empty, returns all directory entries. Else returns only entries matching the pattern. The pattern is NOT a regular expression. It can only handle one '*' wildcard. Examples : *.png, saveGame*, font*.png
-	*/
-	static TCOD_list_t getDirectoryContent(const char *path, const char *pattern);
-
-	/**
-	@PageName system_filesystem
-	@FuncTitle Check if a given file exists
-	@FuncDesc In order to check whether a given file exists in the filesystem. Useful for detecting errors caused by missing files.
-	@Cpp static bool TCODSystem::fileExists(const char *filename, ...)
-	@C bool TCOD_sys_file_exists(const char * filename, ...)
-	@Param filename the file name, using printf-like formatting
-	@Param ... optional arguments for filename formatting
-	@CppEx
-		if (!TCODSystem::fileExists("myfile.%s","txt")) {
-		    fprintf(stderr,"no such file!");
-		}
-	@CEx
-		if (!TCOD_sys_file_exists("myfile.%s","txt")) {
-		    fprintf(stderr,"no such file!");
-		}
-	*/
-	static bool fileExists(const char * filename, ...);
-	/**
-	@PageName system_filesystem
-	@FuncTitle Read the content of a file into memory
-	@FuncDesc This is a portable function to read the content of a file from disk or from the application apk (android).
-		buf must be freed with free(buf).
-	@Cpp static bool TCODSystem::readFile(const char *filename, unsigned char **buf, uint32 *size)
-	@C bool TCOD_sys_read_file(const char *filename, unsigned char **buf, uint32 *size)
-	@Param filename the file name
-	@Param buf a buffer to be allocated and filled with the file content
-	@Param size the size of the allocated buffer.
-	@CppEx
-		unsigned char *buf;
-		uint32 size;
-		if (TCODSystem::readFile("myfile.dat",&buf,&size)) {
-		    // do something with buf
-		    free(buf);
-		}
-	@CEx
-		if (TCOD_sys_read_file("myfile.dat",&buf,&size)) {
-		    // do something with buf
-		    free(buf);
-		}
-	*/	
-	static bool readFile(const char *filename, unsigned char **buf, uint32 *size);
-	/**
-	@PageName system_filesystem
-	@FuncTitle Write the content of a memory buffer to a file
-	@FuncDesc This is a portable function to write some data to a file.
-	@Cpp static bool TCODSystem::writeFile(const char *filename, unsigned char *buf, uint32 size)
-	@C bool TCOD_sys_write_file(const char *filename, unsigned char *buf, uint32 size)
-	@Param filename the file name
-	@Param buf a buffer containing the data to write
-	@Param size the number of bytes to write.
-	@CppEx
-		TCODSystem::writeFile("myfile.dat",buf,size));
-	@CEx
-		TCOD_sys_write_file("myfile.dat",buf,size));
-	*/		
-	static bool writeFile(const char *filename, unsigned char *buf, uint32 size);
-	/**
-	@PageName system_sdlcbk
-	@PageFather system
-	@PageTitle Draw custom graphics on top of the root console
-	@PageDesc You can register a callback that will be called after the libtcod rendering phase, but before the screen buffer is swapped. This callback receives the screen SDL_Surface reference.
-		This makes it possible to use any SDL drawing functions (including openGL) on top of the libtcod console.
-	@FuncTitle Render custom graphics
-	@FuncDesc To disable the custom renderer, call the same method with a NULL parameter.
-		Note that to keep libtcod from requiring the SDL headers, the callback parameter is a void pointer. You have to include SDL headers and cast it to SDL_Surface in your code.
-	@Cpp
-		class TCODLIB_API ITCODSDLRenderer {
-		public :
-			virtual void render(void *sdlSurface) = 0;
-		};
-		static void TCODSystem::registerSDLRenderer(ITCODSDLRenderer *callback);
-	@C
-		typedef void (*SDL_renderer_t) (void *sdl_surface);
-		void TCOD_sys_register_SDL_renderer(SDL_renderer_t callback)
-	@Py
-		def renderer ( sdl_surface ) : ...
-		TCOD_sys_register_SDL_renderer( callback )
-	@Param callback The renderer to call before swapping the screen buffer. If NULL, custom rendering is disabled
-	@CppEx
-		class MyRenderer : public ITCODSDLRenderer {
-		public :
-			void render(void *sdlSurface) {
-				SDL_Surface *s = (SDL_Surface *)sdlSurface;
-				... draw something on s
-			}
-		};
-		TCODSystem::registerSDLRenderer(new MyRenderer());
-	@CEx
-		void my_renderer( void *sdl_surface ) {
-			SDL_Surface *s = (SDL_Surface *)sdl_surface;
-			... draw something on s
-		}
-		TCOD_sys_register_SDL_renderer(my_renderer);
-	@Py
-		def my_renderer(sdl_surface) :
-			... draw something on sdl_surface using pygame
-		libtcod.sys_register_SDL_renderer(my_renderer)
-	*/
-	static void registerSDLRenderer(ITCODSDLRenderer *renderer);
-
-	/**
-	@PageName system_sdlcbk
-	@FuncTitle Managing screen redraw
-	@FuncDesc libtcod is not aware of the part of the screen your SDL renderer has updated. If no change occured in the console, it won't redraw them except if you tell him to do so with this function
-	@Cpp void TCODConsole::setDirty(int x, int y, int w, int h)
-	@C void TCOD_console_set_dirty(int x, int y, int w, int h)
-	@Py TCOD_console_set_dirty(x, y, w, h)
-	@Param x,y,w,h Part of the root console you want to redraw even if nothing has changed in the console back/fore/char.
-	*/
-
-	/**
-	@PageName system_misc
-	@PageFather system
-	@PageTitle Miscellaneous utilities
-	@FuncTitle Using a custom resolution for the fullscreen mode
-	@FuncDesc This function allows you to force the use of a specific resolution in fullscreen mode.
-		The default resolution depends on the root console size and the font character size.
-	@Cpp static void TCODSystem::forceFullscreenResolution(int width, int height)
-	@C void TCOD_sys_force_fullscreen_resolution(int width, int height)
-	@Py sys_force_fullscreen_resolution(width, height)
-	@C# static void TCODSystem::forceFullscreenResolution(int width, int height);
-	@Lua tcod.system.forceFullscreenResolution(width,height)
-	@Param width,height Resolution to use when switching to fullscreen.
-		Will use the smallest available resolution so that :
-		resolution width >= width and resolution width >= root console width * font char width
-		resolution width >= height and resolution height >= root console height * font char height
-	@CppEx
-		TCODSystem::forceFullscreenResolution(800,600); // use 800x600 in fullscreen instead of 640x400
-		TCODConsole::initRoot(80,50,"",true); // 80x50 console with 8x8 char => 640x400 default resolution
-	@CEx
-		TCOD_sys_force_fullscreen_resolution(800,600);
-		TCOD_console_init_root(80,50,"",true);
-	@PyEx
-		libtcod.sys_force_fullscreen_resolution(800,600)
-		libtcod.console_init_root(80,50,"",True)
-	@LuaEx
-		tcod.system.forceFullscreenResolution(800,600) -- use 800x600 in fullscreen instead of 640x400
-		tcod.console.initRoot(80,50,"",true) -- 80x50 console with 8x8 char => 640x400 default resolution
-	*/
-	static void forceFullscreenResolution(int width, int height);
-
-	/**
-	@PageName system_misc
-	@FuncTitle Get current resolution
-	@FuncDesc You can get the current screen resolution with getCurrentResolution. You can use it for example to get the desktop resolution before initializing the root console.
-	@Cpp static void TCODSystem::getCurrentResolution(int *width, int *height)
-	@C void TCOD_sys_get_current_resolution(int *width, int *height)
-	@Py sys_get_current_resolution() # returns w,h
-	@C# static void TCODSystem::getCurrentResolution(out int w, out int h);
-	@Param width,height contains current resolution when the function returns
-	*/
-	static void getCurrentResolution(int *w, int *h);
-	/**
-	@PageName system_misc
-	@FuncTitle Get fullscreen offset
-	@FuncDesc If the fullscreen resolution does not matches the console size in pixels, black borders are added. This function returns the position in pixels of the console top left corner in the screen.
-	@Cpp static void TCODSystem::getFullscreenOffsets(int *offx, int *offy)
-	@C void TCOD_sys_get_fullscreen_offsets(int *offx, int *offy)
-	@C# static void TCODSystem::getFullscreenOffsets(out int offx, out int offy);
-	@Param offx,offy contains the position of the console on the screen when using fullscreen mode.
-	*/
-	static void getFullscreenOffsets(int *offx, int *offy);
-	/**
-	@PageName system_misc
-	@FuncTitle Get the font size
-	@FuncDesc You can get the size of the characters in the font
-	@Cpp static void TCODSystem::getCharSize(int *width, int *height)
-	@C void TCOD_sys_get_char_size(int *width, int *height)
-	@Py sys_get_char_size() # returns w,h
-	@C# static void TCODSystem::getCharSize(out int w, out int h);
-	@Param width,height contains a character size when the function returns
-	*/
-	static void getCharSize(int *w, int *h);
-
-	/**
-	@PageName system_misc
-	@FuncTitle Dynamically updating the font bitmap
-	@FuncDesc You can dynamically change the bitmap of a character in the font. All cells using this ascii code will be updated at next flush call.
-	@Cpp static void TCODSystem::updateChar(int asciiCode, int fontx, int fonty,const TCODImage *img,int x,int y)
-	@C void TCOD_sys_update_char(int asciiCode, int fontx, int fonty, TCOD_image_t img, int x, int y)
-	@Py sys_update_char(asciiCode,fontx,fonty,img,x,y)
-	@Param asciiCode ascii code corresponding to the character to update
-	@Param fontx,fonty coordinate of the character in the bitmap font (in characters, not pixels)
-	@Param img image containing the new character bitmap
-	@Param x,y position in pixels of the top-left corner of the character in the image
-	*/
-	static void updateChar(int asciiCode, int fontx, int fonty,const TCODImage *img,int x,int y);
-
-	/**
-	@PageName system_misc
-	@FuncTitle Dynamically change libtcod's internal renderer
-	@FuncDesc As of 1.5.1, libtcod contains 3 different renderers :
-		* SDL : historic libtcod renderer. Should work and be pretty fast everywhere
-		* OpenGL : requires OpenGL compatible video card. Might be much faster or much slower than SDL, depending on the drivers
-		* GLSDL : requires OpenGL 1.4 compatible video card with GL_ARB_shader_objects extension. Blazing fast if you have the proper hardware and drivers.
-		This function switches the current renderer dynamically.
-	@Cpp static void TCODSystem::setRenderer(TCOD_renderer_t renderer)
-	@C void TCOD_sys_set_renderer(TCOD_renderer_t renderer)
-	@Py sys_set_renderer(renderer)
-	@C# static void TCODSystem::setRenderer(TCODRendererType renderer);
-	@Param renderer Either TCOD_RENDERER_GLSL, TCOD_RENDERER_OPENGL or TCOD_RENDERER_SDL
-	*/
-	static void setRenderer(TCOD_renderer_t renderer);
-
-	/**
-	@PageName system_misc
-	@FuncTitle Get the current internal renderer
-	@Cpp static TCOD_renderer_t TCODSystem::getRenderer()
-	@C TCOD_renderer_t TCOD_sys_get_renderer()
-	@Py sys_get_renderer()
-	@C# static TCODRendererType TCODSystem::getRenderer();
-	*/
-	static TCOD_renderer_t getRenderer();
-
-	/**
-	@PageName system_clipboard
-	@PageTitle Clipboard integration
-	@PageDesc With these functions, you can copy data in your OS' clipboard from the game or retrieve data from the clipboard.
-	@PageFather system
-	@FuncTitle Copy data to the clipboard
-	@Cpp static void TCODSystem::setClipboard(const char *value)
-	@C void TCOD_sys_clipboard_set(const char *value)
-	@Param value Text to copy in the clipboard
-	*/
-	static void setClipboard(const char *value);
-
-	/**
-	@PageName system_clipboard
-	@FuncTitle Paste data from the clipboard
-	@Cpp static char *TCODSystem::getClipboard()
-	@C char *TCOD_sys_clipboard_get()
-	*/
-	static char *getClipboard();
-
-	// thread stuff
-	static int getNumCores();
-	static TCOD_thread_t newThread(int (*func)(void *), void *data);
-	static void deleteThread(TCOD_thread_t th);
-	static void waitThread(TCOD_thread_t th);
-	// mutex
-	static TCOD_mutex_t newMutex();
-	static void mutexIn(TCOD_mutex_t mut);
-	static void mutexOut(TCOD_mutex_t mut);
-	static void deleteMutex(TCOD_mutex_t mut);
-	// semaphore
-	static TCOD_semaphore_t newSemaphore(int initVal);
-	static void lockSemaphore(TCOD_semaphore_t sem);
-	static void unlockSemaphore(TCOD_semaphore_t sem);
-	static void deleteSemaphore( TCOD_semaphore_t sem);
-	// condition
-	static TCOD_cond_t newCondition();
-	static void signalCondition(TCOD_cond_t sem);
-	static void broadcastCondition(TCOD_cond_t sem);
-	static void waitCondition(TCOD_cond_t sem, TCOD_mutex_t mut);
-	static void deleteCondition( TCOD_cond_t sem);
-};
-
-#endif
--- a/include/tree.hpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_TREE_HPP
-#define _TCOD_TREE_HPP
-
-class TCODLIB_API TCODTree {
-public :
-	TCODTree *next;
-	TCODTree *father;
-	TCODTree *sons;
-
-	TCODTree() : next(NULL),father(NULL),sons(NULL){}
-	void addSon(TCODTree *data) {
-		data->father=this;
-		TCODTree *lastson = sons;
-		while ( lastson && lastson->next ) lastson=lastson->next;
-		if ( lastson ) {
-			lastson->next=data;
-		} else {
-			sons=data;
-		}
-	}
-
-};
-
-#endif
--- a/include/txtfield.hpp
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_TEXT_HPP_
-#define _TCOD_TEXT_HPP_
-
-#include "color.hpp"
-
-class TCODLIB_API TCODText {
-public :
-	TCODText(int x, int y, int w, int h, int max_chars);
-	~TCODText();
-	void setProperties(int cursor_char, int blink_interval, const char * prompt, int tab_size);
-	void setColors(TCODColor fore, TCODColor back, float back_transparency);
-	bool update(TCOD_key_t key);
-	void render(TCODConsole * con);
-	const char *getText();
-	void reset();
-protected :
-	TCOD_text_t data;
-};
-
-
-#endif
--- a/include/zip.hpp
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_ZIP_HPP
-#define _TCOD_ZIP_HPP
-
-/**
- @PageName zip
- @PageCategory Base toolkits
- @PageTitle Compression toolkit
- @PageDesc This toolkit provides functions to save or read compressed data from a file. While the module is named Zip, it has nothing to do with the .zip format as it uses zlib compression (.gz format).
-	Note that this modules has no python wrapper. Use python built-in zip module instead.
-	
-	You can use the compression buffer in two modes:
-	* put data in the buffer, then save it to a file,
-	* load a file into the buffer, then get data from it.
- */
-class TCODLIB_API TCODZip {
-public :
-
-	/**
-	@PageName zip_init
-	@PageFather zip
-	@PageTitle Creating a compression buffer
-	@FuncDesc This function initializes a compression buffer.
-	@Cpp TCODZip::TCODZip()
-	@C TCOD_zip_t TCOD_zip_new()	
-	*/	
-	TCODZip();
-	
-	/**
-	@PageName zip_init
-	@FuncDesc Once you don't need the buffer anymore, you can release resources. Note that the adresses returned by the getString function are no longer valid once the buffer has been destroyed.
-	@Cpp TCODZip::~TCODZip()
-	@C void TCOD_zip_delete(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@CppEx 
-		TCODZip *zip = new TCODZip();
-		zip->loadFromFile("myCompressedFile.gz");
-		char c=zip->getChar();
-		int i=zip->getInt();
-		float f= zip->getFloat();
-		const char *s=strdup(zip->getString()); // we duplicate the string to be able to use it after the buffer deletion
-		zip->getData(nbBytes, dataPtr);
-		delete zip;
-	@CEx 
-		TCOD_zip_t zip=TCOD_zip_new();
-		TCOD_zip_load_from_file(zip,"myCompressedFile.gz");
-		char c=TCOD_zip_get_char(zip);
-		int i=TCOD_zip_get_int(zip);
-		float f=TCOD_zip_get_float(zip);
-		const char *s=strdup(TCOD_zip_get_string(zip));
-		TCOD_zip_get_data(zip,nbBytes, dataPtr);
-		TCOD_zip_delete(zip);	
-	*/	
-	~TCODZip();
-
-	/**
-	@PageName zip_put
-	@PageFather zip
-	@PageTitle Using the buffer in output mode
-	@FuncTitle Putting a char in the buffer
-	@Cpp void TCODZip::putChar(char val)
-	@C void TCOD_zip_put_char(TCOD_zip_t zip, char val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	A 8 bits value to store in the buffer
-	*/	
-	void putChar(char val);
-	
-	/**
-	@PageName zip_put
-	@FuncTitle Putting an integer in the buffer
-	@Cpp void TCODZip::putInt(int val)
-	@C void TCOD_zip_put_int(TCOD_zip_t zip, int val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	An integer value to store in the buffer
-	*/	
-	void putInt(int val);
-
-	/**
-	@PageName zip_put
-	@FuncTitle Putting a floating point value in the buffer
-	@Cpp void TCODZip::putFloat(float val)
-	@C void TCOD_zip_put_float(TCOD_zip_t zip, float val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	A float value to store in the buffer
-	*/
-	void putFloat(float val);
-
-	/**
-	@PageName zip_put
-	@FuncTitle Putting a string in the buffer
-	@Cpp void TCODZip::putString(const char *val)
-	@C void TCOD_zip_put_string(TCOD_zip_t zip, const char *val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	A string to store in the buffer
-	*/
-	void putString(const char *val);
-
-   	/**
-	@PageName zip_put
-	@FuncTitle Putting a color in the buffer
-	@Cpp void TCODZip::putColor(const TCODColor *val)
-	@C void TCOD_zip_put_color(TCOD_zip_t zip, const TCOD_color_t val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	A color to store in the buffer
-	*/
-	void putColor(const TCODColor *val);
-
-	/**
-	@PageName zip_put
-	@FuncTitle Putting an image in the buffer
-	@Cpp void TCODZip::putImage(const TCODImage *val)
-	@C void TCOD_zip_put_image(TCOD_zip_t zip, const TCOD_image_t val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	An image to store in the buffer
-	*/
-	void putImage(const TCODImage *val);
-
-	/**
-	@PageName zip_put
-	@FuncTitle Putting a console in the buffer
-	@Cpp void TCODZip::putConsole(const TCODConsole *val)
-	@C void TCOD_zip_put_console(TCOD_zip_t zip, const TCOD_console_t val)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param val	A console to store in the buffer
-	*/
-	void putConsole(const TCODConsole *val);
-
-	/**
-	@PageName zip_put
-	@FuncTitle Putting some custom data in the buffer
-	@Cpp void TCODZip::putData(int nbBytes, const void *data)
-	@C void TCOD_zip_put_data(TCOD_zip_t zip, int nbBytes, const void *data)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param nbBytes	Number of bytes to store in the buffer
-	@Param val	Address of the data to store in the buffer
-	*/
-	void putData(int nbBytes, const void *data);
-
-	/**
-	@PageName zip_put
-	@FuncTitle Reading the number of (uncompressed) bytes in the buffer
-	@Cpp uint32 TCODZip::getCurrentBytes()
-	@C uint32 TCOD_zip_get_current_bytes(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	uint32 getCurrentBytes() const;
-	
-	/**
-	@PageName zip_put
-	@FuncTitle Saving the buffer on disk
-	@FuncDesc Once you have finished adding data in the buffer, you can compress it and save it in a file.
-		The function returns the number of (uncompressed) bytes saved.
-	@Cpp int TCODZip::saveToFile(const char *filename)
-	@C int TCOD_zip_save_to_file(TCOD_zip_t zip, const char *filename)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param filename	Name of the file
-	@CppEx 
-		TCODZip zip;
-		zip.putChar('A');
-		zip.putInt(1764);
-		zip.putFloat(3.14f);
-		zip.putString("A string");
-		zip.putData(nbBytes, dataPtr);
-		zip.saveToFile("myCompressedFile.gz");
-	@CEx 
-		TCOD_zip_t zip=TCOD_zip_new();
-		TCOD_zip_put_char(zip,'A');
-		TCOD_zip_put_int(zip,1764);
-		TCOD_zip_put_float(zip,3.14f);
-		TCOD_zip_put_string(zip,"A string");
-		TCOD_zip_put_data(zip,nbBytes, dataPtr);
-		TCOD_zip_save_to_file(zip,"myCompressedFile.gz");
-	*/	
-	int saveToFile(const char *filename);
-
-	/**
-	@PageName zip_load
-	@PageTitle Using the buffer in input mode
-	@PageFather zip
-	@FuncTitle Reading from a compressed file
-	@FuncDesc You can read data from a file (compressed or not) into the buffer.
-		The function returns the number of (uncompressed) bytes read or 0 if an error occured. 
-	@Cpp int TCODZip::loadFromFile(const char *filename)
-	@C int TCOD_zip_load_from_file(TCOD_zip_t zip, const char *filename)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param filename	Name of the file
-	*/	
-	int loadFromFile(const char *filename);
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading a char from the buffer
-	@Cpp char TCODZip::getChar()
-	@C char TCOD_zip_get_char(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor
-	*/	
-	char getChar();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading an integer from the buffer
-	@Cpp int TCODZip::getInt()
-	@C int TCOD_zip_get_int(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	int getInt();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading a floating point value from the buffer
-	@Cpp float TCODZip::getFloat()
-	@C float TCOD_zip_get_float(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	float getFloat();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading a string from the buffer
-	@FuncDesc The address returned is in the buffer. It is valid as long as you don't destroy the buffer.
-	@Cpp const char *TCODZip::getString()
-	@C const char *TCOD_zip_get_string(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	const char *getString();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading a color from the buffer
-	@Cpp TCODColor TCODZip::getColor()
-	@C TCOD_color_t TCOD_zip_get_color(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	TCODColor getColor();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading a color from the buffer
-	@Cpp TCODImage *TCODZip::getImage()
-	@C TCOD_image_t TCOD_zip_get_image(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	TCODImage *getImage();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading a console from the buffer
-	@Cpp TCODConsole *TCODZip::getConsole()
-	@C TCOD_console_t TCOD_zip_get_console(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	TCODConsole *getConsole();
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Reading some custom data from the buffer
-	@FuncDesc Note that the getData length must match the length of the data when the file was created (with putData).
-		The function returns the number of bytes that were stored in the file by the putData call. If more than nbBytes were stored, the function read only nbBytes and skip the rest of them.
-	@Cpp int TCODZip::getData(int nbBytes, void *data)
-	@C int TCOD_zip_get_data(TCOD_zip_t zip, int nbBytes, void *data)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param nbBytes	Number of bytes to read
-	@Param data	Address of a pre-allocated buffer (at least nbBytes bytes)
-	@CppEx 
-		TCODZip zip;
-		zip.loadFromFile("myCompressedFile.gz");
-		char c=zip.getChar();
-		int i=zip.getInt();
-		float f= zip.getFloat();
-		const char *s=zip.getString();
-		zip.getData(nbBytes, dataPtr);
-	@CEx 
-		TCOD_zip_t zip=TCOD_zip_new();
-		TCOD_zip_load_from_file(zip,"myCompressedFile.gz");
-		char c=TCOD_zip_get_char(zip);
-		int i=TCOD_zip_get_int(zip);
-		float f=TCOD_zip_get_float(zip);
-		const char *s=TCOD_zip_get_string(zip);
-		TCOD_zip_get_data(zip,nbBytes, dataPtr);
-	*/	
-	int getData(int nbBytes, void *data);
-	
-	/**
-	@PageName zip_load
-	@FuncTitle Getting the number of remaining bytes in the buffer
-	@Cpp uint32 TCODZip::getRemainingBytes() const
-	@C uint32 TCOD_zip_get_remaining_bytes(TCOD_zip_t zip)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	*/	
-	uint32 getRemainingBytes() const;
-
-	/**
-	@PageName zip_load
-	@FuncTitle Skiping some bytes in the buffer
-	@Cpp void TCODZip::skipBytes(uint32 nbBytes)
-	@C void TCOD_zip_skip_bytes(TCOD_zip_t zip, uint32 nbBytes)
-	@Param zip	In the C version, the buffer handler, returned by the constructor.
-	@Param nbBytes number of uncompressed bytes to skip
-	*/	
-	void skipBytes(uint32 nbBytes);
-protected :
-	TCOD_zip_t data;
-};
-
-#endif
--- a/include/libtcod.hpp
+++ b/include/libtcod.hpp
@@ -28,24 +28,24 @@
 #ifndef _TCODLIB_HPP
 #define _TCODLIB_HPP
 
-#include "libtcod.h"
-#include "list.hpp"
-#include "color.hpp"
-#include "console.hpp"
-#include "image.hpp"
-#include "sys.hpp"
-#include "mersenne.hpp"
-#include "mouse.hpp"
-#include "bresenham.hpp"
-#include "noise.hpp"
-#include "fov.hpp"
-#include "path.hpp"
-#include "lex.hpp"
-#include "parser.hpp"
-#include "tree.hpp"
-#include "bsp.hpp"
-#include "heightmap.hpp"
-#include "zip.hpp"
-#include "namegen.hpp"
-#include "txtfield.hpp"
+#include <libtcod.h>
+#include <libtcod/list.hpp>
+#include <libtcod/color.hpp>
+#include <libtcod/console.hpp>
+#include <libtcod/image.hpp>
+#include <libtcod/sys.hpp>
+#include <libtcod/mersenne.hpp>
+#include <libtcod/mouse.hpp>
+#include <libtcod/bresenham.hpp>
+#include <libtcod/noise.hpp>
+#include <libtcod/fov.hpp>
+#include <libtcod/path.hpp>
+#include <libtcod/lex.hpp>
+#include <libtcod/parser.hpp>
+#include <libtcod/tree.hpp>
+#include <libtcod/bsp.hpp>
+#include <libtcod/heightmap.hpp>
+#include <libtcod/zip.hpp>
+#include <libtcod/namegen.hpp>
+#include <libtcod/txtfield.hpp>
 #endif
--- /dev/null
+++ b/include/libtcod/mersenne_types.h
@@ -0,0 +1,53 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_RANDOM_TYPES_H
+#define _TCOD_RANDOM_TYPES_H
+
+/* dice roll */
+typedef struct {
+	int nb_rolls;
+	int nb_faces;
+	float multiplier;
+	float addsub;
+} TCOD_dice_t;
+
+/* PRNG algorithms */
+typedef enum {
+    TCOD_RNG_MT,
+    TCOD_RNG_CMWC
+} TCOD_random_algo_t;
+
+typedef enum {
+	TCOD_DISTRIBUTION_LINEAR,
+	TCOD_DISTRIBUTION_GAUSSIAN,
+	TCOD_DISTRIBUTION_GAUSSIAN_RANGE,
+	TCOD_DISTRIBUTION_GAUSSIAN_INVERSE,
+	TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE
+} TCOD_distribution_t;
+
+#endif /* _TCOD_RANDOM_TYPES_H */
--- /dev/null
+++ b/include/libtcod/mouse_types.h
@@ -0,0 +1,47 @@
+/*
+* libtcod 1.5.1
+* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above copyright
+*       notice, this list of conditions and the following disclaimer in the
+*       documentation and/or other materials provided with the distribution.
+*     * The name of Jice or Mingos may not be used to endorse or promote products
+*       derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _TCOD_MOUSE_TYPES_H
+#define _TCOD_MOUSE_TYPES_H
+
+/* mouse data */
+typedef struct {
+  int x,y; /* absolute position */
+  int dx,dy; /* movement since last update in pixels */
+  int cx,cy; /* cell coordinates in the root console */
+  int dcx,dcy; /* movement since last update in console cells */
+  bool lbutton ; /* left button status */
+  bool rbutton ; /* right button status */
+  bool mbutton ; /* middle button status */
+  bool lbutton_pressed ; /* left button pressed event */ 
+  bool rbutton_pressed ; /* right button pressed event */ 
+  bool mbutton_pressed ; /* middle button pressed event */ 
+  bool wheel_up ; /* wheel up event */
+  bool wheel_down ; /* wheel down event */
+} TCOD_mouse_t;
+
+#endif /* _TCOD_MOUSE_TYPES_H */
--- /dev/null
+++ b/include/libtcod/noise_defaults.h
@@ -0,0 +1,9 @@
+#ifndef _TCOD_NOISE_DEFAULTS
+#define _TCOD_NOISE_DEFAULTS
+
+#define TCOD_NOISE_MAX_OCTAVES			128
+#define TCOD_NOISE_MAX_DIMENSIONS		4
+#define TCOD_NOISE_DEFAULT_HURST        0.5f
+#define TCOD_NOISE_DEFAULT_LACUNARITY   2.0f
+
+#endif /* _TCOD_NOISE_DEFAULTS */
--- a/include/mersenne_types.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_RANDOM_TYPES_H
-#define _TCOD_RANDOM_TYPES_H
-
-/* dice roll */
-typedef struct {
-	int nb_rolls;
-	int nb_faces;
-	float multiplier;
-	float addsub;
-} TCOD_dice_t;
-
-/* PRNG algorithms */
-typedef enum {
-    TCOD_RNG_MT,
-    TCOD_RNG_CMWC
-} TCOD_random_algo_t;
-
-typedef enum {
-	TCOD_DISTRIBUTION_LINEAR,
-	TCOD_DISTRIBUTION_GAUSSIAN,
-	TCOD_DISTRIBUTION_GAUSSIAN_RANGE,
-	TCOD_DISTRIBUTION_GAUSSIAN_INVERSE,
-	TCOD_DISTRIBUTION_GAUSSIAN_RANGE_INVERSE
-} TCOD_distribution_t;
-
-#endif /* _TCOD_RANDOM_TYPES_H */
--- a/include/mouse_types.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
-* libtcod 1.5.1
-* Copyright (c) 2008,2009,2010,2012 Jice & Mingos
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above copyright
-*       notice, this list of conditions and the following disclaimer in the
-*       documentation and/or other materials provided with the distribution.
-*     * The name of Jice or Mingos may not be used to endorse or promote products
-*       derived from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY JICE AND MINGOS ``AS IS'' AND ANY
-* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL JICE OR MINGOS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef _TCOD_MOUSE_TYPES_H
-#define _TCOD_MOUSE_TYPES_H
-
-/* mouse data */
-typedef struct {
-  int x,y; /* absolute position */
-  int dx,dy; /* movement since last update in pixels */
-  int cx,cy; /* cell coordinates in the root console */
-  int dcx,dcy; /* movement since last update in console cells */
-  bool lbutton ; /* left button status */
-  bool rbutton ; /* right button status */
-  bool mbutton ; /* middle button status */
-  bool lbutton_pressed ; /* left button pressed event */ 
-  bool rbutton_pressed ; /* right button pressed event */ 
-  bool mbutton_pressed ; /* middle button pressed event */ 
-  bool wheel_up ; /* wheel up event */
-  bool wheel_down ; /* wheel down event */
-} TCOD_mouse_t;
-
-#endif /* _TCOD_MOUSE_TYPES_H */
--- a/include/noise_defaults.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef _TCOD_NOISE_DEFAULTS
-#define _TCOD_NOISE_DEFAULTS
-
-#define TCOD_NOISE_MAX_OCTAVES			128
-#define TCOD_NOISE_MAX_DIMENSIONS		4
-#define TCOD_NOISE_DEFAULT_HURST        0.5f
-#define TCOD_NOISE_DEFAULT_LACUNARITY   2.0f
-
-#endif /* _TCOD_NOISE_DEFAULTS */
